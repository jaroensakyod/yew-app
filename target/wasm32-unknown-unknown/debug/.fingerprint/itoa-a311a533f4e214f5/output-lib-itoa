{"message":"can't find crate for `core`","code":{"code":"E0463","explanation":"A plugin/crate was declared but cannot be found.\n\nErroneous code example:\n\n```compile_fail,E0463\n#![feature(plugin)]\n#![plugin(cookie_monster)] // error: can't find crate for `cookie_monster`\nextern crate cake_is_a_lie; // error: can't find crate for `cake_is_a_lie`\n```\n\nYou need to link your code to the relevant crate in order to be able to use it\n(through Cargo or the `-L` option of rustc example). Plugins are crates as\nwell, and you link to them the same way.\n\n## Common causes\n\n- The crate is not present at all. If using Cargo, add it to `[dependencies]`\n  in Cargo.toml.\n- The crate is present, but under a different name. If using Cargo, look for\n  `package = ` under `[dependencies]` in Cargo.toml.\n\n## Common causes for missing `std` or `core`\n\n- You are cross-compiling for a target which doesn't have `std` prepackaged.\n  Consider one of the following:\n  + Adding a pre-compiled version of std with `rustup target add`\n  + Building std from source with `cargo build -Z build-std`\n  + Using `#![no_std]` at the crate root, so you won't need `std` in the first\n    place.\n- You are developing the compiler itself and haven't built libstd from source.\n  You can usually build it with `x.py build library/std`. More information\n  about x.py is available in the [rustc-dev-guide].\n\n[rustc-dev-guide]: https://rustc-dev-guide.rust-lang.org/building/how-to-build-and-run.html#building-the-compiler\n"},"level":"error","spans":[{"file_name":"C:\\Users\\ASUS\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\itoa-1.0.1\\src\\lib.rs","byte_start":0,"byte_end":0,"line_start":1,"line_end":1,"column_start":1,"column_end":1,"is_primary":true,"text":[],"label":"can't find crate","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"the `wasm32-unknown-unknown` target may not be installed","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"consider downloading the target with `rustup target add wasm32-unknown-unknown`","code":null,"level":"help","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0463]\u001b[0m\u001b[0m\u001b[1m\u001b[38;5;15m: can't find crate for `core`\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m= \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;15mnote\u001b[0m\u001b[0m: the `wasm32-unknown-unknown` target may not be installed\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m= \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;15mhelp\u001b[0m\u001b[0m: consider downloading the target with `rustup target add wasm32-unknown-unknown`\u001b[0m\n\n"}
{"message":"can't find crate for `compiler_builtins`","code":{"code":"E0463","explanation":"A plugin/crate was declared but cannot be found.\n\nErroneous code example:\n\n```compile_fail,E0463\n#![feature(plugin)]\n#![plugin(cookie_monster)] // error: can't find crate for `cookie_monster`\nextern crate cake_is_a_lie; // error: can't find crate for `cake_is_a_lie`\n```\n\nYou need to link your code to the relevant crate in order to be able to use it\n(through Cargo or the `-L` option of rustc example). Plugins are crates as\nwell, and you link to them the same way.\n\n## Common causes\n\n- The crate is not present at all. If using Cargo, add it to `[dependencies]`\n  in Cargo.toml.\n- The crate is present, but under a different name. If using Cargo, look for\n  `package = ` under `[dependencies]` in Cargo.toml.\n\n## Common causes for missing `std` or `core`\n\n- You are cross-compiling for a target which doesn't have `std` prepackaged.\n  Consider one of the following:\n  + Adding a pre-compiled version of std with `rustup target add`\n  + Building std from source with `cargo build -Z build-std`\n  + Using `#![no_std]` at the crate root, so you won't need `std` in the first\n    place.\n- You are developing the compiler itself and haven't built libstd from source.\n  You can usually build it with `x.py build library/std`. More information\n  about x.py is available in the [rustc-dev-guide].\n\n[rustc-dev-guide]: https://rustc-dev-guide.rust-lang.org/building/how-to-build-and-run.html#building-the-compiler\n"},"level":"error","spans":[{"file_name":"C:\\Users\\ASUS\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\itoa-1.0.1\\src\\lib.rs","byte_start":0,"byte_end":0,"line_start":1,"line_end":1,"column_start":1,"column_end":1,"is_primary":true,"text":[],"label":"can't find crate","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0463]\u001b[0m\u001b[0m\u001b[1m\u001b[38;5;15m: can't find crate for `compiler_builtins`\u001b[0m\n\n"}
{"message":"can't find crate for `core`","code":{"code":"E0463","explanation":"A plugin/crate was declared but cannot be found.\n\nErroneous code example:\n\n```compile_fail,E0463\n#![feature(plugin)]\n#![plugin(cookie_monster)] // error: can't find crate for `cookie_monster`\nextern crate cake_is_a_lie; // error: can't find crate for `cake_is_a_lie`\n```\n\nYou need to link your code to the relevant crate in order to be able to use it\n(through Cargo or the `-L` option of rustc example). Plugins are crates as\nwell, and you link to them the same way.\n\n## Common causes\n\n- The crate is not present at all. If using Cargo, add it to `[dependencies]`\n  in Cargo.toml.\n- The crate is present, but under a different name. If using Cargo, look for\n  `package = ` under `[dependencies]` in Cargo.toml.\n\n## Common causes for missing `std` or `core`\n\n- You are cross-compiling for a target which doesn't have `std` prepackaged.\n  Consider one of the following:\n  + Adding a pre-compiled version of std with `rustup target add`\n  + Building std from source with `cargo build -Z build-std`\n  + Using `#![no_std]` at the crate root, so you won't need `std` in the first\n    place.\n- You are developing the compiler itself and haven't built libstd from source.\n  You can usually build it with `x.py build library/std`. More information\n  about x.py is available in the [rustc-dev-guide].\n\n[rustc-dev-guide]: https://rustc-dev-guide.rust-lang.org/building/how-to-build-and-run.html#building-the-compiler\n"},"level":"error","spans":[{"file_name":"C:\\Users\\ASUS\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\itoa-1.0.1\\src\\lib.rs","byte_start":2577,"byte_end":2581,"line_start":44,"line_end":44,"column_start":5,"column_end":9,"is_primary":true,"text":[{"text":"use core::mem::{self, MaybeUninit};","highlight_start":5,"highlight_end":9}],"label":"can't find crate","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"the `wasm32-unknown-unknown` target may not be installed","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"consider downloading the target with `rustup target add wasm32-unknown-unknown`","code":null,"level":"help","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0463]\u001b[0m\u001b[0m\u001b[1m\u001b[38;5;15m: can't find crate for `core`\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m--> \u001b[0m\u001b[0mC:\\Users\\ASUS\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\itoa-1.0.1\\src\\lib.rs:44:5\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14m44\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m| \u001b[0m\u001b[0muse core::mem::{self, MaybeUninit};\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m| \u001b[0m\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9mcan't find crate\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m= \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;15mnote\u001b[0m\u001b[0m: the `wasm32-unknown-unknown` target may not be installed\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m= \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;15mhelp\u001b[0m\u001b[0m: consider downloading the target with `rustup target add wasm32-unknown-unknown`\u001b[0m\n\n"}
{"message":"can't find crate for `core`","code":{"code":"E0463","explanation":"A plugin/crate was declared but cannot be found.\n\nErroneous code example:\n\n```compile_fail,E0463\n#![feature(plugin)]\n#![plugin(cookie_monster)] // error: can't find crate for `cookie_monster`\nextern crate cake_is_a_lie; // error: can't find crate for `cake_is_a_lie`\n```\n\nYou need to link your code to the relevant crate in order to be able to use it\n(through Cargo or the `-L` option of rustc example). Plugins are crates as\nwell, and you link to them the same way.\n\n## Common causes\n\n- The crate is not present at all. If using Cargo, add it to `[dependencies]`\n  in Cargo.toml.\n- The crate is present, but under a different name. If using Cargo, look for\n  `package = ` under `[dependencies]` in Cargo.toml.\n\n## Common causes for missing `std` or `core`\n\n- You are cross-compiling for a target which doesn't have `std` prepackaged.\n  Consider one of the following:\n  + Adding a pre-compiled version of std with `rustup target add`\n  + Building std from source with `cargo build -Z build-std`\n  + Using `#![no_std]` at the crate root, so you won't need `std` in the first\n    place.\n- You are developing the compiler itself and haven't built libstd from source.\n  You can usually build it with `x.py build library/std`. More information\n  about x.py is available in the [rustc-dev-guide].\n\n[rustc-dev-guide]: https://rustc-dev-guide.rust-lang.org/building/how-to-build-and-run.html#building-the-compiler\n"},"level":"error","spans":[{"file_name":"C:\\Users\\ASUS\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\itoa-1.0.1\\src\\lib.rs","byte_start":2613,"byte_end":2617,"line_start":45,"line_end":45,"column_start":5,"column_end":9,"is_primary":true,"text":[{"text":"use core::{ptr, slice, str};","highlight_start":5,"highlight_end":9}],"label":"can't find crate","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"the `wasm32-unknown-unknown` target may not be installed","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"consider downloading the target with `rustup target add wasm32-unknown-unknown`","code":null,"level":"help","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0463]\u001b[0m\u001b[0m\u001b[1m\u001b[38;5;15m: can't find crate for `core`\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m--> \u001b[0m\u001b[0mC:\\Users\\ASUS\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\itoa-1.0.1\\src\\lib.rs:45:5\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14m45\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m| \u001b[0m\u001b[0muse core::{ptr, slice, str};\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m| \u001b[0m\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9mcan't find crate\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m= \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;15mnote\u001b[0m\u001b[0m: the `wasm32-unknown-unknown` target may not be installed\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m= \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;15mhelp\u001b[0m\u001b[0m: consider downloading the target with `rustup target add wasm32-unknown-unknown`\u001b[0m\n\n"}
{"message":"cannot find macro `debug_assert_eq` in this scope","code":null,"level":"error","spans":[{"file_name":"C:\\Users\\ASUS\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\itoa-1.0.1\\src\\udiv128.rs","byte_start":1230,"byte_end":1245,"line_start":39,"line_end":39,"column_start":5,"column_end":20,"is_primary":true,"text":[{"text":"    debug_assert_eq!(quot, n / d as u128);","highlight_start":5,"highlight_end":20}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror\u001b[0m\u001b[0m\u001b[1m\u001b[38;5;15m: cannot find macro `debug_assert_eq` in this scope\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m--> \u001b[0m\u001b[0mC:\\Users\\ASUS\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\itoa-1.0.1\\src\\udiv128.rs:39:5\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14m39\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m| \u001b[0m\u001b[0m    debug_assert_eq!(quot, n / d as u128);\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m| \u001b[0m\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^^^^^^^^^^\u001b[0m\n\n"}
{"message":"cannot find macro `debug_assert_eq` in this scope","code":null,"level":"error","spans":[{"file_name":"C:\\Users\\ASUS\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\itoa-1.0.1\\src\\udiv128.rs","byte_start":1273,"byte_end":1288,"line_start":40,"line_end":40,"column_start":5,"column_end":20,"is_primary":true,"text":[{"text":"    debug_assert_eq!(rem as u128, n % d as u128);","highlight_start":5,"highlight_end":20}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror\u001b[0m\u001b[0m\u001b[1m\u001b[38;5;15m: cannot find macro `debug_assert_eq` in this scope\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m--> \u001b[0m\u001b[0mC:\\Users\\ASUS\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\itoa-1.0.1\\src\\udiv128.rs:40:5\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14m40\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m| \u001b[0m\u001b[0m    debug_assert_eq!(rem as u128, n % d as u128);\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m| \u001b[0m\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^^^^^^^^^^\u001b[0m\n\n"}
{"message":"failed to resolve: use of undeclared type `MaybeUninit`","code":{"code":"E0433","explanation":"An undeclared crate, module, or type was used.\n\nErroneous code example:\n\n```compile_fail,E0433\nlet map = HashMap::new();\n// error: failed to resolve: use of undeclared type `HashMap`\n```\n\nPlease verify you didn't misspell the type/module's name or that you didn't\nforget to import it:\n\n```\nuse std::collections::HashMap; // HashMap has been imported.\nlet map: HashMap<u32, u32> = HashMap::new(); // So it can be used!\n```\n\nIf you've expected to use a crate name:\n\n```compile_fail\nuse ferris_wheel::BigO;\n// error: failed to resolve: use of undeclared crate or module `ferris_wheel`\n```\n\nMake sure the crate has been added as a dependency in `Cargo.toml`.\n\nTo use a module from your current crate, add the `crate::` prefix to the path.\n"},"level":"error","spans":[{"file_name":"C:\\Users\\ASUS\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\itoa-1.0.1\\src\\lib.rs","byte_start":3329,"byte_end":3340,"line_start":80,"line_end":80,"column_start":22,"column_end":33,"is_primary":true,"text":[{"text":"        let bytes = [MaybeUninit::<u8>::uninit(); I128_MAX_LEN];","highlight_start":22,"highlight_end":33}],"label":"use of undeclared type `MaybeUninit`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0433]\u001b[0m\u001b[0m\u001b[1m\u001b[38;5;15m: failed to resolve: use of undeclared type `MaybeUninit`\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m--> \u001b[0m\u001b[0mC:\\Users\\ASUS\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\itoa-1.0.1\\src\\lib.rs:80:22\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14m80\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m| \u001b[0m\u001b[0m        let bytes = [MaybeUninit::<u8>::uninit(); I128_MAX_LEN];\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m| \u001b[0m\u001b[0m                     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9muse of undeclared type `MaybeUninit`\u001b[0m\n\n"}
{"message":"failed to resolve: use of undeclared crate or module `mem`","code":{"code":"E0433","explanation":"An undeclared crate, module, or type was used.\n\nErroneous code example:\n\n```compile_fail,E0433\nlet map = HashMap::new();\n// error: failed to resolve: use of undeclared type `HashMap`\n```\n\nPlease verify you didn't misspell the type/module's name or that you didn't\nforget to import it:\n\n```\nuse std::collections::HashMap; // HashMap has been imported.\nlet map: HashMap<u32, u32> = HashMap::new(); // So it can be used!\n```\n\nIf you've expected to use a crate name:\n\n```compile_fail\nuse ferris_wheel::BigO;\n// error: failed to resolve: use of undeclared crate or module `ferris_wheel`\n```\n\nMake sure the crate has been added as a dependency in `Cargo.toml`.\n\nTo use a module from your current crate, add the `crate::` prefix to the path.\n"},"level":"error","spans":[{"file_name":"C:\\Users\\ASUS\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\itoa-1.0.1\\src\\lib.rs","byte_start":5578,"byte_end":5581,"line_start":139,"line_end":139,"column_start":24,"column_end":27,"is_primary":true,"text":[{"text":"                    if mem::size_of::<$t>() >= 2 {","highlight_start":24,"highlight_end":27}],"label":"use of undeclared crate or module `mem`","suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"C:\\Users\\ASUS\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\itoa-1.0.1\\src\\lib.rs","byte_start":7757,"byte_end":7922,"line_start":197,"line_end":204,"column_start":1,"column_end":12,"is_primary":false,"text":[{"text":"impl_Integer!(","highlight_start":1,"highlight_end":15},{"text":"    I8_MAX_LEN => i8,","highlight_start":1,"highlight_end":22},{"text":"    U8_MAX_LEN => u8,","highlight_start":1,"highlight_end":22},{"text":"    I16_MAX_LEN => i16,","highlight_start":1,"highlight_end":24},{"text":"    U16_MAX_LEN => u16,","highlight_start":1,"highlight_end":24},{"text":"    I32_MAX_LEN => i32,","highlight_start":1,"highlight_end":24},{"text":"    U32_MAX_LEN => u32","highlight_start":1,"highlight_end":23},{"text":"    as u32);","highlight_start":1,"highlight_end":12}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"impl_Integer!","def_site_span":{"file_name":"C:\\Users\\ASUS\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\itoa-1.0.1\\src\\lib.rs","byte_start":4595,"byte_end":7512,"line_start":116,"line_end":186,"column_start":1,"column_end":2,"is_primary":false,"text":[{"text":"macro_rules! impl_Integer {","highlight_start":1,"highlight_end":28},{"text":"    ($($max_len:expr => $t:ident),* as $conv_fn:ident) => {$(","highlight_start":1,"highlight_end":62},{"text":"        impl Integer for $t {}","highlight_start":1,"highlight_end":31},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        impl private::Sealed for $t {","highlight_start":1,"highlight_end":38},{"text":"            type Buffer = [MaybeUninit<u8>; $max_len];","highlight_start":1,"highlight_end":55},{"text":"","highlight_start":1,"highlight_end":1},{"text":"            #[allow(unused_comparisons)]","highlight_start":1,"highlight_end":41},{"text":"            #[inline]","highlight_start":1,"highlight_end":22},{"text":"            fn write(self, buf: &mut [MaybeUninit<u8>; $max_len]) -> &str {","highlight_start":1,"highlight_end":76},{"text":"                let is_nonnegative = self >= 0;","highlight_start":1,"highlight_end":48},{"text":"                let mut n = if is_nonnegative {","highlight_start":1,"highlight_end":48},{"text":"                    self as $conv_fn","highlight_start":1,"highlight_end":37},{"text":"                } else {","highlight_start":1,"highlight_end":25},{"text":"                    // convert the negative num to positive by summing 1 to it's 2 complement","highlight_start":1,"highlight_end":94},{"text":"                    (!(self as $conv_fn)).wrapping_add(1)","highlight_start":1,"highlight_end":58},{"text":"                };","highlight_start":1,"highlight_end":19},{"text":"                let mut curr = buf.len() as isize;","highlight_start":1,"highlight_end":51},{"text":"                let buf_ptr = buf.as_mut_ptr() as *mut u8;","highlight_start":1,"highlight_end":59},{"text":"                let lut_ptr = DEC_DIGITS_LUT.as_ptr();","highlight_start":1,"highlight_end":55},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                unsafe {","highlight_start":1,"highlight_end":25},{"text":"                    // need at least 16 bits for the 4-characters-at-a-time to work.","highlight_start":1,"highlight_end":85},{"text":"                    if mem::size_of::<$t>() >= 2 {","highlight_start":1,"highlight_end":51},{"text":"                        // eagerly decode 4 characters at a time","highlight_start":1,"highlight_end":65},{"text":"                        while n >= 10000 {","highlight_start":1,"highlight_end":43},{"text":"                            let rem = (n % 10000) as isize;","highlight_start":1,"highlight_end":60},{"text":"                            n /= 10000;","highlight_start":1,"highlight_end":40},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                            let d1 = (rem / 100) << 1;","highlight_start":1,"highlight_end":55},{"text":"                            let d2 = (rem % 100) << 1;","highlight_start":1,"highlight_end":55},{"text":"                            curr -= 4;","highlight_start":1,"highlight_end":39},{"text":"                            ptr::copy_nonoverlapping(lut_ptr.offset(d1), buf_ptr.offset(curr), 2);","highlight_start":1,"highlight_end":99},{"text":"                            ptr::copy_nonoverlapping(lut_ptr.offset(d2), buf_ptr.offset(curr + 2), 2);","highlight_start":1,"highlight_end":103},{"text":"                        }","highlight_start":1,"highlight_end":26},{"text":"                    }","highlight_start":1,"highlight_end":22},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                    // if we reach here numbers are <= 9999, so at most 4 chars long","highlight_start":1,"highlight_end":85},{"text":"                    let mut n = n as isize; // possibly reduce 64bit math","highlight_start":1,"highlight_end":74},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                    // decode 2 more chars, if > 2 chars","highlight_start":1,"highlight_end":57},{"text":"                    if n >= 100 {","highlight_start":1,"highlight_end":34},{"text":"                        let d1 = (n % 100) << 1;","highlight_start":1,"highlight_end":49},{"text":"                        n /= 100;","highlight_start":1,"highlight_end":34},{"text":"                        curr -= 2;","highlight_start":1,"highlight_end":35},{"text":"                        ptr::copy_nonoverlapping(lut_ptr.offset(d1), buf_ptr.offset(curr), 2);","highlight_start":1,"highlight_end":95},{"text":"                    }","highlight_start":1,"highlight_end":22},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                    // decode last 1 or 2 chars","highlight_start":1,"highlight_end":48},{"text":"                    if n < 10 {","highlight_start":1,"highlight_end":32},{"text":"                        curr -= 1;","highlight_start":1,"highlight_end":35},{"text":"                        *buf_ptr.offset(curr) = (n as u8) + b'0';","highlight_start":1,"highlight_end":66},{"text":"                    } else {","highlight_start":1,"highlight_end":29},{"text":"                        let d1 = n << 1;","highlight_start":1,"highlight_end":41},{"text":"                        curr -= 2;","highlight_start":1,"highlight_end":35},{"text":"                        ptr::copy_nonoverlapping(lut_ptr.offset(d1), buf_ptr.offset(curr), 2);","highlight_start":1,"highlight_end":95},{"text":"                    }","highlight_start":1,"highlight_end":22},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                    if !is_nonnegative {","highlight_start":1,"highlight_end":41},{"text":"                        curr -= 1;","highlight_start":1,"highlight_end":35},{"text":"                        *buf_ptr.offset(curr) = b'-';","highlight_start":1,"highlight_end":54},{"text":"                    }","highlight_start":1,"highlight_end":22},{"text":"                }","highlight_start":1,"highlight_end":18},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                let len = buf.len() - curr as usize;","highlight_start":1,"highlight_end":53},{"text":"                let bytes = unsafe { slice::from_raw_parts(buf_ptr.offset(curr), len) };","highlight_start":1,"highlight_end":89},{"text":"                unsafe { str::from_utf8_unchecked(bytes) }","highlight_start":1,"highlight_end":59},{"text":"            }","highlight_start":1,"highlight_end":14},{"text":"        }","highlight_start":1,"highlight_end":10},{"text":"    )*};","highlight_start":1,"highlight_end":9},{"text":"}","highlight_start":1,"highlight_end":2}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}}],"children":[],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0433]\u001b[0m\u001b[0m\u001b[1m\u001b[38;5;15m: failed to resolve: use of undeclared crate or module `mem`\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m--> \u001b[0m\u001b[0mC:\\Users\\ASUS\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\itoa-1.0.1\\src\\lib.rs:139:24\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14m139\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m| \u001b[0m\u001b[0m  \u001b[0m\u001b[0m                    if mem::size_of::<$t>() >= 2 {\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m| \u001b[0m\u001b[0m                         \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9muse of undeclared crate or module `mem`\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14m...\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14m197\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m| \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m/\u001b[0m\u001b[0m \u001b[0m\u001b[0mimpl_Integer!(\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14m198\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m| \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    I8_MAX_LEN => i8,\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14m199\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m| \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    U8_MAX_LEN => u8,\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14m200\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m| \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    I16_MAX_LEN => i16,\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14m...\u001b[0m\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14m203\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m| \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    U32_MAX_LEN => u32\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14m204\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m| \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    as u32);\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m| \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|___________-\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14min this macro invocation\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m= \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;15mnote\u001b[0m\u001b[0m: this error originates in the macro `impl_Integer` (in Nightly builds, run with -Z macro-backtrace for more info)\u001b[0m\n\n"}
{"message":"failed to resolve: use of undeclared crate or module `ptr`","code":{"code":"E0433","explanation":"An undeclared crate, module, or type was used.\n\nErroneous code example:\n\n```compile_fail,E0433\nlet map = HashMap::new();\n// error: failed to resolve: use of undeclared type `HashMap`\n```\n\nPlease verify you didn't misspell the type/module's name or that you didn't\nforget to import it:\n\n```\nuse std::collections::HashMap; // HashMap has been imported.\nlet map: HashMap<u32, u32> = HashMap::new(); // So it can be used!\n```\n\nIf you've expected to use a crate name:\n\n```compile_fail\nuse ferris_wheel::BigO;\n// error: failed to resolve: use of undeclared crate or module `ferris_wheel`\n```\n\nMake sure the crate has been added as a dependency in `Cargo.toml`.\n\nTo use a module from your current crate, add the `crate::` prefix to the path.\n"},"level":"error","spans":[{"file_name":"C:\\Users\\ASUS\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\itoa-1.0.1\\src\\lib.rs","byte_start":5992,"byte_end":5995,"line_start":148,"line_end":148,"column_start":29,"column_end":32,"is_primary":true,"text":[{"text":"                            ptr::copy_nonoverlapping(lut_ptr.offset(d1), buf_ptr.offset(curr), 2);","highlight_start":29,"highlight_end":32}],"label":"use of undeclared crate or module `ptr`","suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"C:\\Users\\ASUS\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\itoa-1.0.1\\src\\lib.rs","byte_start":7757,"byte_end":7922,"line_start":197,"line_end":204,"column_start":1,"column_end":12,"is_primary":false,"text":[{"text":"impl_Integer!(","highlight_start":1,"highlight_end":15},{"text":"    I8_MAX_LEN => i8,","highlight_start":1,"highlight_end":22},{"text":"    U8_MAX_LEN => u8,","highlight_start":1,"highlight_end":22},{"text":"    I16_MAX_LEN => i16,","highlight_start":1,"highlight_end":24},{"text":"    U16_MAX_LEN => u16,","highlight_start":1,"highlight_end":24},{"text":"    I32_MAX_LEN => i32,","highlight_start":1,"highlight_end":24},{"text":"    U32_MAX_LEN => u32","highlight_start":1,"highlight_end":23},{"text":"    as u32);","highlight_start":1,"highlight_end":12}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"impl_Integer!","def_site_span":{"file_name":"C:\\Users\\ASUS\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\itoa-1.0.1\\src\\lib.rs","byte_start":4595,"byte_end":7512,"line_start":116,"line_end":186,"column_start":1,"column_end":2,"is_primary":false,"text":[{"text":"macro_rules! impl_Integer {","highlight_start":1,"highlight_end":28},{"text":"    ($($max_len:expr => $t:ident),* as $conv_fn:ident) => {$(","highlight_start":1,"highlight_end":62},{"text":"        impl Integer for $t {}","highlight_start":1,"highlight_end":31},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        impl private::Sealed for $t {","highlight_start":1,"highlight_end":38},{"text":"            type Buffer = [MaybeUninit<u8>; $max_len];","highlight_start":1,"highlight_end":55},{"text":"","highlight_start":1,"highlight_end":1},{"text":"            #[allow(unused_comparisons)]","highlight_start":1,"highlight_end":41},{"text":"            #[inline]","highlight_start":1,"highlight_end":22},{"text":"            fn write(self, buf: &mut [MaybeUninit<u8>; $max_len]) -> &str {","highlight_start":1,"highlight_end":76},{"text":"                let is_nonnegative = self >= 0;","highlight_start":1,"highlight_end":48},{"text":"                let mut n = if is_nonnegative {","highlight_start":1,"highlight_end":48},{"text":"                    self as $conv_fn","highlight_start":1,"highlight_end":37},{"text":"                } else {","highlight_start":1,"highlight_end":25},{"text":"                    // convert the negative num to positive by summing 1 to it's 2 complement","highlight_start":1,"highlight_end":94},{"text":"                    (!(self as $conv_fn)).wrapping_add(1)","highlight_start":1,"highlight_end":58},{"text":"                };","highlight_start":1,"highlight_end":19},{"text":"                let mut curr = buf.len() as isize;","highlight_start":1,"highlight_end":51},{"text":"                let buf_ptr = buf.as_mut_ptr() as *mut u8;","highlight_start":1,"highlight_end":59},{"text":"                let lut_ptr = DEC_DIGITS_LUT.as_ptr();","highlight_start":1,"highlight_end":55},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                unsafe {","highlight_start":1,"highlight_end":25},{"text":"                    // need at least 16 bits for the 4-characters-at-a-time to work.","highlight_start":1,"highlight_end":85},{"text":"                    if mem::size_of::<$t>() >= 2 {","highlight_start":1,"highlight_end":51},{"text":"                        // eagerly decode 4 characters at a time","highlight_start":1,"highlight_end":65},{"text":"                        while n >= 10000 {","highlight_start":1,"highlight_end":43},{"text":"                            let rem = (n % 10000) as isize;","highlight_start":1,"highlight_end":60},{"text":"                            n /= 10000;","highlight_start":1,"highlight_end":40},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                            let d1 = (rem / 100) << 1;","highlight_start":1,"highlight_end":55},{"text":"                            let d2 = (rem % 100) << 1;","highlight_start":1,"highlight_end":55},{"text":"                            curr -= 4;","highlight_start":1,"highlight_end":39},{"text":"                            ptr::copy_nonoverlapping(lut_ptr.offset(d1), buf_ptr.offset(curr), 2);","highlight_start":1,"highlight_end":99},{"text":"                            ptr::copy_nonoverlapping(lut_ptr.offset(d2), buf_ptr.offset(curr + 2), 2);","highlight_start":1,"highlight_end":103},{"text":"                        }","highlight_start":1,"highlight_end":26},{"text":"                    }","highlight_start":1,"highlight_end":22},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                    // if we reach here numbers are <= 9999, so at most 4 chars long","highlight_start":1,"highlight_end":85},{"text":"                    let mut n = n as isize; // possibly reduce 64bit math","highlight_start":1,"highlight_end":74},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                    // decode 2 more chars, if > 2 chars","highlight_start":1,"highlight_end":57},{"text":"                    if n >= 100 {","highlight_start":1,"highlight_end":34},{"text":"                        let d1 = (n % 100) << 1;","highlight_start":1,"highlight_end":49},{"text":"                        n /= 100;","highlight_start":1,"highlight_end":34},{"text":"                        curr -= 2;","highlight_start":1,"highlight_end":35},{"text":"                        ptr::copy_nonoverlapping(lut_ptr.offset(d1), buf_ptr.offset(curr), 2);","highlight_start":1,"highlight_end":95},{"text":"                    }","highlight_start":1,"highlight_end":22},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                    // decode last 1 or 2 chars","highlight_start":1,"highlight_end":48},{"text":"                    if n < 10 {","highlight_start":1,"highlight_end":32},{"text":"                        curr -= 1;","highlight_start":1,"highlight_end":35},{"text":"                        *buf_ptr.offset(curr) = (n as u8) + b'0';","highlight_start":1,"highlight_end":66},{"text":"                    } else {","highlight_start":1,"highlight_end":29},{"text":"                        let d1 = n << 1;","highlight_start":1,"highlight_end":41},{"text":"                        curr -= 2;","highlight_start":1,"highlight_end":35},{"text":"                        ptr::copy_nonoverlapping(lut_ptr.offset(d1), buf_ptr.offset(curr), 2);","highlight_start":1,"highlight_end":95},{"text":"                    }","highlight_start":1,"highlight_end":22},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                    if !is_nonnegative {","highlight_start":1,"highlight_end":41},{"text":"                        curr -= 1;","highlight_start":1,"highlight_end":35},{"text":"                        *buf_ptr.offset(curr) = b'-';","highlight_start":1,"highlight_end":54},{"text":"                    }","highlight_start":1,"highlight_end":22},{"text":"                }","highlight_start":1,"highlight_end":18},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                let len = buf.len() - curr as usize;","highlight_start":1,"highlight_end":53},{"text":"                let bytes = unsafe { slice::from_raw_parts(buf_ptr.offset(curr), len) };","highlight_start":1,"highlight_end":89},{"text":"                unsafe { str::from_utf8_unchecked(bytes) }","highlight_start":1,"highlight_end":59},{"text":"            }","highlight_start":1,"highlight_end":14},{"text":"        }","highlight_start":1,"highlight_end":10},{"text":"    )*};","highlight_start":1,"highlight_end":9},{"text":"}","highlight_start":1,"highlight_end":2}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}}],"children":[],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0433]\u001b[0m\u001b[0m\u001b[1m\u001b[38;5;15m: failed to resolve: use of undeclared crate or module `ptr`\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m--> \u001b[0m\u001b[0mC:\\Users\\ASUS\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\itoa-1.0.1\\src\\lib.rs:148:29\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14m148\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m| \u001b[0m\u001b[0m  \u001b[0m\u001b[0m                            ptr::copy_nonoverlapping(lut_ptr.offset(d1), buf_ptr.offset(curr), 2);\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m| \u001b[0m\u001b[0m                              \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9muse of undeclared crate or module `ptr`\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14m...\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14m197\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m| \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m/\u001b[0m\u001b[0m \u001b[0m\u001b[0mimpl_Integer!(\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14m198\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m| \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    I8_MAX_LEN => i8,\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14m199\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m| \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    U8_MAX_LEN => u8,\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14m200\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m| \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    I16_MAX_LEN => i16,\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14m...\u001b[0m\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14m203\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m| \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    U32_MAX_LEN => u32\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14m204\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m| \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    as u32);\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m| \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|___________-\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14min this macro invocation\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m= \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;15mnote\u001b[0m\u001b[0m: this error originates in the macro `impl_Integer` (in Nightly builds, run with -Z macro-backtrace for more info)\u001b[0m\n\n"}
{"message":"failed to resolve: use of undeclared crate or module `ptr`","code":{"code":"E0433","explanation":"An undeclared crate, module, or type was used.\n\nErroneous code example:\n\n```compile_fail,E0433\nlet map = HashMap::new();\n// error: failed to resolve: use of undeclared type `HashMap`\n```\n\nPlease verify you didn't misspell the type/module's name or that you didn't\nforget to import it:\n\n```\nuse std::collections::HashMap; // HashMap has been imported.\nlet map: HashMap<u32, u32> = HashMap::new(); // So it can be used!\n```\n\nIf you've expected to use a crate name:\n\n```compile_fail\nuse ferris_wheel::BigO;\n// error: failed to resolve: use of undeclared crate or module `ferris_wheel`\n```\n\nMake sure the crate has been added as a dependency in `Cargo.toml`.\n\nTo use a module from your current crate, add the `crate::` prefix to the path.\n"},"level":"error","spans":[{"file_name":"C:\\Users\\ASUS\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\itoa-1.0.1\\src\\lib.rs","byte_start":6091,"byte_end":6094,"line_start":149,"line_end":149,"column_start":29,"column_end":32,"is_primary":true,"text":[{"text":"                            ptr::copy_nonoverlapping(lut_ptr.offset(d2), buf_ptr.offset(curr + 2), 2);","highlight_start":29,"highlight_end":32}],"label":"use of undeclared crate or module `ptr`","suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"C:\\Users\\ASUS\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\itoa-1.0.1\\src\\lib.rs","byte_start":7757,"byte_end":7922,"line_start":197,"line_end":204,"column_start":1,"column_end":12,"is_primary":false,"text":[{"text":"impl_Integer!(","highlight_start":1,"highlight_end":15},{"text":"    I8_MAX_LEN => i8,","highlight_start":1,"highlight_end":22},{"text":"    U8_MAX_LEN => u8,","highlight_start":1,"highlight_end":22},{"text":"    I16_MAX_LEN => i16,","highlight_start":1,"highlight_end":24},{"text":"    U16_MAX_LEN => u16,","highlight_start":1,"highlight_end":24},{"text":"    I32_MAX_LEN => i32,","highlight_start":1,"highlight_end":24},{"text":"    U32_MAX_LEN => u32","highlight_start":1,"highlight_end":23},{"text":"    as u32);","highlight_start":1,"highlight_end":12}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"impl_Integer!","def_site_span":{"file_name":"C:\\Users\\ASUS\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\itoa-1.0.1\\src\\lib.rs","byte_start":4595,"byte_end":7512,"line_start":116,"line_end":186,"column_start":1,"column_end":2,"is_primary":false,"text":[{"text":"macro_rules! impl_Integer {","highlight_start":1,"highlight_end":28},{"text":"    ($($max_len:expr => $t:ident),* as $conv_fn:ident) => {$(","highlight_start":1,"highlight_end":62},{"text":"        impl Integer for $t {}","highlight_start":1,"highlight_end":31},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        impl private::Sealed for $t {","highlight_start":1,"highlight_end":38},{"text":"            type Buffer = [MaybeUninit<u8>; $max_len];","highlight_start":1,"highlight_end":55},{"text":"","highlight_start":1,"highlight_end":1},{"text":"            #[allow(unused_comparisons)]","highlight_start":1,"highlight_end":41},{"text":"            #[inline]","highlight_start":1,"highlight_end":22},{"text":"            fn write(self, buf: &mut [MaybeUninit<u8>; $max_len]) -> &str {","highlight_start":1,"highlight_end":76},{"text":"                let is_nonnegative = self >= 0;","highlight_start":1,"highlight_end":48},{"text":"                let mut n = if is_nonnegative {","highlight_start":1,"highlight_end":48},{"text":"                    self as $conv_fn","highlight_start":1,"highlight_end":37},{"text":"                } else {","highlight_start":1,"highlight_end":25},{"text":"                    // convert the negative num to positive by summing 1 to it's 2 complement","highlight_start":1,"highlight_end":94},{"text":"                    (!(self as $conv_fn)).wrapping_add(1)","highlight_start":1,"highlight_end":58},{"text":"                };","highlight_start":1,"highlight_end":19},{"text":"                let mut curr = buf.len() as isize;","highlight_start":1,"highlight_end":51},{"text":"                let buf_ptr = buf.as_mut_ptr() as *mut u8;","highlight_start":1,"highlight_end":59},{"text":"                let lut_ptr = DEC_DIGITS_LUT.as_ptr();","highlight_start":1,"highlight_end":55},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                unsafe {","highlight_start":1,"highlight_end":25},{"text":"                    // need at least 16 bits for the 4-characters-at-a-time to work.","highlight_start":1,"highlight_end":85},{"text":"                    if mem::size_of::<$t>() >= 2 {","highlight_start":1,"highlight_end":51},{"text":"                        // eagerly decode 4 characters at a time","highlight_start":1,"highlight_end":65},{"text":"                        while n >= 10000 {","highlight_start":1,"highlight_end":43},{"text":"                            let rem = (n % 10000) as isize;","highlight_start":1,"highlight_end":60},{"text":"                            n /= 10000;","highlight_start":1,"highlight_end":40},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                            let d1 = (rem / 100) << 1;","highlight_start":1,"highlight_end":55},{"text":"                            let d2 = (rem % 100) << 1;","highlight_start":1,"highlight_end":55},{"text":"                            curr -= 4;","highlight_start":1,"highlight_end":39},{"text":"                            ptr::copy_nonoverlapping(lut_ptr.offset(d1), buf_ptr.offset(curr), 2);","highlight_start":1,"highlight_end":99},{"text":"                            ptr::copy_nonoverlapping(lut_ptr.offset(d2), buf_ptr.offset(curr + 2), 2);","highlight_start":1,"highlight_end":103},{"text":"                        }","highlight_start":1,"highlight_end":26},{"text":"                    }","highlight_start":1,"highlight_end":22},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                    // if we reach here numbers are <= 9999, so at most 4 chars long","highlight_start":1,"highlight_end":85},{"text":"                    let mut n = n as isize; // possibly reduce 64bit math","highlight_start":1,"highlight_end":74},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                    // decode 2 more chars, if > 2 chars","highlight_start":1,"highlight_end":57},{"text":"                    if n >= 100 {","highlight_start":1,"highlight_end":34},{"text":"                        let d1 = (n % 100) << 1;","highlight_start":1,"highlight_end":49},{"text":"                        n /= 100;","highlight_start":1,"highlight_end":34},{"text":"                        curr -= 2;","highlight_start":1,"highlight_end":35},{"text":"                        ptr::copy_nonoverlapping(lut_ptr.offset(d1), buf_ptr.offset(curr), 2);","highlight_start":1,"highlight_end":95},{"text":"                    }","highlight_start":1,"highlight_end":22},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                    // decode last 1 or 2 chars","highlight_start":1,"highlight_end":48},{"text":"                    if n < 10 {","highlight_start":1,"highlight_end":32},{"text":"                        curr -= 1;","highlight_start":1,"highlight_end":35},{"text":"                        *buf_ptr.offset(curr) = (n as u8) + b'0';","highlight_start":1,"highlight_end":66},{"text":"                    } else {","highlight_start":1,"highlight_end":29},{"text":"                        let d1 = n << 1;","highlight_start":1,"highlight_end":41},{"text":"                        curr -= 2;","highlight_start":1,"highlight_end":35},{"text":"                        ptr::copy_nonoverlapping(lut_ptr.offset(d1), buf_ptr.offset(curr), 2);","highlight_start":1,"highlight_end":95},{"text":"                    }","highlight_start":1,"highlight_end":22},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                    if !is_nonnegative {","highlight_start":1,"highlight_end":41},{"text":"                        curr -= 1;","highlight_start":1,"highlight_end":35},{"text":"                        *buf_ptr.offset(curr) = b'-';","highlight_start":1,"highlight_end":54},{"text":"                    }","highlight_start":1,"highlight_end":22},{"text":"                }","highlight_start":1,"highlight_end":18},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                let len = buf.len() - curr as usize;","highlight_start":1,"highlight_end":53},{"text":"                let bytes = unsafe { slice::from_raw_parts(buf_ptr.offset(curr), len) };","highlight_start":1,"highlight_end":89},{"text":"                unsafe { str::from_utf8_unchecked(bytes) }","highlight_start":1,"highlight_end":59},{"text":"            }","highlight_start":1,"highlight_end":14},{"text":"        }","highlight_start":1,"highlight_end":10},{"text":"    )*};","highlight_start":1,"highlight_end":9},{"text":"}","highlight_start":1,"highlight_end":2}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}}],"children":[],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0433]\u001b[0m\u001b[0m\u001b[1m\u001b[38;5;15m: failed to resolve: use of undeclared crate or module `ptr`\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m--> \u001b[0m\u001b[0mC:\\Users\\ASUS\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\itoa-1.0.1\\src\\lib.rs:149:29\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14m149\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m| \u001b[0m\u001b[0m  \u001b[0m\u001b[0m                            ptr::copy_nonoverlapping(lut_ptr.offset(d2), buf_ptr.offset(curr + 2), 2);\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m| \u001b[0m\u001b[0m                              \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9muse of undeclared crate or module `ptr`\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14m...\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14m197\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m| \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m/\u001b[0m\u001b[0m \u001b[0m\u001b[0mimpl_Integer!(\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14m198\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m| \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    I8_MAX_LEN => i8,\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14m199\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m| \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    U8_MAX_LEN => u8,\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14m200\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m| \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    I16_MAX_LEN => i16,\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14m...\u001b[0m\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14m203\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m| \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    U32_MAX_LEN => u32\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14m204\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m| \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    as u32);\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m| \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|___________-\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14min this macro invocation\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m= \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;15mnote\u001b[0m\u001b[0m: this error originates in the macro `impl_Integer` (in Nightly builds, run with -Z macro-backtrace for more info)\u001b[0m\n\n"}
{"message":"failed to resolve: use of undeclared crate or module `ptr`","code":{"code":"E0433","explanation":"An undeclared crate, module, or type was used.\n\nErroneous code example:\n\n```compile_fail,E0433\nlet map = HashMap::new();\n// error: failed to resolve: use of undeclared type `HashMap`\n```\n\nPlease verify you didn't misspell the type/module's name or that you didn't\nforget to import it:\n\n```\nuse std::collections::HashMap; // HashMap has been imported.\nlet map: HashMap<u32, u32> = HashMap::new(); // So it can be used!\n```\n\nIf you've expected to use a crate name:\n\n```compile_fail\nuse ferris_wheel::BigO;\n// error: failed to resolve: use of undeclared crate or module `ferris_wheel`\n```\n\nMake sure the crate has been added as a dependency in `Cargo.toml`.\n\nTo use a module from your current crate, add the `crate::` prefix to the path.\n"},"level":"error","spans":[{"file_name":"C:\\Users\\ASUS\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\itoa-1.0.1\\src\\lib.rs","byte_start":6608,"byte_end":6611,"line_start":161,"line_end":161,"column_start":25,"column_end":28,"is_primary":true,"text":[{"text":"                        ptr::copy_nonoverlapping(lut_ptr.offset(d1), buf_ptr.offset(curr), 2);","highlight_start":25,"highlight_end":28}],"label":"use of undeclared crate or module `ptr`","suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"C:\\Users\\ASUS\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\itoa-1.0.1\\src\\lib.rs","byte_start":7757,"byte_end":7922,"line_start":197,"line_end":204,"column_start":1,"column_end":12,"is_primary":false,"text":[{"text":"impl_Integer!(","highlight_start":1,"highlight_end":15},{"text":"    I8_MAX_LEN => i8,","highlight_start":1,"highlight_end":22},{"text":"    U8_MAX_LEN => u8,","highlight_start":1,"highlight_end":22},{"text":"    I16_MAX_LEN => i16,","highlight_start":1,"highlight_end":24},{"text":"    U16_MAX_LEN => u16,","highlight_start":1,"highlight_end":24},{"text":"    I32_MAX_LEN => i32,","highlight_start":1,"highlight_end":24},{"text":"    U32_MAX_LEN => u32","highlight_start":1,"highlight_end":23},{"text":"    as u32);","highlight_start":1,"highlight_end":12}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"impl_Integer!","def_site_span":{"file_name":"C:\\Users\\ASUS\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\itoa-1.0.1\\src\\lib.rs","byte_start":4595,"byte_end":7512,"line_start":116,"line_end":186,"column_start":1,"column_end":2,"is_primary":false,"text":[{"text":"macro_rules! impl_Integer {","highlight_start":1,"highlight_end":28},{"text":"    ($($max_len:expr => $t:ident),* as $conv_fn:ident) => {$(","highlight_start":1,"highlight_end":62},{"text":"        impl Integer for $t {}","highlight_start":1,"highlight_end":31},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        impl private::Sealed for $t {","highlight_start":1,"highlight_end":38},{"text":"            type Buffer = [MaybeUninit<u8>; $max_len];","highlight_start":1,"highlight_end":55},{"text":"","highlight_start":1,"highlight_end":1},{"text":"            #[allow(unused_comparisons)]","highlight_start":1,"highlight_end":41},{"text":"            #[inline]","highlight_start":1,"highlight_end":22},{"text":"            fn write(self, buf: &mut [MaybeUninit<u8>; $max_len]) -> &str {","highlight_start":1,"highlight_end":76},{"text":"                let is_nonnegative = self >= 0;","highlight_start":1,"highlight_end":48},{"text":"                let mut n = if is_nonnegative {","highlight_start":1,"highlight_end":48},{"text":"                    self as $conv_fn","highlight_start":1,"highlight_end":37},{"text":"                } else {","highlight_start":1,"highlight_end":25},{"text":"                    // convert the negative num to positive by summing 1 to it's 2 complement","highlight_start":1,"highlight_end":94},{"text":"                    (!(self as $conv_fn)).wrapping_add(1)","highlight_start":1,"highlight_end":58},{"text":"                };","highlight_start":1,"highlight_end":19},{"text":"                let mut curr = buf.len() as isize;","highlight_start":1,"highlight_end":51},{"text":"                let buf_ptr = buf.as_mut_ptr() as *mut u8;","highlight_start":1,"highlight_end":59},{"text":"                let lut_ptr = DEC_DIGITS_LUT.as_ptr();","highlight_start":1,"highlight_end":55},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                unsafe {","highlight_start":1,"highlight_end":25},{"text":"                    // need at least 16 bits for the 4-characters-at-a-time to work.","highlight_start":1,"highlight_end":85},{"text":"                    if mem::size_of::<$t>() >= 2 {","highlight_start":1,"highlight_end":51},{"text":"                        // eagerly decode 4 characters at a time","highlight_start":1,"highlight_end":65},{"text":"                        while n >= 10000 {","highlight_start":1,"highlight_end":43},{"text":"                            let rem = (n % 10000) as isize;","highlight_start":1,"highlight_end":60},{"text":"                            n /= 10000;","highlight_start":1,"highlight_end":40},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                            let d1 = (rem / 100) << 1;","highlight_start":1,"highlight_end":55},{"text":"                            let d2 = (rem % 100) << 1;","highlight_start":1,"highlight_end":55},{"text":"                            curr -= 4;","highlight_start":1,"highlight_end":39},{"text":"                            ptr::copy_nonoverlapping(lut_ptr.offset(d1), buf_ptr.offset(curr), 2);","highlight_start":1,"highlight_end":99},{"text":"                            ptr::copy_nonoverlapping(lut_ptr.offset(d2), buf_ptr.offset(curr + 2), 2);","highlight_start":1,"highlight_end":103},{"text":"                        }","highlight_start":1,"highlight_end":26},{"text":"                    }","highlight_start":1,"highlight_end":22},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                    // if we reach here numbers are <= 9999, so at most 4 chars long","highlight_start":1,"highlight_end":85},{"text":"                    let mut n = n as isize; // possibly reduce 64bit math","highlight_start":1,"highlight_end":74},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                    // decode 2 more chars, if > 2 chars","highlight_start":1,"highlight_end":57},{"text":"                    if n >= 100 {","highlight_start":1,"highlight_end":34},{"text":"                        let d1 = (n % 100) << 1;","highlight_start":1,"highlight_end":49},{"text":"                        n /= 100;","highlight_start":1,"highlight_end":34},{"text":"                        curr -= 2;","highlight_start":1,"highlight_end":35},{"text":"                        ptr::copy_nonoverlapping(lut_ptr.offset(d1), buf_ptr.offset(curr), 2);","highlight_start":1,"highlight_end":95},{"text":"                    }","highlight_start":1,"highlight_end":22},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                    // decode last 1 or 2 chars","highlight_start":1,"highlight_end":48},{"text":"                    if n < 10 {","highlight_start":1,"highlight_end":32},{"text":"                        curr -= 1;","highlight_start":1,"highlight_end":35},{"text":"                        *buf_ptr.offset(curr) = (n as u8) + b'0';","highlight_start":1,"highlight_end":66},{"text":"                    } else {","highlight_start":1,"highlight_end":29},{"text":"                        let d1 = n << 1;","highlight_start":1,"highlight_end":41},{"text":"                        curr -= 2;","highlight_start":1,"highlight_end":35},{"text":"                        ptr::copy_nonoverlapping(lut_ptr.offset(d1), buf_ptr.offset(curr), 2);","highlight_start":1,"highlight_end":95},{"text":"                    }","highlight_start":1,"highlight_end":22},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                    if !is_nonnegative {","highlight_start":1,"highlight_end":41},{"text":"                        curr -= 1;","highlight_start":1,"highlight_end":35},{"text":"                        *buf_ptr.offset(curr) = b'-';","highlight_start":1,"highlight_end":54},{"text":"                    }","highlight_start":1,"highlight_end":22},{"text":"                }","highlight_start":1,"highlight_end":18},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                let len = buf.len() - curr as usize;","highlight_start":1,"highlight_end":53},{"text":"                let bytes = unsafe { slice::from_raw_parts(buf_ptr.offset(curr), len) };","highlight_start":1,"highlight_end":89},{"text":"                unsafe { str::from_utf8_unchecked(bytes) }","highlight_start":1,"highlight_end":59},{"text":"            }","highlight_start":1,"highlight_end":14},{"text":"        }","highlight_start":1,"highlight_end":10},{"text":"    )*};","highlight_start":1,"highlight_end":9},{"text":"}","highlight_start":1,"highlight_end":2}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}}],"children":[],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0433]\u001b[0m\u001b[0m\u001b[1m\u001b[38;5;15m: failed to resolve: use of undeclared crate or module `ptr`\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m--> \u001b[0m\u001b[0mC:\\Users\\ASUS\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\itoa-1.0.1\\src\\lib.rs:161:25\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14m161\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m| \u001b[0m\u001b[0m  \u001b[0m\u001b[0m                        ptr::copy_nonoverlapping(lut_ptr.offset(d1), buf_ptr.offset(curr), 2);\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m| \u001b[0m\u001b[0m                          \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9muse of undeclared crate or module `ptr`\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14m...\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14m197\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m| \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m/\u001b[0m\u001b[0m \u001b[0m\u001b[0mimpl_Integer!(\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14m198\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m| \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    I8_MAX_LEN => i8,\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14m199\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m| \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    U8_MAX_LEN => u8,\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14m200\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m| \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    I16_MAX_LEN => i16,\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14m...\u001b[0m\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14m203\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m| \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    U32_MAX_LEN => u32\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14m204\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m| \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    as u32);\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m| \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|___________-\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14min this macro invocation\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m= \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;15mnote\u001b[0m\u001b[0m: this error originates in the macro `impl_Integer` (in Nightly builds, run with -Z macro-backtrace for more info)\u001b[0m\n\n"}
{"message":"failed to resolve: use of undeclared crate or module `ptr`","code":{"code":"E0433","explanation":"An undeclared crate, module, or type was used.\n\nErroneous code example:\n\n```compile_fail,E0433\nlet map = HashMap::new();\n// error: failed to resolve: use of undeclared type `HashMap`\n```\n\nPlease verify you didn't misspell the type/module's name or that you didn't\nforget to import it:\n\n```\nuse std::collections::HashMap; // HashMap has been imported.\nlet map: HashMap<u32, u32> = HashMap::new(); // So it can be used!\n```\n\nIf you've expected to use a crate name:\n\n```compile_fail\nuse ferris_wheel::BigO;\n// error: failed to resolve: use of undeclared crate or module `ferris_wheel`\n```\n\nMake sure the crate has been added as a dependency in `Cargo.toml`.\n\nTo use a module from your current crate, add the `crate::` prefix to the path.\n"},"level":"error","spans":[{"file_name":"C:\\Users\\ASUS\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\itoa-1.0.1\\src\\lib.rs","byte_start":7012,"byte_end":7015,"line_start":171,"line_end":171,"column_start":25,"column_end":28,"is_primary":true,"text":[{"text":"                        ptr::copy_nonoverlapping(lut_ptr.offset(d1), buf_ptr.offset(curr), 2);","highlight_start":25,"highlight_end":28}],"label":"use of undeclared crate or module `ptr`","suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"C:\\Users\\ASUS\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\itoa-1.0.1\\src\\lib.rs","byte_start":7757,"byte_end":7922,"line_start":197,"line_end":204,"column_start":1,"column_end":12,"is_primary":false,"text":[{"text":"impl_Integer!(","highlight_start":1,"highlight_end":15},{"text":"    I8_MAX_LEN => i8,","highlight_start":1,"highlight_end":22},{"text":"    U8_MAX_LEN => u8,","highlight_start":1,"highlight_end":22},{"text":"    I16_MAX_LEN => i16,","highlight_start":1,"highlight_end":24},{"text":"    U16_MAX_LEN => u16,","highlight_start":1,"highlight_end":24},{"text":"    I32_MAX_LEN => i32,","highlight_start":1,"highlight_end":24},{"text":"    U32_MAX_LEN => u32","highlight_start":1,"highlight_end":23},{"text":"    as u32);","highlight_start":1,"highlight_end":12}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"impl_Integer!","def_site_span":{"file_name":"C:\\Users\\ASUS\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\itoa-1.0.1\\src\\lib.rs","byte_start":4595,"byte_end":7512,"line_start":116,"line_end":186,"column_start":1,"column_end":2,"is_primary":false,"text":[{"text":"macro_rules! impl_Integer {","highlight_start":1,"highlight_end":28},{"text":"    ($($max_len:expr => $t:ident),* as $conv_fn:ident) => {$(","highlight_start":1,"highlight_end":62},{"text":"        impl Integer for $t {}","highlight_start":1,"highlight_end":31},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        impl private::Sealed for $t {","highlight_start":1,"highlight_end":38},{"text":"            type Buffer = [MaybeUninit<u8>; $max_len];","highlight_start":1,"highlight_end":55},{"text":"","highlight_start":1,"highlight_end":1},{"text":"            #[allow(unused_comparisons)]","highlight_start":1,"highlight_end":41},{"text":"            #[inline]","highlight_start":1,"highlight_end":22},{"text":"            fn write(self, buf: &mut [MaybeUninit<u8>; $max_len]) -> &str {","highlight_start":1,"highlight_end":76},{"text":"                let is_nonnegative = self >= 0;","highlight_start":1,"highlight_end":48},{"text":"                let mut n = if is_nonnegative {","highlight_start":1,"highlight_end":48},{"text":"                    self as $conv_fn","highlight_start":1,"highlight_end":37},{"text":"                } else {","highlight_start":1,"highlight_end":25},{"text":"                    // convert the negative num to positive by summing 1 to it's 2 complement","highlight_start":1,"highlight_end":94},{"text":"                    (!(self as $conv_fn)).wrapping_add(1)","highlight_start":1,"highlight_end":58},{"text":"                };","highlight_start":1,"highlight_end":19},{"text":"                let mut curr = buf.len() as isize;","highlight_start":1,"highlight_end":51},{"text":"                let buf_ptr = buf.as_mut_ptr() as *mut u8;","highlight_start":1,"highlight_end":59},{"text":"                let lut_ptr = DEC_DIGITS_LUT.as_ptr();","highlight_start":1,"highlight_end":55},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                unsafe {","highlight_start":1,"highlight_end":25},{"text":"                    // need at least 16 bits for the 4-characters-at-a-time to work.","highlight_start":1,"highlight_end":85},{"text":"                    if mem::size_of::<$t>() >= 2 {","highlight_start":1,"highlight_end":51},{"text":"                        // eagerly decode 4 characters at a time","highlight_start":1,"highlight_end":65},{"text":"                        while n >= 10000 {","highlight_start":1,"highlight_end":43},{"text":"                            let rem = (n % 10000) as isize;","highlight_start":1,"highlight_end":60},{"text":"                            n /= 10000;","highlight_start":1,"highlight_end":40},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                            let d1 = (rem / 100) << 1;","highlight_start":1,"highlight_end":55},{"text":"                            let d2 = (rem % 100) << 1;","highlight_start":1,"highlight_end":55},{"text":"                            curr -= 4;","highlight_start":1,"highlight_end":39},{"text":"                            ptr::copy_nonoverlapping(lut_ptr.offset(d1), buf_ptr.offset(curr), 2);","highlight_start":1,"highlight_end":99},{"text":"                            ptr::copy_nonoverlapping(lut_ptr.offset(d2), buf_ptr.offset(curr + 2), 2);","highlight_start":1,"highlight_end":103},{"text":"                        }","highlight_start":1,"highlight_end":26},{"text":"                    }","highlight_start":1,"highlight_end":22},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                    // if we reach here numbers are <= 9999, so at most 4 chars long","highlight_start":1,"highlight_end":85},{"text":"                    let mut n = n as isize; // possibly reduce 64bit math","highlight_start":1,"highlight_end":74},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                    // decode 2 more chars, if > 2 chars","highlight_start":1,"highlight_end":57},{"text":"                    if n >= 100 {","highlight_start":1,"highlight_end":34},{"text":"                        let d1 = (n % 100) << 1;","highlight_start":1,"highlight_end":49},{"text":"                        n /= 100;","highlight_start":1,"highlight_end":34},{"text":"                        curr -= 2;","highlight_start":1,"highlight_end":35},{"text":"                        ptr::copy_nonoverlapping(lut_ptr.offset(d1), buf_ptr.offset(curr), 2);","highlight_start":1,"highlight_end":95},{"text":"                    }","highlight_start":1,"highlight_end":22},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                    // decode last 1 or 2 chars","highlight_start":1,"highlight_end":48},{"text":"                    if n < 10 {","highlight_start":1,"highlight_end":32},{"text":"                        curr -= 1;","highlight_start":1,"highlight_end":35},{"text":"                        *buf_ptr.offset(curr) = (n as u8) + b'0';","highlight_start":1,"highlight_end":66},{"text":"                    } else {","highlight_start":1,"highlight_end":29},{"text":"                        let d1 = n << 1;","highlight_start":1,"highlight_end":41},{"text":"                        curr -= 2;","highlight_start":1,"highlight_end":35},{"text":"                        ptr::copy_nonoverlapping(lut_ptr.offset(d1), buf_ptr.offset(curr), 2);","highlight_start":1,"highlight_end":95},{"text":"                    }","highlight_start":1,"highlight_end":22},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                    if !is_nonnegative {","highlight_start":1,"highlight_end":41},{"text":"                        curr -= 1;","highlight_start":1,"highlight_end":35},{"text":"                        *buf_ptr.offset(curr) = b'-';","highlight_start":1,"highlight_end":54},{"text":"                    }","highlight_start":1,"highlight_end":22},{"text":"                }","highlight_start":1,"highlight_end":18},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                let len = buf.len() - curr as usize;","highlight_start":1,"highlight_end":53},{"text":"                let bytes = unsafe { slice::from_raw_parts(buf_ptr.offset(curr), len) };","highlight_start":1,"highlight_end":89},{"text":"                unsafe { str::from_utf8_unchecked(bytes) }","highlight_start":1,"highlight_end":59},{"text":"            }","highlight_start":1,"highlight_end":14},{"text":"        }","highlight_start":1,"highlight_end":10},{"text":"    )*};","highlight_start":1,"highlight_end":9},{"text":"}","highlight_start":1,"highlight_end":2}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}}],"children":[],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0433]\u001b[0m\u001b[0m\u001b[1m\u001b[38;5;15m: failed to resolve: use of undeclared crate or module `ptr`\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m--> \u001b[0m\u001b[0mC:\\Users\\ASUS\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\itoa-1.0.1\\src\\lib.rs:171:25\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14m171\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m| \u001b[0m\u001b[0m  \u001b[0m\u001b[0m                        ptr::copy_nonoverlapping(lut_ptr.offset(d1), buf_ptr.offset(curr), 2);\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m| \u001b[0m\u001b[0m                          \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9muse of undeclared crate or module `ptr`\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14m...\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14m197\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m| \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m/\u001b[0m\u001b[0m \u001b[0m\u001b[0mimpl_Integer!(\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14m198\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m| \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    I8_MAX_LEN => i8,\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14m199\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m| \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    U8_MAX_LEN => u8,\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14m200\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m| \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    I16_MAX_LEN => i16,\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14m...\u001b[0m\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14m203\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m| \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    U32_MAX_LEN => u32\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14m204\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m| \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    as u32);\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m| \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|___________-\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14min this macro invocation\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m= \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;15mnote\u001b[0m\u001b[0m: this error originates in the macro `impl_Integer` (in Nightly builds, run with -Z macro-backtrace for more info)\u001b[0m\n\n"}
{"message":"failed to resolve: use of undeclared crate or module `slice`","code":{"code":"E0433","explanation":"An undeclared crate, module, or type was used.\n\nErroneous code example:\n\n```compile_fail,E0433\nlet map = HashMap::new();\n// error: failed to resolve: use of undeclared type `HashMap`\n```\n\nPlease verify you didn't misspell the type/module's name or that you didn't\nforget to import it:\n\n```\nuse std::collections::HashMap; // HashMap has been imported.\nlet map: HashMap<u32, u32> = HashMap::new(); // So it can be used!\n```\n\nIf you've expected to use a crate name:\n\n```compile_fail\nuse ferris_wheel::BigO;\n// error: failed to resolve: use of undeclared crate or module `ferris_wheel`\n```\n\nMake sure the crate has been added as a dependency in `Cargo.toml`.\n\nTo use a module from your current crate, add the `crate::` prefix to the path.\n"},"level":"error","spans":[{"file_name":"C:\\Users\\ASUS\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\itoa-1.0.1\\src\\lib.rs","byte_start":7367,"byte_end":7372,"line_start":181,"line_end":181,"column_start":38,"column_end":43,"is_primary":true,"text":[{"text":"                let bytes = unsafe { slice::from_raw_parts(buf_ptr.offset(curr), len) };","highlight_start":38,"highlight_end":43}],"label":"use of undeclared crate or module `slice`","suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"C:\\Users\\ASUS\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\itoa-1.0.1\\src\\lib.rs","byte_start":7757,"byte_end":7922,"line_start":197,"line_end":204,"column_start":1,"column_end":12,"is_primary":false,"text":[{"text":"impl_Integer!(","highlight_start":1,"highlight_end":15},{"text":"    I8_MAX_LEN => i8,","highlight_start":1,"highlight_end":22},{"text":"    U8_MAX_LEN => u8,","highlight_start":1,"highlight_end":22},{"text":"    I16_MAX_LEN => i16,","highlight_start":1,"highlight_end":24},{"text":"    U16_MAX_LEN => u16,","highlight_start":1,"highlight_end":24},{"text":"    I32_MAX_LEN => i32,","highlight_start":1,"highlight_end":24},{"text":"    U32_MAX_LEN => u32","highlight_start":1,"highlight_end":23},{"text":"    as u32);","highlight_start":1,"highlight_end":12}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"impl_Integer!","def_site_span":{"file_name":"C:\\Users\\ASUS\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\itoa-1.0.1\\src\\lib.rs","byte_start":4595,"byte_end":7512,"line_start":116,"line_end":186,"column_start":1,"column_end":2,"is_primary":false,"text":[{"text":"macro_rules! impl_Integer {","highlight_start":1,"highlight_end":28},{"text":"    ($($max_len:expr => $t:ident),* as $conv_fn:ident) => {$(","highlight_start":1,"highlight_end":62},{"text":"        impl Integer for $t {}","highlight_start":1,"highlight_end":31},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        impl private::Sealed for $t {","highlight_start":1,"highlight_end":38},{"text":"            type Buffer = [MaybeUninit<u8>; $max_len];","highlight_start":1,"highlight_end":55},{"text":"","highlight_start":1,"highlight_end":1},{"text":"            #[allow(unused_comparisons)]","highlight_start":1,"highlight_end":41},{"text":"            #[inline]","highlight_start":1,"highlight_end":22},{"text":"            fn write(self, buf: &mut [MaybeUninit<u8>; $max_len]) -> &str {","highlight_start":1,"highlight_end":76},{"text":"                let is_nonnegative = self >= 0;","highlight_start":1,"highlight_end":48},{"text":"                let mut n = if is_nonnegative {","highlight_start":1,"highlight_end":48},{"text":"                    self as $conv_fn","highlight_start":1,"highlight_end":37},{"text":"                } else {","highlight_start":1,"highlight_end":25},{"text":"                    // convert the negative num to positive by summing 1 to it's 2 complement","highlight_start":1,"highlight_end":94},{"text":"                    (!(self as $conv_fn)).wrapping_add(1)","highlight_start":1,"highlight_end":58},{"text":"                };","highlight_start":1,"highlight_end":19},{"text":"                let mut curr = buf.len() as isize;","highlight_start":1,"highlight_end":51},{"text":"                let buf_ptr = buf.as_mut_ptr() as *mut u8;","highlight_start":1,"highlight_end":59},{"text":"                let lut_ptr = DEC_DIGITS_LUT.as_ptr();","highlight_start":1,"highlight_end":55},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                unsafe {","highlight_start":1,"highlight_end":25},{"text":"                    // need at least 16 bits for the 4-characters-at-a-time to work.","highlight_start":1,"highlight_end":85},{"text":"                    if mem::size_of::<$t>() >= 2 {","highlight_start":1,"highlight_end":51},{"text":"                        // eagerly decode 4 characters at a time","highlight_start":1,"highlight_end":65},{"text":"                        while n >= 10000 {","highlight_start":1,"highlight_end":43},{"text":"                            let rem = (n % 10000) as isize;","highlight_start":1,"highlight_end":60},{"text":"                            n /= 10000;","highlight_start":1,"highlight_end":40},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                            let d1 = (rem / 100) << 1;","highlight_start":1,"highlight_end":55},{"text":"                            let d2 = (rem % 100) << 1;","highlight_start":1,"highlight_end":55},{"text":"                            curr -= 4;","highlight_start":1,"highlight_end":39},{"text":"                            ptr::copy_nonoverlapping(lut_ptr.offset(d1), buf_ptr.offset(curr), 2);","highlight_start":1,"highlight_end":99},{"text":"                            ptr::copy_nonoverlapping(lut_ptr.offset(d2), buf_ptr.offset(curr + 2), 2);","highlight_start":1,"highlight_end":103},{"text":"                        }","highlight_start":1,"highlight_end":26},{"text":"                    }","highlight_start":1,"highlight_end":22},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                    // if we reach here numbers are <= 9999, so at most 4 chars long","highlight_start":1,"highlight_end":85},{"text":"                    let mut n = n as isize; // possibly reduce 64bit math","highlight_start":1,"highlight_end":74},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                    // decode 2 more chars, if > 2 chars","highlight_start":1,"highlight_end":57},{"text":"                    if n >= 100 {","highlight_start":1,"highlight_end":34},{"text":"                        let d1 = (n % 100) << 1;","highlight_start":1,"highlight_end":49},{"text":"                        n /= 100;","highlight_start":1,"highlight_end":34},{"text":"                        curr -= 2;","highlight_start":1,"highlight_end":35},{"text":"                        ptr::copy_nonoverlapping(lut_ptr.offset(d1), buf_ptr.offset(curr), 2);","highlight_start":1,"highlight_end":95},{"text":"                    }","highlight_start":1,"highlight_end":22},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                    // decode last 1 or 2 chars","highlight_start":1,"highlight_end":48},{"text":"                    if n < 10 {","highlight_start":1,"highlight_end":32},{"text":"                        curr -= 1;","highlight_start":1,"highlight_end":35},{"text":"                        *buf_ptr.offset(curr) = (n as u8) + b'0';","highlight_start":1,"highlight_end":66},{"text":"                    } else {","highlight_start":1,"highlight_end":29},{"text":"                        let d1 = n << 1;","highlight_start":1,"highlight_end":41},{"text":"                        curr -= 2;","highlight_start":1,"highlight_end":35},{"text":"                        ptr::copy_nonoverlapping(lut_ptr.offset(d1), buf_ptr.offset(curr), 2);","highlight_start":1,"highlight_end":95},{"text":"                    }","highlight_start":1,"highlight_end":22},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                    if !is_nonnegative {","highlight_start":1,"highlight_end":41},{"text":"                        curr -= 1;","highlight_start":1,"highlight_end":35},{"text":"                        *buf_ptr.offset(curr) = b'-';","highlight_start":1,"highlight_end":54},{"text":"                    }","highlight_start":1,"highlight_end":22},{"text":"                }","highlight_start":1,"highlight_end":18},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                let len = buf.len() - curr as usize;","highlight_start":1,"highlight_end":53},{"text":"                let bytes = unsafe { slice::from_raw_parts(buf_ptr.offset(curr), len) };","highlight_start":1,"highlight_end":89},{"text":"                unsafe { str::from_utf8_unchecked(bytes) }","highlight_start":1,"highlight_end":59},{"text":"            }","highlight_start":1,"highlight_end":14},{"text":"        }","highlight_start":1,"highlight_end":10},{"text":"    )*};","highlight_start":1,"highlight_end":9},{"text":"}","highlight_start":1,"highlight_end":2}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}}],"children":[],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0433]\u001b[0m\u001b[0m\u001b[1m\u001b[38;5;15m: failed to resolve: use of undeclared crate or module `slice`\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m--> \u001b[0m\u001b[0mC:\\Users\\ASUS\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\itoa-1.0.1\\src\\lib.rs:181:38\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14m181\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m| \u001b[0m\u001b[0m  \u001b[0m\u001b[0m                let bytes = unsafe { slice::from_raw_parts(buf_ptr.offset(curr), len) };\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m| \u001b[0m\u001b[0m                                       \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9muse of undeclared crate or module `slice`\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14m...\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14m197\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m| \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m/\u001b[0m\u001b[0m \u001b[0m\u001b[0mimpl_Integer!(\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14m198\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m| \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    I8_MAX_LEN => i8,\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14m199\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m| \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    U8_MAX_LEN => u8,\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14m200\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m| \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    I16_MAX_LEN => i16,\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14m...\u001b[0m\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14m203\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m| \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    U32_MAX_LEN => u32\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14m204\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m| \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    as u32);\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m| \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|___________-\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14min this macro invocation\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m= \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;15mnote\u001b[0m\u001b[0m: this error originates in the macro `impl_Integer` (in Nightly builds, run with -Z macro-backtrace for more info)\u001b[0m\n\n"}
{"message":"failed to resolve: use of undeclared crate or module `mem`","code":{"code":"E0433","explanation":"An undeclared crate, module, or type was used.\n\nErroneous code example:\n\n```compile_fail,E0433\nlet map = HashMap::new();\n// error: failed to resolve: use of undeclared type `HashMap`\n```\n\nPlease verify you didn't misspell the type/module's name or that you didn't\nforget to import it:\n\n```\nuse std::collections::HashMap; // HashMap has been imported.\nlet map: HashMap<u32, u32> = HashMap::new(); // So it can be used!\n```\n\nIf you've expected to use a crate name:\n\n```compile_fail\nuse ferris_wheel::BigO;\n// error: failed to resolve: use of undeclared crate or module `ferris_wheel`\n```\n\nMake sure the crate has been added as a dependency in `Cargo.toml`.\n\nTo use a module from your current crate, add the `crate::` prefix to the path.\n"},"level":"error","spans":[{"file_name":"C:\\Users\\ASUS\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\itoa-1.0.1\\src\\lib.rs","byte_start":5578,"byte_end":5581,"line_start":139,"line_end":139,"column_start":24,"column_end":27,"is_primary":true,"text":[{"text":"                    if mem::size_of::<$t>() >= 2 {","highlight_start":24,"highlight_end":27}],"label":"use of undeclared crate or module `mem`","suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"C:\\Users\\ASUS\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\itoa-1.0.1\\src\\lib.rs","byte_start":7925,"byte_end":7985,"line_start":206,"line_end":206,"column_start":1,"column_end":61,"is_primary":false,"text":[{"text":"impl_Integer!(I64_MAX_LEN => i64, U64_MAX_LEN => u64 as u64);","highlight_start":1,"highlight_end":61}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"impl_Integer!","def_site_span":{"file_name":"C:\\Users\\ASUS\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\itoa-1.0.1\\src\\lib.rs","byte_start":4595,"byte_end":7512,"line_start":116,"line_end":186,"column_start":1,"column_end":2,"is_primary":false,"text":[{"text":"macro_rules! impl_Integer {","highlight_start":1,"highlight_end":28},{"text":"    ($($max_len:expr => $t:ident),* as $conv_fn:ident) => {$(","highlight_start":1,"highlight_end":62},{"text":"        impl Integer for $t {}","highlight_start":1,"highlight_end":31},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        impl private::Sealed for $t {","highlight_start":1,"highlight_end":38},{"text":"            type Buffer = [MaybeUninit<u8>; $max_len];","highlight_start":1,"highlight_end":55},{"text":"","highlight_start":1,"highlight_end":1},{"text":"            #[allow(unused_comparisons)]","highlight_start":1,"highlight_end":41},{"text":"            #[inline]","highlight_start":1,"highlight_end":22},{"text":"            fn write(self, buf: &mut [MaybeUninit<u8>; $max_len]) -> &str {","highlight_start":1,"highlight_end":76},{"text":"                let is_nonnegative = self >= 0;","highlight_start":1,"highlight_end":48},{"text":"                let mut n = if is_nonnegative {","highlight_start":1,"highlight_end":48},{"text":"                    self as $conv_fn","highlight_start":1,"highlight_end":37},{"text":"                } else {","highlight_start":1,"highlight_end":25},{"text":"                    // convert the negative num to positive by summing 1 to it's 2 complement","highlight_start":1,"highlight_end":94},{"text":"                    (!(self as $conv_fn)).wrapping_add(1)","highlight_start":1,"highlight_end":58},{"text":"                };","highlight_start":1,"highlight_end":19},{"text":"                let mut curr = buf.len() as isize;","highlight_start":1,"highlight_end":51},{"text":"                let buf_ptr = buf.as_mut_ptr() as *mut u8;","highlight_start":1,"highlight_end":59},{"text":"                let lut_ptr = DEC_DIGITS_LUT.as_ptr();","highlight_start":1,"highlight_end":55},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                unsafe {","highlight_start":1,"highlight_end":25},{"text":"                    // need at least 16 bits for the 4-characters-at-a-time to work.","highlight_start":1,"highlight_end":85},{"text":"                    if mem::size_of::<$t>() >= 2 {","highlight_start":1,"highlight_end":51},{"text":"                        // eagerly decode 4 characters at a time","highlight_start":1,"highlight_end":65},{"text":"                        while n >= 10000 {","highlight_start":1,"highlight_end":43},{"text":"                            let rem = (n % 10000) as isize;","highlight_start":1,"highlight_end":60},{"text":"                            n /= 10000;","highlight_start":1,"highlight_end":40},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                            let d1 = (rem / 100) << 1;","highlight_start":1,"highlight_end":55},{"text":"                            let d2 = (rem % 100) << 1;","highlight_start":1,"highlight_end":55},{"text":"                            curr -= 4;","highlight_start":1,"highlight_end":39},{"text":"                            ptr::copy_nonoverlapping(lut_ptr.offset(d1), buf_ptr.offset(curr), 2);","highlight_start":1,"highlight_end":99},{"text":"                            ptr::copy_nonoverlapping(lut_ptr.offset(d2), buf_ptr.offset(curr + 2), 2);","highlight_start":1,"highlight_end":103},{"text":"                        }","highlight_start":1,"highlight_end":26},{"text":"                    }","highlight_start":1,"highlight_end":22},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                    // if we reach here numbers are <= 9999, so at most 4 chars long","highlight_start":1,"highlight_end":85},{"text":"                    let mut n = n as isize; // possibly reduce 64bit math","highlight_start":1,"highlight_end":74},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                    // decode 2 more chars, if > 2 chars","highlight_start":1,"highlight_end":57},{"text":"                    if n >= 100 {","highlight_start":1,"highlight_end":34},{"text":"                        let d1 = (n % 100) << 1;","highlight_start":1,"highlight_end":49},{"text":"                        n /= 100;","highlight_start":1,"highlight_end":34},{"text":"                        curr -= 2;","highlight_start":1,"highlight_end":35},{"text":"                        ptr::copy_nonoverlapping(lut_ptr.offset(d1), buf_ptr.offset(curr), 2);","highlight_start":1,"highlight_end":95},{"text":"                    }","highlight_start":1,"highlight_end":22},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                    // decode last 1 or 2 chars","highlight_start":1,"highlight_end":48},{"text":"                    if n < 10 {","highlight_start":1,"highlight_end":32},{"text":"                        curr -= 1;","highlight_start":1,"highlight_end":35},{"text":"                        *buf_ptr.offset(curr) = (n as u8) + b'0';","highlight_start":1,"highlight_end":66},{"text":"                    } else {","highlight_start":1,"highlight_end":29},{"text":"                        let d1 = n << 1;","highlight_start":1,"highlight_end":41},{"text":"                        curr -= 2;","highlight_start":1,"highlight_end":35},{"text":"                        ptr::copy_nonoverlapping(lut_ptr.offset(d1), buf_ptr.offset(curr), 2);","highlight_start":1,"highlight_end":95},{"text":"                    }","highlight_start":1,"highlight_end":22},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                    if !is_nonnegative {","highlight_start":1,"highlight_end":41},{"text":"                        curr -= 1;","highlight_start":1,"highlight_end":35},{"text":"                        *buf_ptr.offset(curr) = b'-';","highlight_start":1,"highlight_end":54},{"text":"                    }","highlight_start":1,"highlight_end":22},{"text":"                }","highlight_start":1,"highlight_end":18},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                let len = buf.len() - curr as usize;","highlight_start":1,"highlight_end":53},{"text":"                let bytes = unsafe { slice::from_raw_parts(buf_ptr.offset(curr), len) };","highlight_start":1,"highlight_end":89},{"text":"                unsafe { str::from_utf8_unchecked(bytes) }","highlight_start":1,"highlight_end":59},{"text":"            }","highlight_start":1,"highlight_end":14},{"text":"        }","highlight_start":1,"highlight_end":10},{"text":"    )*};","highlight_start":1,"highlight_end":9},{"text":"}","highlight_start":1,"highlight_end":2}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}}],"children":[],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0433]\u001b[0m\u001b[0m\u001b[1m\u001b[38;5;15m: failed to resolve: use of undeclared crate or module `mem`\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m--> \u001b[0m\u001b[0mC:\\Users\\ASUS\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\itoa-1.0.1\\src\\lib.rs:139:24\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14m139\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m| \u001b[0m\u001b[0m                    if mem::size_of::<$t>() >= 2 {\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m| \u001b[0m\u001b[0m                       \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9muse of undeclared crate or module `mem`\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14m...\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14m206\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m| \u001b[0m\u001b[0mimpl_Integer!(I64_MAX_LEN => i64, U64_MAX_LEN => u64 as u64);\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m| \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m------------------------------------------------------------\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14min this macro invocation\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m= \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;15mnote\u001b[0m\u001b[0m: this error originates in the macro `impl_Integer` (in Nightly builds, run with -Z macro-backtrace for more info)\u001b[0m\n\n"}
{"message":"failed to resolve: use of undeclared crate or module `ptr`","code":{"code":"E0433","explanation":"An undeclared crate, module, or type was used.\n\nErroneous code example:\n\n```compile_fail,E0433\nlet map = HashMap::new();\n// error: failed to resolve: use of undeclared type `HashMap`\n```\n\nPlease verify you didn't misspell the type/module's name or that you didn't\nforget to import it:\n\n```\nuse std::collections::HashMap; // HashMap has been imported.\nlet map: HashMap<u32, u32> = HashMap::new(); // So it can be used!\n```\n\nIf you've expected to use a crate name:\n\n```compile_fail\nuse ferris_wheel::BigO;\n// error: failed to resolve: use of undeclared crate or module `ferris_wheel`\n```\n\nMake sure the crate has been added as a dependency in `Cargo.toml`.\n\nTo use a module from your current crate, add the `crate::` prefix to the path.\n"},"level":"error","spans":[{"file_name":"C:\\Users\\ASUS\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\itoa-1.0.1\\src\\lib.rs","byte_start":5992,"byte_end":5995,"line_start":148,"line_end":148,"column_start":29,"column_end":32,"is_primary":true,"text":[{"text":"                            ptr::copy_nonoverlapping(lut_ptr.offset(d1), buf_ptr.offset(curr), 2);","highlight_start":29,"highlight_end":32}],"label":"use of undeclared crate or module `ptr`","suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"C:\\Users\\ASUS\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\itoa-1.0.1\\src\\lib.rs","byte_start":7925,"byte_end":7985,"line_start":206,"line_end":206,"column_start":1,"column_end":61,"is_primary":false,"text":[{"text":"impl_Integer!(I64_MAX_LEN => i64, U64_MAX_LEN => u64 as u64);","highlight_start":1,"highlight_end":61}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"impl_Integer!","def_site_span":{"file_name":"C:\\Users\\ASUS\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\itoa-1.0.1\\src\\lib.rs","byte_start":4595,"byte_end":7512,"line_start":116,"line_end":186,"column_start":1,"column_end":2,"is_primary":false,"text":[{"text":"macro_rules! impl_Integer {","highlight_start":1,"highlight_end":28},{"text":"    ($($max_len:expr => $t:ident),* as $conv_fn:ident) => {$(","highlight_start":1,"highlight_end":62},{"text":"        impl Integer for $t {}","highlight_start":1,"highlight_end":31},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        impl private::Sealed for $t {","highlight_start":1,"highlight_end":38},{"text":"            type Buffer = [MaybeUninit<u8>; $max_len];","highlight_start":1,"highlight_end":55},{"text":"","highlight_start":1,"highlight_end":1},{"text":"            #[allow(unused_comparisons)]","highlight_start":1,"highlight_end":41},{"text":"            #[inline]","highlight_start":1,"highlight_end":22},{"text":"            fn write(self, buf: &mut [MaybeUninit<u8>; $max_len]) -> &str {","highlight_start":1,"highlight_end":76},{"text":"                let is_nonnegative = self >= 0;","highlight_start":1,"highlight_end":48},{"text":"                let mut n = if is_nonnegative {","highlight_start":1,"highlight_end":48},{"text":"                    self as $conv_fn","highlight_start":1,"highlight_end":37},{"text":"                } else {","highlight_start":1,"highlight_end":25},{"text":"                    // convert the negative num to positive by summing 1 to it's 2 complement","highlight_start":1,"highlight_end":94},{"text":"                    (!(self as $conv_fn)).wrapping_add(1)","highlight_start":1,"highlight_end":58},{"text":"                };","highlight_start":1,"highlight_end":19},{"text":"                let mut curr = buf.len() as isize;","highlight_start":1,"highlight_end":51},{"text":"                let buf_ptr = buf.as_mut_ptr() as *mut u8;","highlight_start":1,"highlight_end":59},{"text":"                let lut_ptr = DEC_DIGITS_LUT.as_ptr();","highlight_start":1,"highlight_end":55},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                unsafe {","highlight_start":1,"highlight_end":25},{"text":"                    // need at least 16 bits for the 4-characters-at-a-time to work.","highlight_start":1,"highlight_end":85},{"text":"                    if mem::size_of::<$t>() >= 2 {","highlight_start":1,"highlight_end":51},{"text":"                        // eagerly decode 4 characters at a time","highlight_start":1,"highlight_end":65},{"text":"                        while n >= 10000 {","highlight_start":1,"highlight_end":43},{"text":"                            let rem = (n % 10000) as isize;","highlight_start":1,"highlight_end":60},{"text":"                            n /= 10000;","highlight_start":1,"highlight_end":40},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                            let d1 = (rem / 100) << 1;","highlight_start":1,"highlight_end":55},{"text":"                            let d2 = (rem % 100) << 1;","highlight_start":1,"highlight_end":55},{"text":"                            curr -= 4;","highlight_start":1,"highlight_end":39},{"text":"                            ptr::copy_nonoverlapping(lut_ptr.offset(d1), buf_ptr.offset(curr), 2);","highlight_start":1,"highlight_end":99},{"text":"                            ptr::copy_nonoverlapping(lut_ptr.offset(d2), buf_ptr.offset(curr + 2), 2);","highlight_start":1,"highlight_end":103},{"text":"                        }","highlight_start":1,"highlight_end":26},{"text":"                    }","highlight_start":1,"highlight_end":22},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                    // if we reach here numbers are <= 9999, so at most 4 chars long","highlight_start":1,"highlight_end":85},{"text":"                    let mut n = n as isize; // possibly reduce 64bit math","highlight_start":1,"highlight_end":74},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                    // decode 2 more chars, if > 2 chars","highlight_start":1,"highlight_end":57},{"text":"                    if n >= 100 {","highlight_start":1,"highlight_end":34},{"text":"                        let d1 = (n % 100) << 1;","highlight_start":1,"highlight_end":49},{"text":"                        n /= 100;","highlight_start":1,"highlight_end":34},{"text":"                        curr -= 2;","highlight_start":1,"highlight_end":35},{"text":"                        ptr::copy_nonoverlapping(lut_ptr.offset(d1), buf_ptr.offset(curr), 2);","highlight_start":1,"highlight_end":95},{"text":"                    }","highlight_start":1,"highlight_end":22},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                    // decode last 1 or 2 chars","highlight_start":1,"highlight_end":48},{"text":"                    if n < 10 {","highlight_start":1,"highlight_end":32},{"text":"                        curr -= 1;","highlight_start":1,"highlight_end":35},{"text":"                        *buf_ptr.offset(curr) = (n as u8) + b'0';","highlight_start":1,"highlight_end":66},{"text":"                    } else {","highlight_start":1,"highlight_end":29},{"text":"                        let d1 = n << 1;","highlight_start":1,"highlight_end":41},{"text":"                        curr -= 2;","highlight_start":1,"highlight_end":35},{"text":"                        ptr::copy_nonoverlapping(lut_ptr.offset(d1), buf_ptr.offset(curr), 2);","highlight_start":1,"highlight_end":95},{"text":"                    }","highlight_start":1,"highlight_end":22},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                    if !is_nonnegative {","highlight_start":1,"highlight_end":41},{"text":"                        curr -= 1;","highlight_start":1,"highlight_end":35},{"text":"                        *buf_ptr.offset(curr) = b'-';","highlight_start":1,"highlight_end":54},{"text":"                    }","highlight_start":1,"highlight_end":22},{"text":"                }","highlight_start":1,"highlight_end":18},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                let len = buf.len() - curr as usize;","highlight_start":1,"highlight_end":53},{"text":"                let bytes = unsafe { slice::from_raw_parts(buf_ptr.offset(curr), len) };","highlight_start":1,"highlight_end":89},{"text":"                unsafe { str::from_utf8_unchecked(bytes) }","highlight_start":1,"highlight_end":59},{"text":"            }","highlight_start":1,"highlight_end":14},{"text":"        }","highlight_start":1,"highlight_end":10},{"text":"    )*};","highlight_start":1,"highlight_end":9},{"text":"}","highlight_start":1,"highlight_end":2}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}}],"children":[],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0433]\u001b[0m\u001b[0m\u001b[1m\u001b[38;5;15m: failed to resolve: use of undeclared crate or module `ptr`\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m--> \u001b[0m\u001b[0mC:\\Users\\ASUS\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\itoa-1.0.1\\src\\lib.rs:148:29\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14m148\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m| \u001b[0m\u001b[0m                            ptr::copy_nonoverlapping(lut_ptr.offset(d1), buf_ptr.offset(curr), 2);\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m| \u001b[0m\u001b[0m                            \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9muse of undeclared crate or module `ptr`\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14m...\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14m206\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m| \u001b[0m\u001b[0mimpl_Integer!(I64_MAX_LEN => i64, U64_MAX_LEN => u64 as u64);\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m| \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m------------------------------------------------------------\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14min this macro invocation\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m= \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;15mnote\u001b[0m\u001b[0m: this error originates in the macro `impl_Integer` (in Nightly builds, run with -Z macro-backtrace for more info)\u001b[0m\n\n"}
{"message":"failed to resolve: use of undeclared crate or module `ptr`","code":{"code":"E0433","explanation":"An undeclared crate, module, or type was used.\n\nErroneous code example:\n\n```compile_fail,E0433\nlet map = HashMap::new();\n// error: failed to resolve: use of undeclared type `HashMap`\n```\n\nPlease verify you didn't misspell the type/module's name or that you didn't\nforget to import it:\n\n```\nuse std::collections::HashMap; // HashMap has been imported.\nlet map: HashMap<u32, u32> = HashMap::new(); // So it can be used!\n```\n\nIf you've expected to use a crate name:\n\n```compile_fail\nuse ferris_wheel::BigO;\n// error: failed to resolve: use of undeclared crate or module `ferris_wheel`\n```\n\nMake sure the crate has been added as a dependency in `Cargo.toml`.\n\nTo use a module from your current crate, add the `crate::` prefix to the path.\n"},"level":"error","spans":[{"file_name":"C:\\Users\\ASUS\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\itoa-1.0.1\\src\\lib.rs","byte_start":6091,"byte_end":6094,"line_start":149,"line_end":149,"column_start":29,"column_end":32,"is_primary":true,"text":[{"text":"                            ptr::copy_nonoverlapping(lut_ptr.offset(d2), buf_ptr.offset(curr + 2), 2);","highlight_start":29,"highlight_end":32}],"label":"use of undeclared crate or module `ptr`","suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"C:\\Users\\ASUS\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\itoa-1.0.1\\src\\lib.rs","byte_start":7925,"byte_end":7985,"line_start":206,"line_end":206,"column_start":1,"column_end":61,"is_primary":false,"text":[{"text":"impl_Integer!(I64_MAX_LEN => i64, U64_MAX_LEN => u64 as u64);","highlight_start":1,"highlight_end":61}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"impl_Integer!","def_site_span":{"file_name":"C:\\Users\\ASUS\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\itoa-1.0.1\\src\\lib.rs","byte_start":4595,"byte_end":7512,"line_start":116,"line_end":186,"column_start":1,"column_end":2,"is_primary":false,"text":[{"text":"macro_rules! impl_Integer {","highlight_start":1,"highlight_end":28},{"text":"    ($($max_len:expr => $t:ident),* as $conv_fn:ident) => {$(","highlight_start":1,"highlight_end":62},{"text":"        impl Integer for $t {}","highlight_start":1,"highlight_end":31},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        impl private::Sealed for $t {","highlight_start":1,"highlight_end":38},{"text":"            type Buffer = [MaybeUninit<u8>; $max_len];","highlight_start":1,"highlight_end":55},{"text":"","highlight_start":1,"highlight_end":1},{"text":"            #[allow(unused_comparisons)]","highlight_start":1,"highlight_end":41},{"text":"            #[inline]","highlight_start":1,"highlight_end":22},{"text":"            fn write(self, buf: &mut [MaybeUninit<u8>; $max_len]) -> &str {","highlight_start":1,"highlight_end":76},{"text":"                let is_nonnegative = self >= 0;","highlight_start":1,"highlight_end":48},{"text":"                let mut n = if is_nonnegative {","highlight_start":1,"highlight_end":48},{"text":"                    self as $conv_fn","highlight_start":1,"highlight_end":37},{"text":"                } else {","highlight_start":1,"highlight_end":25},{"text":"                    // convert the negative num to positive by summing 1 to it's 2 complement","highlight_start":1,"highlight_end":94},{"text":"                    (!(self as $conv_fn)).wrapping_add(1)","highlight_start":1,"highlight_end":58},{"text":"                };","highlight_start":1,"highlight_end":19},{"text":"                let mut curr = buf.len() as isize;","highlight_start":1,"highlight_end":51},{"text":"                let buf_ptr = buf.as_mut_ptr() as *mut u8;","highlight_start":1,"highlight_end":59},{"text":"                let lut_ptr = DEC_DIGITS_LUT.as_ptr();","highlight_start":1,"highlight_end":55},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                unsafe {","highlight_start":1,"highlight_end":25},{"text":"                    // need at least 16 bits for the 4-characters-at-a-time to work.","highlight_start":1,"highlight_end":85},{"text":"                    if mem::size_of::<$t>() >= 2 {","highlight_start":1,"highlight_end":51},{"text":"                        // eagerly decode 4 characters at a time","highlight_start":1,"highlight_end":65},{"text":"                        while n >= 10000 {","highlight_start":1,"highlight_end":43},{"text":"                            let rem = (n % 10000) as isize;","highlight_start":1,"highlight_end":60},{"text":"                            n /= 10000;","highlight_start":1,"highlight_end":40},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                            let d1 = (rem / 100) << 1;","highlight_start":1,"highlight_end":55},{"text":"                            let d2 = (rem % 100) << 1;","highlight_start":1,"highlight_end":55},{"text":"                            curr -= 4;","highlight_start":1,"highlight_end":39},{"text":"                            ptr::copy_nonoverlapping(lut_ptr.offset(d1), buf_ptr.offset(curr), 2);","highlight_start":1,"highlight_end":99},{"text":"                            ptr::copy_nonoverlapping(lut_ptr.offset(d2), buf_ptr.offset(curr + 2), 2);","highlight_start":1,"highlight_end":103},{"text":"                        }","highlight_start":1,"highlight_end":26},{"text":"                    }","highlight_start":1,"highlight_end":22},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                    // if we reach here numbers are <= 9999, so at most 4 chars long","highlight_start":1,"highlight_end":85},{"text":"                    let mut n = n as isize; // possibly reduce 64bit math","highlight_start":1,"highlight_end":74},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                    // decode 2 more chars, if > 2 chars","highlight_start":1,"highlight_end":57},{"text":"                    if n >= 100 {","highlight_start":1,"highlight_end":34},{"text":"                        let d1 = (n % 100) << 1;","highlight_start":1,"highlight_end":49},{"text":"                        n /= 100;","highlight_start":1,"highlight_end":34},{"text":"                        curr -= 2;","highlight_start":1,"highlight_end":35},{"text":"                        ptr::copy_nonoverlapping(lut_ptr.offset(d1), buf_ptr.offset(curr), 2);","highlight_start":1,"highlight_end":95},{"text":"                    }","highlight_start":1,"highlight_end":22},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                    // decode last 1 or 2 chars","highlight_start":1,"highlight_end":48},{"text":"                    if n < 10 {","highlight_start":1,"highlight_end":32},{"text":"                        curr -= 1;","highlight_start":1,"highlight_end":35},{"text":"                        *buf_ptr.offset(curr) = (n as u8) + b'0';","highlight_start":1,"highlight_end":66},{"text":"                    } else {","highlight_start":1,"highlight_end":29},{"text":"                        let d1 = n << 1;","highlight_start":1,"highlight_end":41},{"text":"                        curr -= 2;","highlight_start":1,"highlight_end":35},{"text":"                        ptr::copy_nonoverlapping(lut_ptr.offset(d1), buf_ptr.offset(curr), 2);","highlight_start":1,"highlight_end":95},{"text":"                    }","highlight_start":1,"highlight_end":22},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                    if !is_nonnegative {","highlight_start":1,"highlight_end":41},{"text":"                        curr -= 1;","highlight_start":1,"highlight_end":35},{"text":"                        *buf_ptr.offset(curr) = b'-';","highlight_start":1,"highlight_end":54},{"text":"                    }","highlight_start":1,"highlight_end":22},{"text":"                }","highlight_start":1,"highlight_end":18},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                let len = buf.len() - curr as usize;","highlight_start":1,"highlight_end":53},{"text":"                let bytes = unsafe { slice::from_raw_parts(buf_ptr.offset(curr), len) };","highlight_start":1,"highlight_end":89},{"text":"                unsafe { str::from_utf8_unchecked(bytes) }","highlight_start":1,"highlight_end":59},{"text":"            }","highlight_start":1,"highlight_end":14},{"text":"        }","highlight_start":1,"highlight_end":10},{"text":"    )*};","highlight_start":1,"highlight_end":9},{"text":"}","highlight_start":1,"highlight_end":2}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}}],"children":[],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0433]\u001b[0m\u001b[0m\u001b[1m\u001b[38;5;15m: failed to resolve: use of undeclared crate or module `ptr`\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m--> \u001b[0m\u001b[0mC:\\Users\\ASUS\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\itoa-1.0.1\\src\\lib.rs:149:29\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14m149\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m| \u001b[0m\u001b[0m                            ptr::copy_nonoverlapping(lut_ptr.offset(d2), buf_ptr.offset(curr + 2), 2);\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m| \u001b[0m\u001b[0m                            \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9muse of undeclared crate or module `ptr`\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14m...\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14m206\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m| \u001b[0m\u001b[0mimpl_Integer!(I64_MAX_LEN => i64, U64_MAX_LEN => u64 as u64);\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m| \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m------------------------------------------------------------\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14min this macro invocation\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m= \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;15mnote\u001b[0m\u001b[0m: this error originates in the macro `impl_Integer` (in Nightly builds, run with -Z macro-backtrace for more info)\u001b[0m\n\n"}
{"message":"failed to resolve: use of undeclared crate or module `ptr`","code":{"code":"E0433","explanation":"An undeclared crate, module, or type was used.\n\nErroneous code example:\n\n```compile_fail,E0433\nlet map = HashMap::new();\n// error: failed to resolve: use of undeclared type `HashMap`\n```\n\nPlease verify you didn't misspell the type/module's name or that you didn't\nforget to import it:\n\n```\nuse std::collections::HashMap; // HashMap has been imported.\nlet map: HashMap<u32, u32> = HashMap::new(); // So it can be used!\n```\n\nIf you've expected to use a crate name:\n\n```compile_fail\nuse ferris_wheel::BigO;\n// error: failed to resolve: use of undeclared crate or module `ferris_wheel`\n```\n\nMake sure the crate has been added as a dependency in `Cargo.toml`.\n\nTo use a module from your current crate, add the `crate::` prefix to the path.\n"},"level":"error","spans":[{"file_name":"C:\\Users\\ASUS\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\itoa-1.0.1\\src\\lib.rs","byte_start":6608,"byte_end":6611,"line_start":161,"line_end":161,"column_start":25,"column_end":28,"is_primary":true,"text":[{"text":"                        ptr::copy_nonoverlapping(lut_ptr.offset(d1), buf_ptr.offset(curr), 2);","highlight_start":25,"highlight_end":28}],"label":"use of undeclared crate or module `ptr`","suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"C:\\Users\\ASUS\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\itoa-1.0.1\\src\\lib.rs","byte_start":7925,"byte_end":7985,"line_start":206,"line_end":206,"column_start":1,"column_end":61,"is_primary":false,"text":[{"text":"impl_Integer!(I64_MAX_LEN => i64, U64_MAX_LEN => u64 as u64);","highlight_start":1,"highlight_end":61}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"impl_Integer!","def_site_span":{"file_name":"C:\\Users\\ASUS\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\itoa-1.0.1\\src\\lib.rs","byte_start":4595,"byte_end":7512,"line_start":116,"line_end":186,"column_start":1,"column_end":2,"is_primary":false,"text":[{"text":"macro_rules! impl_Integer {","highlight_start":1,"highlight_end":28},{"text":"    ($($max_len:expr => $t:ident),* as $conv_fn:ident) => {$(","highlight_start":1,"highlight_end":62},{"text":"        impl Integer for $t {}","highlight_start":1,"highlight_end":31},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        impl private::Sealed for $t {","highlight_start":1,"highlight_end":38},{"text":"            type Buffer = [MaybeUninit<u8>; $max_len];","highlight_start":1,"highlight_end":55},{"text":"","highlight_start":1,"highlight_end":1},{"text":"            #[allow(unused_comparisons)]","highlight_start":1,"highlight_end":41},{"text":"            #[inline]","highlight_start":1,"highlight_end":22},{"text":"            fn write(self, buf: &mut [MaybeUninit<u8>; $max_len]) -> &str {","highlight_start":1,"highlight_end":76},{"text":"                let is_nonnegative = self >= 0;","highlight_start":1,"highlight_end":48},{"text":"                let mut n = if is_nonnegative {","highlight_start":1,"highlight_end":48},{"text":"                    self as $conv_fn","highlight_start":1,"highlight_end":37},{"text":"                } else {","highlight_start":1,"highlight_end":25},{"text":"                    // convert the negative num to positive by summing 1 to it's 2 complement","highlight_start":1,"highlight_end":94},{"text":"                    (!(self as $conv_fn)).wrapping_add(1)","highlight_start":1,"highlight_end":58},{"text":"                };","highlight_start":1,"highlight_end":19},{"text":"                let mut curr = buf.len() as isize;","highlight_start":1,"highlight_end":51},{"text":"                let buf_ptr = buf.as_mut_ptr() as *mut u8;","highlight_start":1,"highlight_end":59},{"text":"                let lut_ptr = DEC_DIGITS_LUT.as_ptr();","highlight_start":1,"highlight_end":55},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                unsafe {","highlight_start":1,"highlight_end":25},{"text":"                    // need at least 16 bits for the 4-characters-at-a-time to work.","highlight_start":1,"highlight_end":85},{"text":"                    if mem::size_of::<$t>() >= 2 {","highlight_start":1,"highlight_end":51},{"text":"                        // eagerly decode 4 characters at a time","highlight_start":1,"highlight_end":65},{"text":"                        while n >= 10000 {","highlight_start":1,"highlight_end":43},{"text":"                            let rem = (n % 10000) as isize;","highlight_start":1,"highlight_end":60},{"text":"                            n /= 10000;","highlight_start":1,"highlight_end":40},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                            let d1 = (rem / 100) << 1;","highlight_start":1,"highlight_end":55},{"text":"                            let d2 = (rem % 100) << 1;","highlight_start":1,"highlight_end":55},{"text":"                            curr -= 4;","highlight_start":1,"highlight_end":39},{"text":"                            ptr::copy_nonoverlapping(lut_ptr.offset(d1), buf_ptr.offset(curr), 2);","highlight_start":1,"highlight_end":99},{"text":"                            ptr::copy_nonoverlapping(lut_ptr.offset(d2), buf_ptr.offset(curr + 2), 2);","highlight_start":1,"highlight_end":103},{"text":"                        }","highlight_start":1,"highlight_end":26},{"text":"                    }","highlight_start":1,"highlight_end":22},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                    // if we reach here numbers are <= 9999, so at most 4 chars long","highlight_start":1,"highlight_end":85},{"text":"                    let mut n = n as isize; // possibly reduce 64bit math","highlight_start":1,"highlight_end":74},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                    // decode 2 more chars, if > 2 chars","highlight_start":1,"highlight_end":57},{"text":"                    if n >= 100 {","highlight_start":1,"highlight_end":34},{"text":"                        let d1 = (n % 100) << 1;","highlight_start":1,"highlight_end":49},{"text":"                        n /= 100;","highlight_start":1,"highlight_end":34},{"text":"                        curr -= 2;","highlight_start":1,"highlight_end":35},{"text":"                        ptr::copy_nonoverlapping(lut_ptr.offset(d1), buf_ptr.offset(curr), 2);","highlight_start":1,"highlight_end":95},{"text":"                    }","highlight_start":1,"highlight_end":22},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                    // decode last 1 or 2 chars","highlight_start":1,"highlight_end":48},{"text":"                    if n < 10 {","highlight_start":1,"highlight_end":32},{"text":"                        curr -= 1;","highlight_start":1,"highlight_end":35},{"text":"                        *buf_ptr.offset(curr) = (n as u8) + b'0';","highlight_start":1,"highlight_end":66},{"text":"                    } else {","highlight_start":1,"highlight_end":29},{"text":"                        let d1 = n << 1;","highlight_start":1,"highlight_end":41},{"text":"                        curr -= 2;","highlight_start":1,"highlight_end":35},{"text":"                        ptr::copy_nonoverlapping(lut_ptr.offset(d1), buf_ptr.offset(curr), 2);","highlight_start":1,"highlight_end":95},{"text":"                    }","highlight_start":1,"highlight_end":22},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                    if !is_nonnegative {","highlight_start":1,"highlight_end":41},{"text":"                        curr -= 1;","highlight_start":1,"highlight_end":35},{"text":"                        *buf_ptr.offset(curr) = b'-';","highlight_start":1,"highlight_end":54},{"text":"                    }","highlight_start":1,"highlight_end":22},{"text":"                }","highlight_start":1,"highlight_end":18},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                let len = buf.len() - curr as usize;","highlight_start":1,"highlight_end":53},{"text":"                let bytes = unsafe { slice::from_raw_parts(buf_ptr.offset(curr), len) };","highlight_start":1,"highlight_end":89},{"text":"                unsafe { str::from_utf8_unchecked(bytes) }","highlight_start":1,"highlight_end":59},{"text":"            }","highlight_start":1,"highlight_end":14},{"text":"        }","highlight_start":1,"highlight_end":10},{"text":"    )*};","highlight_start":1,"highlight_end":9},{"text":"}","highlight_start":1,"highlight_end":2}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}}],"children":[],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0433]\u001b[0m\u001b[0m\u001b[1m\u001b[38;5;15m: failed to resolve: use of undeclared crate or module `ptr`\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m--> \u001b[0m\u001b[0mC:\\Users\\ASUS\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\itoa-1.0.1\\src\\lib.rs:161:25\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14m161\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m| \u001b[0m\u001b[0m                        ptr::copy_nonoverlapping(lut_ptr.offset(d1), buf_ptr.offset(curr), 2);\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m| \u001b[0m\u001b[0m                        \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9muse of undeclared crate or module `ptr`\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14m...\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14m206\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m| \u001b[0m\u001b[0mimpl_Integer!(I64_MAX_LEN => i64, U64_MAX_LEN => u64 as u64);\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m| \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m------------------------------------------------------------\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14min this macro invocation\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m= \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;15mnote\u001b[0m\u001b[0m: this error originates in the macro `impl_Integer` (in Nightly builds, run with -Z macro-backtrace for more info)\u001b[0m\n\n"}
{"message":"failed to resolve: use of undeclared crate or module `ptr`","code":{"code":"E0433","explanation":"An undeclared crate, module, or type was used.\n\nErroneous code example:\n\n```compile_fail,E0433\nlet map = HashMap::new();\n// error: failed to resolve: use of undeclared type `HashMap`\n```\n\nPlease verify you didn't misspell the type/module's name or that you didn't\nforget to import it:\n\n```\nuse std::collections::HashMap; // HashMap has been imported.\nlet map: HashMap<u32, u32> = HashMap::new(); // So it can be used!\n```\n\nIf you've expected to use a crate name:\n\n```compile_fail\nuse ferris_wheel::BigO;\n// error: failed to resolve: use of undeclared crate or module `ferris_wheel`\n```\n\nMake sure the crate has been added as a dependency in `Cargo.toml`.\n\nTo use a module from your current crate, add the `crate::` prefix to the path.\n"},"level":"error","spans":[{"file_name":"C:\\Users\\ASUS\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\itoa-1.0.1\\src\\lib.rs","byte_start":7012,"byte_end":7015,"line_start":171,"line_end":171,"column_start":25,"column_end":28,"is_primary":true,"text":[{"text":"                        ptr::copy_nonoverlapping(lut_ptr.offset(d1), buf_ptr.offset(curr), 2);","highlight_start":25,"highlight_end":28}],"label":"use of undeclared crate or module `ptr`","suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"C:\\Users\\ASUS\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\itoa-1.0.1\\src\\lib.rs","byte_start":7925,"byte_end":7985,"line_start":206,"line_end":206,"column_start":1,"column_end":61,"is_primary":false,"text":[{"text":"impl_Integer!(I64_MAX_LEN => i64, U64_MAX_LEN => u64 as u64);","highlight_start":1,"highlight_end":61}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"impl_Integer!","def_site_span":{"file_name":"C:\\Users\\ASUS\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\itoa-1.0.1\\src\\lib.rs","byte_start":4595,"byte_end":7512,"line_start":116,"line_end":186,"column_start":1,"column_end":2,"is_primary":false,"text":[{"text":"macro_rules! impl_Integer {","highlight_start":1,"highlight_end":28},{"text":"    ($($max_len:expr => $t:ident),* as $conv_fn:ident) => {$(","highlight_start":1,"highlight_end":62},{"text":"        impl Integer for $t {}","highlight_start":1,"highlight_end":31},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        impl private::Sealed for $t {","highlight_start":1,"highlight_end":38},{"text":"            type Buffer = [MaybeUninit<u8>; $max_len];","highlight_start":1,"highlight_end":55},{"text":"","highlight_start":1,"highlight_end":1},{"text":"            #[allow(unused_comparisons)]","highlight_start":1,"highlight_end":41},{"text":"            #[inline]","highlight_start":1,"highlight_end":22},{"text":"            fn write(self, buf: &mut [MaybeUninit<u8>; $max_len]) -> &str {","highlight_start":1,"highlight_end":76},{"text":"                let is_nonnegative = self >= 0;","highlight_start":1,"highlight_end":48},{"text":"                let mut n = if is_nonnegative {","highlight_start":1,"highlight_end":48},{"text":"                    self as $conv_fn","highlight_start":1,"highlight_end":37},{"text":"                } else {","highlight_start":1,"highlight_end":25},{"text":"                    // convert the negative num to positive by summing 1 to it's 2 complement","highlight_start":1,"highlight_end":94},{"text":"                    (!(self as $conv_fn)).wrapping_add(1)","highlight_start":1,"highlight_end":58},{"text":"                };","highlight_start":1,"highlight_end":19},{"text":"                let mut curr = buf.len() as isize;","highlight_start":1,"highlight_end":51},{"text":"                let buf_ptr = buf.as_mut_ptr() as *mut u8;","highlight_start":1,"highlight_end":59},{"text":"                let lut_ptr = DEC_DIGITS_LUT.as_ptr();","highlight_start":1,"highlight_end":55},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                unsafe {","highlight_start":1,"highlight_end":25},{"text":"                    // need at least 16 bits for the 4-characters-at-a-time to work.","highlight_start":1,"highlight_end":85},{"text":"                    if mem::size_of::<$t>() >= 2 {","highlight_start":1,"highlight_end":51},{"text":"                        // eagerly decode 4 characters at a time","highlight_start":1,"highlight_end":65},{"text":"                        while n >= 10000 {","highlight_start":1,"highlight_end":43},{"text":"                            let rem = (n % 10000) as isize;","highlight_start":1,"highlight_end":60},{"text":"                            n /= 10000;","highlight_start":1,"highlight_end":40},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                            let d1 = (rem / 100) << 1;","highlight_start":1,"highlight_end":55},{"text":"                            let d2 = (rem % 100) << 1;","highlight_start":1,"highlight_end":55},{"text":"                            curr -= 4;","highlight_start":1,"highlight_end":39},{"text":"                            ptr::copy_nonoverlapping(lut_ptr.offset(d1), buf_ptr.offset(curr), 2);","highlight_start":1,"highlight_end":99},{"text":"                            ptr::copy_nonoverlapping(lut_ptr.offset(d2), buf_ptr.offset(curr + 2), 2);","highlight_start":1,"highlight_end":103},{"text":"                        }","highlight_start":1,"highlight_end":26},{"text":"                    }","highlight_start":1,"highlight_end":22},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                    // if we reach here numbers are <= 9999, so at most 4 chars long","highlight_start":1,"highlight_end":85},{"text":"                    let mut n = n as isize; // possibly reduce 64bit math","highlight_start":1,"highlight_end":74},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                    // decode 2 more chars, if > 2 chars","highlight_start":1,"highlight_end":57},{"text":"                    if n >= 100 {","highlight_start":1,"highlight_end":34},{"text":"                        let d1 = (n % 100) << 1;","highlight_start":1,"highlight_end":49},{"text":"                        n /= 100;","highlight_start":1,"highlight_end":34},{"text":"                        curr -= 2;","highlight_start":1,"highlight_end":35},{"text":"                        ptr::copy_nonoverlapping(lut_ptr.offset(d1), buf_ptr.offset(curr), 2);","highlight_start":1,"highlight_end":95},{"text":"                    }","highlight_start":1,"highlight_end":22},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                    // decode last 1 or 2 chars","highlight_start":1,"highlight_end":48},{"text":"                    if n < 10 {","highlight_start":1,"highlight_end":32},{"text":"                        curr -= 1;","highlight_start":1,"highlight_end":35},{"text":"                        *buf_ptr.offset(curr) = (n as u8) + b'0';","highlight_start":1,"highlight_end":66},{"text":"                    } else {","highlight_start":1,"highlight_end":29},{"text":"                        let d1 = n << 1;","highlight_start":1,"highlight_end":41},{"text":"                        curr -= 2;","highlight_start":1,"highlight_end":35},{"text":"                        ptr::copy_nonoverlapping(lut_ptr.offset(d1), buf_ptr.offset(curr), 2);","highlight_start":1,"highlight_end":95},{"text":"                    }","highlight_start":1,"highlight_end":22},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                    if !is_nonnegative {","highlight_start":1,"highlight_end":41},{"text":"                        curr -= 1;","highlight_start":1,"highlight_end":35},{"text":"                        *buf_ptr.offset(curr) = b'-';","highlight_start":1,"highlight_end":54},{"text":"                    }","highlight_start":1,"highlight_end":22},{"text":"                }","highlight_start":1,"highlight_end":18},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                let len = buf.len() - curr as usize;","highlight_start":1,"highlight_end":53},{"text":"                let bytes = unsafe { slice::from_raw_parts(buf_ptr.offset(curr), len) };","highlight_start":1,"highlight_end":89},{"text":"                unsafe { str::from_utf8_unchecked(bytes) }","highlight_start":1,"highlight_end":59},{"text":"            }","highlight_start":1,"highlight_end":14},{"text":"        }","highlight_start":1,"highlight_end":10},{"text":"    )*};","highlight_start":1,"highlight_end":9},{"text":"}","highlight_start":1,"highlight_end":2}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}}],"children":[],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0433]\u001b[0m\u001b[0m\u001b[1m\u001b[38;5;15m: failed to resolve: use of undeclared crate or module `ptr`\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m--> \u001b[0m\u001b[0mC:\\Users\\ASUS\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\itoa-1.0.1\\src\\lib.rs:171:25\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14m171\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m| \u001b[0m\u001b[0m                        ptr::copy_nonoverlapping(lut_ptr.offset(d1), buf_ptr.offset(curr), 2);\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m| \u001b[0m\u001b[0m                        \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9muse of undeclared crate or module `ptr`\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14m...\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14m206\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m| \u001b[0m\u001b[0mimpl_Integer!(I64_MAX_LEN => i64, U64_MAX_LEN => u64 as u64);\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m| \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m------------------------------------------------------------\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14min this macro invocation\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m= \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;15mnote\u001b[0m\u001b[0m: this error originates in the macro `impl_Integer` (in Nightly builds, run with -Z macro-backtrace for more info)\u001b[0m\n\n"}
{"message":"failed to resolve: use of undeclared crate or module `slice`","code":{"code":"E0433","explanation":"An undeclared crate, module, or type was used.\n\nErroneous code example:\n\n```compile_fail,E0433\nlet map = HashMap::new();\n// error: failed to resolve: use of undeclared type `HashMap`\n```\n\nPlease verify you didn't misspell the type/module's name or that you didn't\nforget to import it:\n\n```\nuse std::collections::HashMap; // HashMap has been imported.\nlet map: HashMap<u32, u32> = HashMap::new(); // So it can be used!\n```\n\nIf you've expected to use a crate name:\n\n```compile_fail\nuse ferris_wheel::BigO;\n// error: failed to resolve: use of undeclared crate or module `ferris_wheel`\n```\n\nMake sure the crate has been added as a dependency in `Cargo.toml`.\n\nTo use a module from your current crate, add the `crate::` prefix to the path.\n"},"level":"error","spans":[{"file_name":"C:\\Users\\ASUS\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\itoa-1.0.1\\src\\lib.rs","byte_start":7367,"byte_end":7372,"line_start":181,"line_end":181,"column_start":38,"column_end":43,"is_primary":true,"text":[{"text":"                let bytes = unsafe { slice::from_raw_parts(buf_ptr.offset(curr), len) };","highlight_start":38,"highlight_end":43}],"label":"use of undeclared crate or module `slice`","suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"C:\\Users\\ASUS\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\itoa-1.0.1\\src\\lib.rs","byte_start":7925,"byte_end":7985,"line_start":206,"line_end":206,"column_start":1,"column_end":61,"is_primary":false,"text":[{"text":"impl_Integer!(I64_MAX_LEN => i64, U64_MAX_LEN => u64 as u64);","highlight_start":1,"highlight_end":61}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"impl_Integer!","def_site_span":{"file_name":"C:\\Users\\ASUS\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\itoa-1.0.1\\src\\lib.rs","byte_start":4595,"byte_end":7512,"line_start":116,"line_end":186,"column_start":1,"column_end":2,"is_primary":false,"text":[{"text":"macro_rules! impl_Integer {","highlight_start":1,"highlight_end":28},{"text":"    ($($max_len:expr => $t:ident),* as $conv_fn:ident) => {$(","highlight_start":1,"highlight_end":62},{"text":"        impl Integer for $t {}","highlight_start":1,"highlight_end":31},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        impl private::Sealed for $t {","highlight_start":1,"highlight_end":38},{"text":"            type Buffer = [MaybeUninit<u8>; $max_len];","highlight_start":1,"highlight_end":55},{"text":"","highlight_start":1,"highlight_end":1},{"text":"            #[allow(unused_comparisons)]","highlight_start":1,"highlight_end":41},{"text":"            #[inline]","highlight_start":1,"highlight_end":22},{"text":"            fn write(self, buf: &mut [MaybeUninit<u8>; $max_len]) -> &str {","highlight_start":1,"highlight_end":76},{"text":"                let is_nonnegative = self >= 0;","highlight_start":1,"highlight_end":48},{"text":"                let mut n = if is_nonnegative {","highlight_start":1,"highlight_end":48},{"text":"                    self as $conv_fn","highlight_start":1,"highlight_end":37},{"text":"                } else {","highlight_start":1,"highlight_end":25},{"text":"                    // convert the negative num to positive by summing 1 to it's 2 complement","highlight_start":1,"highlight_end":94},{"text":"                    (!(self as $conv_fn)).wrapping_add(1)","highlight_start":1,"highlight_end":58},{"text":"                };","highlight_start":1,"highlight_end":19},{"text":"                let mut curr = buf.len() as isize;","highlight_start":1,"highlight_end":51},{"text":"                let buf_ptr = buf.as_mut_ptr() as *mut u8;","highlight_start":1,"highlight_end":59},{"text":"                let lut_ptr = DEC_DIGITS_LUT.as_ptr();","highlight_start":1,"highlight_end":55},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                unsafe {","highlight_start":1,"highlight_end":25},{"text":"                    // need at least 16 bits for the 4-characters-at-a-time to work.","highlight_start":1,"highlight_end":85},{"text":"                    if mem::size_of::<$t>() >= 2 {","highlight_start":1,"highlight_end":51},{"text":"                        // eagerly decode 4 characters at a time","highlight_start":1,"highlight_end":65},{"text":"                        while n >= 10000 {","highlight_start":1,"highlight_end":43},{"text":"                            let rem = (n % 10000) as isize;","highlight_start":1,"highlight_end":60},{"text":"                            n /= 10000;","highlight_start":1,"highlight_end":40},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                            let d1 = (rem / 100) << 1;","highlight_start":1,"highlight_end":55},{"text":"                            let d2 = (rem % 100) << 1;","highlight_start":1,"highlight_end":55},{"text":"                            curr -= 4;","highlight_start":1,"highlight_end":39},{"text":"                            ptr::copy_nonoverlapping(lut_ptr.offset(d1), buf_ptr.offset(curr), 2);","highlight_start":1,"highlight_end":99},{"text":"                            ptr::copy_nonoverlapping(lut_ptr.offset(d2), buf_ptr.offset(curr + 2), 2);","highlight_start":1,"highlight_end":103},{"text":"                        }","highlight_start":1,"highlight_end":26},{"text":"                    }","highlight_start":1,"highlight_end":22},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                    // if we reach here numbers are <= 9999, so at most 4 chars long","highlight_start":1,"highlight_end":85},{"text":"                    let mut n = n as isize; // possibly reduce 64bit math","highlight_start":1,"highlight_end":74},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                    // decode 2 more chars, if > 2 chars","highlight_start":1,"highlight_end":57},{"text":"                    if n >= 100 {","highlight_start":1,"highlight_end":34},{"text":"                        let d1 = (n % 100) << 1;","highlight_start":1,"highlight_end":49},{"text":"                        n /= 100;","highlight_start":1,"highlight_end":34},{"text":"                        curr -= 2;","highlight_start":1,"highlight_end":35},{"text":"                        ptr::copy_nonoverlapping(lut_ptr.offset(d1), buf_ptr.offset(curr), 2);","highlight_start":1,"highlight_end":95},{"text":"                    }","highlight_start":1,"highlight_end":22},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                    // decode last 1 or 2 chars","highlight_start":1,"highlight_end":48},{"text":"                    if n < 10 {","highlight_start":1,"highlight_end":32},{"text":"                        curr -= 1;","highlight_start":1,"highlight_end":35},{"text":"                        *buf_ptr.offset(curr) = (n as u8) + b'0';","highlight_start":1,"highlight_end":66},{"text":"                    } else {","highlight_start":1,"highlight_end":29},{"text":"                        let d1 = n << 1;","highlight_start":1,"highlight_end":41},{"text":"                        curr -= 2;","highlight_start":1,"highlight_end":35},{"text":"                        ptr::copy_nonoverlapping(lut_ptr.offset(d1), buf_ptr.offset(curr), 2);","highlight_start":1,"highlight_end":95},{"text":"                    }","highlight_start":1,"highlight_end":22},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                    if !is_nonnegative {","highlight_start":1,"highlight_end":41},{"text":"                        curr -= 1;","highlight_start":1,"highlight_end":35},{"text":"                        *buf_ptr.offset(curr) = b'-';","highlight_start":1,"highlight_end":54},{"text":"                    }","highlight_start":1,"highlight_end":22},{"text":"                }","highlight_start":1,"highlight_end":18},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                let len = buf.len() - curr as usize;","highlight_start":1,"highlight_end":53},{"text":"                let bytes = unsafe { slice::from_raw_parts(buf_ptr.offset(curr), len) };","highlight_start":1,"highlight_end":89},{"text":"                unsafe { str::from_utf8_unchecked(bytes) }","highlight_start":1,"highlight_end":59},{"text":"            }","highlight_start":1,"highlight_end":14},{"text":"        }","highlight_start":1,"highlight_end":10},{"text":"    )*};","highlight_start":1,"highlight_end":9},{"text":"}","highlight_start":1,"highlight_end":2}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}}],"children":[],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0433]\u001b[0m\u001b[0m\u001b[1m\u001b[38;5;15m: failed to resolve: use of undeclared crate or module `slice`\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m--> \u001b[0m\u001b[0mC:\\Users\\ASUS\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\itoa-1.0.1\\src\\lib.rs:181:38\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14m181\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m| \u001b[0m\u001b[0m                let bytes = unsafe { slice::from_raw_parts(buf_ptr.offset(curr), len) };\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m| \u001b[0m\u001b[0m                                     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9muse of undeclared crate or module `slice`\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14m...\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14m206\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m| \u001b[0m\u001b[0mimpl_Integer!(I64_MAX_LEN => i64, U64_MAX_LEN => u64 as u64);\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m| \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m------------------------------------------------------------\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14min this macro invocation\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m= \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;15mnote\u001b[0m\u001b[0m: this error originates in the macro `impl_Integer` (in Nightly builds, run with -Z macro-backtrace for more info)\u001b[0m\n\n"}
{"message":"failed to resolve: use of undeclared crate or module `mem`","code":{"code":"E0433","explanation":"An undeclared crate, module, or type was used.\n\nErroneous code example:\n\n```compile_fail,E0433\nlet map = HashMap::new();\n// error: failed to resolve: use of undeclared type `HashMap`\n```\n\nPlease verify you didn't misspell the type/module's name or that you didn't\nforget to import it:\n\n```\nuse std::collections::HashMap; // HashMap has been imported.\nlet map: HashMap<u32, u32> = HashMap::new(); // So it can be used!\n```\n\nIf you've expected to use a crate name:\n\n```compile_fail\nuse ferris_wheel::BigO;\n// error: failed to resolve: use of undeclared crate or module `ferris_wheel`\n```\n\nMake sure the crate has been added as a dependency in `Cargo.toml`.\n\nTo use a module from your current crate, add the `crate::` prefix to the path.\n"},"level":"error","spans":[{"file_name":"C:\\Users\\ASUS\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\itoa-1.0.1\\src\\lib.rs","byte_start":5578,"byte_end":5581,"line_start":139,"line_end":139,"column_start":24,"column_end":27,"is_primary":true,"text":[{"text":"                    if mem::size_of::<$t>() >= 2 {","highlight_start":24,"highlight_end":27}],"label":"use of undeclared crate or module `mem`","suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"C:\\Users\\ASUS\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\itoa-1.0.1\\src\\lib.rs","byte_start":8127,"byte_end":8191,"line_start":212,"line_end":212,"column_start":1,"column_end":65,"is_primary":false,"text":[{"text":"impl_Integer!(I32_MAX_LEN => isize, U32_MAX_LEN => usize as u32);","highlight_start":1,"highlight_end":65}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"impl_Integer!","def_site_span":{"file_name":"C:\\Users\\ASUS\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\itoa-1.0.1\\src\\lib.rs","byte_start":4595,"byte_end":7512,"line_start":116,"line_end":186,"column_start":1,"column_end":2,"is_primary":false,"text":[{"text":"macro_rules! impl_Integer {","highlight_start":1,"highlight_end":28},{"text":"    ($($max_len:expr => $t:ident),* as $conv_fn:ident) => {$(","highlight_start":1,"highlight_end":62},{"text":"        impl Integer for $t {}","highlight_start":1,"highlight_end":31},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        impl private::Sealed for $t {","highlight_start":1,"highlight_end":38},{"text":"            type Buffer = [MaybeUninit<u8>; $max_len];","highlight_start":1,"highlight_end":55},{"text":"","highlight_start":1,"highlight_end":1},{"text":"            #[allow(unused_comparisons)]","highlight_start":1,"highlight_end":41},{"text":"            #[inline]","highlight_start":1,"highlight_end":22},{"text":"            fn write(self, buf: &mut [MaybeUninit<u8>; $max_len]) -> &str {","highlight_start":1,"highlight_end":76},{"text":"                let is_nonnegative = self >= 0;","highlight_start":1,"highlight_end":48},{"text":"                let mut n = if is_nonnegative {","highlight_start":1,"highlight_end":48},{"text":"                    self as $conv_fn","highlight_start":1,"highlight_end":37},{"text":"                } else {","highlight_start":1,"highlight_end":25},{"text":"                    // convert the negative num to positive by summing 1 to it's 2 complement","highlight_start":1,"highlight_end":94},{"text":"                    (!(self as $conv_fn)).wrapping_add(1)","highlight_start":1,"highlight_end":58},{"text":"                };","highlight_start":1,"highlight_end":19},{"text":"                let mut curr = buf.len() as isize;","highlight_start":1,"highlight_end":51},{"text":"                let buf_ptr = buf.as_mut_ptr() as *mut u8;","highlight_start":1,"highlight_end":59},{"text":"                let lut_ptr = DEC_DIGITS_LUT.as_ptr();","highlight_start":1,"highlight_end":55},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                unsafe {","highlight_start":1,"highlight_end":25},{"text":"                    // need at least 16 bits for the 4-characters-at-a-time to work.","highlight_start":1,"highlight_end":85},{"text":"                    if mem::size_of::<$t>() >= 2 {","highlight_start":1,"highlight_end":51},{"text":"                        // eagerly decode 4 characters at a time","highlight_start":1,"highlight_end":65},{"text":"                        while n >= 10000 {","highlight_start":1,"highlight_end":43},{"text":"                            let rem = (n % 10000) as isize;","highlight_start":1,"highlight_end":60},{"text":"                            n /= 10000;","highlight_start":1,"highlight_end":40},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                            let d1 = (rem / 100) << 1;","highlight_start":1,"highlight_end":55},{"text":"                            let d2 = (rem % 100) << 1;","highlight_start":1,"highlight_end":55},{"text":"                            curr -= 4;","highlight_start":1,"highlight_end":39},{"text":"                            ptr::copy_nonoverlapping(lut_ptr.offset(d1), buf_ptr.offset(curr), 2);","highlight_start":1,"highlight_end":99},{"text":"                            ptr::copy_nonoverlapping(lut_ptr.offset(d2), buf_ptr.offset(curr + 2), 2);","highlight_start":1,"highlight_end":103},{"text":"                        }","highlight_start":1,"highlight_end":26},{"text":"                    }","highlight_start":1,"highlight_end":22},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                    // if we reach here numbers are <= 9999, so at most 4 chars long","highlight_start":1,"highlight_end":85},{"text":"                    let mut n = n as isize; // possibly reduce 64bit math","highlight_start":1,"highlight_end":74},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                    // decode 2 more chars, if > 2 chars","highlight_start":1,"highlight_end":57},{"text":"                    if n >= 100 {","highlight_start":1,"highlight_end":34},{"text":"                        let d1 = (n % 100) << 1;","highlight_start":1,"highlight_end":49},{"text":"                        n /= 100;","highlight_start":1,"highlight_end":34},{"text":"                        curr -= 2;","highlight_start":1,"highlight_end":35},{"text":"                        ptr::copy_nonoverlapping(lut_ptr.offset(d1), buf_ptr.offset(curr), 2);","highlight_start":1,"highlight_end":95},{"text":"                    }","highlight_start":1,"highlight_end":22},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                    // decode last 1 or 2 chars","highlight_start":1,"highlight_end":48},{"text":"                    if n < 10 {","highlight_start":1,"highlight_end":32},{"text":"                        curr -= 1;","highlight_start":1,"highlight_end":35},{"text":"                        *buf_ptr.offset(curr) = (n as u8) + b'0';","highlight_start":1,"highlight_end":66},{"text":"                    } else {","highlight_start":1,"highlight_end":29},{"text":"                        let d1 = n << 1;","highlight_start":1,"highlight_end":41},{"text":"                        curr -= 2;","highlight_start":1,"highlight_end":35},{"text":"                        ptr::copy_nonoverlapping(lut_ptr.offset(d1), buf_ptr.offset(curr), 2);","highlight_start":1,"highlight_end":95},{"text":"                    }","highlight_start":1,"highlight_end":22},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                    if !is_nonnegative {","highlight_start":1,"highlight_end":41},{"text":"                        curr -= 1;","highlight_start":1,"highlight_end":35},{"text":"                        *buf_ptr.offset(curr) = b'-';","highlight_start":1,"highlight_end":54},{"text":"                    }","highlight_start":1,"highlight_end":22},{"text":"                }","highlight_start":1,"highlight_end":18},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                let len = buf.len() - curr as usize;","highlight_start":1,"highlight_end":53},{"text":"                let bytes = unsafe { slice::from_raw_parts(buf_ptr.offset(curr), len) };","highlight_start":1,"highlight_end":89},{"text":"                unsafe { str::from_utf8_unchecked(bytes) }","highlight_start":1,"highlight_end":59},{"text":"            }","highlight_start":1,"highlight_end":14},{"text":"        }","highlight_start":1,"highlight_end":10},{"text":"    )*};","highlight_start":1,"highlight_end":9},{"text":"}","highlight_start":1,"highlight_end":2}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}}],"children":[],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0433]\u001b[0m\u001b[0m\u001b[1m\u001b[38;5;15m: failed to resolve: use of undeclared crate or module `mem`\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m--> \u001b[0m\u001b[0mC:\\Users\\ASUS\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\itoa-1.0.1\\src\\lib.rs:139:24\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14m139\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m| \u001b[0m\u001b[0m                    if mem::size_of::<$t>() >= 2 {\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m| \u001b[0m\u001b[0m                       \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9muse of undeclared crate or module `mem`\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14m...\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14m212\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m| \u001b[0m\u001b[0mimpl_Integer!(I32_MAX_LEN => isize, U32_MAX_LEN => usize as u32);\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m| \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m----------------------------------------------------------------\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14min this macro invocation\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m= \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;15mnote\u001b[0m\u001b[0m: this error originates in the macro `impl_Integer` (in Nightly builds, run with -Z macro-backtrace for more info)\u001b[0m\n\n"}
{"message":"failed to resolve: use of undeclared crate or module `ptr`","code":{"code":"E0433","explanation":"An undeclared crate, module, or type was used.\n\nErroneous code example:\n\n```compile_fail,E0433\nlet map = HashMap::new();\n// error: failed to resolve: use of undeclared type `HashMap`\n```\n\nPlease verify you didn't misspell the type/module's name or that you didn't\nforget to import it:\n\n```\nuse std::collections::HashMap; // HashMap has been imported.\nlet map: HashMap<u32, u32> = HashMap::new(); // So it can be used!\n```\n\nIf you've expected to use a crate name:\n\n```compile_fail\nuse ferris_wheel::BigO;\n// error: failed to resolve: use of undeclared crate or module `ferris_wheel`\n```\n\nMake sure the crate has been added as a dependency in `Cargo.toml`.\n\nTo use a module from your current crate, add the `crate::` prefix to the path.\n"},"level":"error","spans":[{"file_name":"C:\\Users\\ASUS\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\itoa-1.0.1\\src\\lib.rs","byte_start":5992,"byte_end":5995,"line_start":148,"line_end":148,"column_start":29,"column_end":32,"is_primary":true,"text":[{"text":"                            ptr::copy_nonoverlapping(lut_ptr.offset(d1), buf_ptr.offset(curr), 2);","highlight_start":29,"highlight_end":32}],"label":"use of undeclared crate or module `ptr`","suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"C:\\Users\\ASUS\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\itoa-1.0.1\\src\\lib.rs","byte_start":8127,"byte_end":8191,"line_start":212,"line_end":212,"column_start":1,"column_end":65,"is_primary":false,"text":[{"text":"impl_Integer!(I32_MAX_LEN => isize, U32_MAX_LEN => usize as u32);","highlight_start":1,"highlight_end":65}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"impl_Integer!","def_site_span":{"file_name":"C:\\Users\\ASUS\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\itoa-1.0.1\\src\\lib.rs","byte_start":4595,"byte_end":7512,"line_start":116,"line_end":186,"column_start":1,"column_end":2,"is_primary":false,"text":[{"text":"macro_rules! impl_Integer {","highlight_start":1,"highlight_end":28},{"text":"    ($($max_len:expr => $t:ident),* as $conv_fn:ident) => {$(","highlight_start":1,"highlight_end":62},{"text":"        impl Integer for $t {}","highlight_start":1,"highlight_end":31},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        impl private::Sealed for $t {","highlight_start":1,"highlight_end":38},{"text":"            type Buffer = [MaybeUninit<u8>; $max_len];","highlight_start":1,"highlight_end":55},{"text":"","highlight_start":1,"highlight_end":1},{"text":"            #[allow(unused_comparisons)]","highlight_start":1,"highlight_end":41},{"text":"            #[inline]","highlight_start":1,"highlight_end":22},{"text":"            fn write(self, buf: &mut [MaybeUninit<u8>; $max_len]) -> &str {","highlight_start":1,"highlight_end":76},{"text":"                let is_nonnegative = self >= 0;","highlight_start":1,"highlight_end":48},{"text":"                let mut n = if is_nonnegative {","highlight_start":1,"highlight_end":48},{"text":"                    self as $conv_fn","highlight_start":1,"highlight_end":37},{"text":"                } else {","highlight_start":1,"highlight_end":25},{"text":"                    // convert the negative num to positive by summing 1 to it's 2 complement","highlight_start":1,"highlight_end":94},{"text":"                    (!(self as $conv_fn)).wrapping_add(1)","highlight_start":1,"highlight_end":58},{"text":"                };","highlight_start":1,"highlight_end":19},{"text":"                let mut curr = buf.len() as isize;","highlight_start":1,"highlight_end":51},{"text":"                let buf_ptr = buf.as_mut_ptr() as *mut u8;","highlight_start":1,"highlight_end":59},{"text":"                let lut_ptr = DEC_DIGITS_LUT.as_ptr();","highlight_start":1,"highlight_end":55},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                unsafe {","highlight_start":1,"highlight_end":25},{"text":"                    // need at least 16 bits for the 4-characters-at-a-time to work.","highlight_start":1,"highlight_end":85},{"text":"                    if mem::size_of::<$t>() >= 2 {","highlight_start":1,"highlight_end":51},{"text":"                        // eagerly decode 4 characters at a time","highlight_start":1,"highlight_end":65},{"text":"                        while n >= 10000 {","highlight_start":1,"highlight_end":43},{"text":"                            let rem = (n % 10000) as isize;","highlight_start":1,"highlight_end":60},{"text":"                            n /= 10000;","highlight_start":1,"highlight_end":40},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                            let d1 = (rem / 100) << 1;","highlight_start":1,"highlight_end":55},{"text":"                            let d2 = (rem % 100) << 1;","highlight_start":1,"highlight_end":55},{"text":"                            curr -= 4;","highlight_start":1,"highlight_end":39},{"text":"                            ptr::copy_nonoverlapping(lut_ptr.offset(d1), buf_ptr.offset(curr), 2);","highlight_start":1,"highlight_end":99},{"text":"                            ptr::copy_nonoverlapping(lut_ptr.offset(d2), buf_ptr.offset(curr + 2), 2);","highlight_start":1,"highlight_end":103},{"text":"                        }","highlight_start":1,"highlight_end":26},{"text":"                    }","highlight_start":1,"highlight_end":22},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                    // if we reach here numbers are <= 9999, so at most 4 chars long","highlight_start":1,"highlight_end":85},{"text":"                    let mut n = n as isize; // possibly reduce 64bit math","highlight_start":1,"highlight_end":74},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                    // decode 2 more chars, if > 2 chars","highlight_start":1,"highlight_end":57},{"text":"                    if n >= 100 {","highlight_start":1,"highlight_end":34},{"text":"                        let d1 = (n % 100) << 1;","highlight_start":1,"highlight_end":49},{"text":"                        n /= 100;","highlight_start":1,"highlight_end":34},{"text":"                        curr -= 2;","highlight_start":1,"highlight_end":35},{"text":"                        ptr::copy_nonoverlapping(lut_ptr.offset(d1), buf_ptr.offset(curr), 2);","highlight_start":1,"highlight_end":95},{"text":"                    }","highlight_start":1,"highlight_end":22},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                    // decode last 1 or 2 chars","highlight_start":1,"highlight_end":48},{"text":"                    if n < 10 {","highlight_start":1,"highlight_end":32},{"text":"                        curr -= 1;","highlight_start":1,"highlight_end":35},{"text":"                        *buf_ptr.offset(curr) = (n as u8) + b'0';","highlight_start":1,"highlight_end":66},{"text":"                    } else {","highlight_start":1,"highlight_end":29},{"text":"                        let d1 = n << 1;","highlight_start":1,"highlight_end":41},{"text":"                        curr -= 2;","highlight_start":1,"highlight_end":35},{"text":"                        ptr::copy_nonoverlapping(lut_ptr.offset(d1), buf_ptr.offset(curr), 2);","highlight_start":1,"highlight_end":95},{"text":"                    }","highlight_start":1,"highlight_end":22},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                    if !is_nonnegative {","highlight_start":1,"highlight_end":41},{"text":"                        curr -= 1;","highlight_start":1,"highlight_end":35},{"text":"                        *buf_ptr.offset(curr) = b'-';","highlight_start":1,"highlight_end":54},{"text":"                    }","highlight_start":1,"highlight_end":22},{"text":"                }","highlight_start":1,"highlight_end":18},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                let len = buf.len() - curr as usize;","highlight_start":1,"highlight_end":53},{"text":"                let bytes = unsafe { slice::from_raw_parts(buf_ptr.offset(curr), len) };","highlight_start":1,"highlight_end":89},{"text":"                unsafe { str::from_utf8_unchecked(bytes) }","highlight_start":1,"highlight_end":59},{"text":"            }","highlight_start":1,"highlight_end":14},{"text":"        }","highlight_start":1,"highlight_end":10},{"text":"    )*};","highlight_start":1,"highlight_end":9},{"text":"}","highlight_start":1,"highlight_end":2}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}}],"children":[],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0433]\u001b[0m\u001b[0m\u001b[1m\u001b[38;5;15m: failed to resolve: use of undeclared crate or module `ptr`\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m--> \u001b[0m\u001b[0mC:\\Users\\ASUS\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\itoa-1.0.1\\src\\lib.rs:148:29\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14m148\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m| \u001b[0m\u001b[0m                            ptr::copy_nonoverlapping(lut_ptr.offset(d1), buf_ptr.offset(curr), 2);\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m| \u001b[0m\u001b[0m                            \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9muse of undeclared crate or module `ptr`\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14m...\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14m212\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m| \u001b[0m\u001b[0mimpl_Integer!(I32_MAX_LEN => isize, U32_MAX_LEN => usize as u32);\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m| \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m----------------------------------------------------------------\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14min this macro invocation\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m= \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;15mnote\u001b[0m\u001b[0m: this error originates in the macro `impl_Integer` (in Nightly builds, run with -Z macro-backtrace for more info)\u001b[0m\n\n"}
{"message":"failed to resolve: use of undeclared crate or module `ptr`","code":{"code":"E0433","explanation":"An undeclared crate, module, or type was used.\n\nErroneous code example:\n\n```compile_fail,E0433\nlet map = HashMap::new();\n// error: failed to resolve: use of undeclared type `HashMap`\n```\n\nPlease verify you didn't misspell the type/module's name or that you didn't\nforget to import it:\n\n```\nuse std::collections::HashMap; // HashMap has been imported.\nlet map: HashMap<u32, u32> = HashMap::new(); // So it can be used!\n```\n\nIf you've expected to use a crate name:\n\n```compile_fail\nuse ferris_wheel::BigO;\n// error: failed to resolve: use of undeclared crate or module `ferris_wheel`\n```\n\nMake sure the crate has been added as a dependency in `Cargo.toml`.\n\nTo use a module from your current crate, add the `crate::` prefix to the path.\n"},"level":"error","spans":[{"file_name":"C:\\Users\\ASUS\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\itoa-1.0.1\\src\\lib.rs","byte_start":6091,"byte_end":6094,"line_start":149,"line_end":149,"column_start":29,"column_end":32,"is_primary":true,"text":[{"text":"                            ptr::copy_nonoverlapping(lut_ptr.offset(d2), buf_ptr.offset(curr + 2), 2);","highlight_start":29,"highlight_end":32}],"label":"use of undeclared crate or module `ptr`","suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"C:\\Users\\ASUS\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\itoa-1.0.1\\src\\lib.rs","byte_start":8127,"byte_end":8191,"line_start":212,"line_end":212,"column_start":1,"column_end":65,"is_primary":false,"text":[{"text":"impl_Integer!(I32_MAX_LEN => isize, U32_MAX_LEN => usize as u32);","highlight_start":1,"highlight_end":65}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"impl_Integer!","def_site_span":{"file_name":"C:\\Users\\ASUS\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\itoa-1.0.1\\src\\lib.rs","byte_start":4595,"byte_end":7512,"line_start":116,"line_end":186,"column_start":1,"column_end":2,"is_primary":false,"text":[{"text":"macro_rules! impl_Integer {","highlight_start":1,"highlight_end":28},{"text":"    ($($max_len:expr => $t:ident),* as $conv_fn:ident) => {$(","highlight_start":1,"highlight_end":62},{"text":"        impl Integer for $t {}","highlight_start":1,"highlight_end":31},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        impl private::Sealed for $t {","highlight_start":1,"highlight_end":38},{"text":"            type Buffer = [MaybeUninit<u8>; $max_len];","highlight_start":1,"highlight_end":55},{"text":"","highlight_start":1,"highlight_end":1},{"text":"            #[allow(unused_comparisons)]","highlight_start":1,"highlight_end":41},{"text":"            #[inline]","highlight_start":1,"highlight_end":22},{"text":"            fn write(self, buf: &mut [MaybeUninit<u8>; $max_len]) -> &str {","highlight_start":1,"highlight_end":76},{"text":"                let is_nonnegative = self >= 0;","highlight_start":1,"highlight_end":48},{"text":"                let mut n = if is_nonnegative {","highlight_start":1,"highlight_end":48},{"text":"                    self as $conv_fn","highlight_start":1,"highlight_end":37},{"text":"                } else {","highlight_start":1,"highlight_end":25},{"text":"                    // convert the negative num to positive by summing 1 to it's 2 complement","highlight_start":1,"highlight_end":94},{"text":"                    (!(self as $conv_fn)).wrapping_add(1)","highlight_start":1,"highlight_end":58},{"text":"                };","highlight_start":1,"highlight_end":19},{"text":"                let mut curr = buf.len() as isize;","highlight_start":1,"highlight_end":51},{"text":"                let buf_ptr = buf.as_mut_ptr() as *mut u8;","highlight_start":1,"highlight_end":59},{"text":"                let lut_ptr = DEC_DIGITS_LUT.as_ptr();","highlight_start":1,"highlight_end":55},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                unsafe {","highlight_start":1,"highlight_end":25},{"text":"                    // need at least 16 bits for the 4-characters-at-a-time to work.","highlight_start":1,"highlight_end":85},{"text":"                    if mem::size_of::<$t>() >= 2 {","highlight_start":1,"highlight_end":51},{"text":"                        // eagerly decode 4 characters at a time","highlight_start":1,"highlight_end":65},{"text":"                        while n >= 10000 {","highlight_start":1,"highlight_end":43},{"text":"                            let rem = (n % 10000) as isize;","highlight_start":1,"highlight_end":60},{"text":"                            n /= 10000;","highlight_start":1,"highlight_end":40},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                            let d1 = (rem / 100) << 1;","highlight_start":1,"highlight_end":55},{"text":"                            let d2 = (rem % 100) << 1;","highlight_start":1,"highlight_end":55},{"text":"                            curr -= 4;","highlight_start":1,"highlight_end":39},{"text":"                            ptr::copy_nonoverlapping(lut_ptr.offset(d1), buf_ptr.offset(curr), 2);","highlight_start":1,"highlight_end":99},{"text":"                            ptr::copy_nonoverlapping(lut_ptr.offset(d2), buf_ptr.offset(curr + 2), 2);","highlight_start":1,"highlight_end":103},{"text":"                        }","highlight_start":1,"highlight_end":26},{"text":"                    }","highlight_start":1,"highlight_end":22},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                    // if we reach here numbers are <= 9999, so at most 4 chars long","highlight_start":1,"highlight_end":85},{"text":"                    let mut n = n as isize; // possibly reduce 64bit math","highlight_start":1,"highlight_end":74},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                    // decode 2 more chars, if > 2 chars","highlight_start":1,"highlight_end":57},{"text":"                    if n >= 100 {","highlight_start":1,"highlight_end":34},{"text":"                        let d1 = (n % 100) << 1;","highlight_start":1,"highlight_end":49},{"text":"                        n /= 100;","highlight_start":1,"highlight_end":34},{"text":"                        curr -= 2;","highlight_start":1,"highlight_end":35},{"text":"                        ptr::copy_nonoverlapping(lut_ptr.offset(d1), buf_ptr.offset(curr), 2);","highlight_start":1,"highlight_end":95},{"text":"                    }","highlight_start":1,"highlight_end":22},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                    // decode last 1 or 2 chars","highlight_start":1,"highlight_end":48},{"text":"                    if n < 10 {","highlight_start":1,"highlight_end":32},{"text":"                        curr -= 1;","highlight_start":1,"highlight_end":35},{"text":"                        *buf_ptr.offset(curr) = (n as u8) + b'0';","highlight_start":1,"highlight_end":66},{"text":"                    } else {","highlight_start":1,"highlight_end":29},{"text":"                        let d1 = n << 1;","highlight_start":1,"highlight_end":41},{"text":"                        curr -= 2;","highlight_start":1,"highlight_end":35},{"text":"                        ptr::copy_nonoverlapping(lut_ptr.offset(d1), buf_ptr.offset(curr), 2);","highlight_start":1,"highlight_end":95},{"text":"                    }","highlight_start":1,"highlight_end":22},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                    if !is_nonnegative {","highlight_start":1,"highlight_end":41},{"text":"                        curr -= 1;","highlight_start":1,"highlight_end":35},{"text":"                        *buf_ptr.offset(curr) = b'-';","highlight_start":1,"highlight_end":54},{"text":"                    }","highlight_start":1,"highlight_end":22},{"text":"                }","highlight_start":1,"highlight_end":18},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                let len = buf.len() - curr as usize;","highlight_start":1,"highlight_end":53},{"text":"                let bytes = unsafe { slice::from_raw_parts(buf_ptr.offset(curr), len) };","highlight_start":1,"highlight_end":89},{"text":"                unsafe { str::from_utf8_unchecked(bytes) }","highlight_start":1,"highlight_end":59},{"text":"            }","highlight_start":1,"highlight_end":14},{"text":"        }","highlight_start":1,"highlight_end":10},{"text":"    )*};","highlight_start":1,"highlight_end":9},{"text":"}","highlight_start":1,"highlight_end":2}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}}],"children":[],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0433]\u001b[0m\u001b[0m\u001b[1m\u001b[38;5;15m: failed to resolve: use of undeclared crate or module `ptr`\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m--> \u001b[0m\u001b[0mC:\\Users\\ASUS\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\itoa-1.0.1\\src\\lib.rs:149:29\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14m149\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m| \u001b[0m\u001b[0m                            ptr::copy_nonoverlapping(lut_ptr.offset(d2), buf_ptr.offset(curr + 2), 2);\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m| \u001b[0m\u001b[0m                            \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9muse of undeclared crate or module `ptr`\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14m...\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14m212\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m| \u001b[0m\u001b[0mimpl_Integer!(I32_MAX_LEN => isize, U32_MAX_LEN => usize as u32);\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m| \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m----------------------------------------------------------------\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14min this macro invocation\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m= \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;15mnote\u001b[0m\u001b[0m: this error originates in the macro `impl_Integer` (in Nightly builds, run with -Z macro-backtrace for more info)\u001b[0m\n\n"}
{"message":"failed to resolve: use of undeclared crate or module `ptr`","code":{"code":"E0433","explanation":"An undeclared crate, module, or type was used.\n\nErroneous code example:\n\n```compile_fail,E0433\nlet map = HashMap::new();\n// error: failed to resolve: use of undeclared type `HashMap`\n```\n\nPlease verify you didn't misspell the type/module's name or that you didn't\nforget to import it:\n\n```\nuse std::collections::HashMap; // HashMap has been imported.\nlet map: HashMap<u32, u32> = HashMap::new(); // So it can be used!\n```\n\nIf you've expected to use a crate name:\n\n```compile_fail\nuse ferris_wheel::BigO;\n// error: failed to resolve: use of undeclared crate or module `ferris_wheel`\n```\n\nMake sure the crate has been added as a dependency in `Cargo.toml`.\n\nTo use a module from your current crate, add the `crate::` prefix to the path.\n"},"level":"error","spans":[{"file_name":"C:\\Users\\ASUS\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\itoa-1.0.1\\src\\lib.rs","byte_start":6608,"byte_end":6611,"line_start":161,"line_end":161,"column_start":25,"column_end":28,"is_primary":true,"text":[{"text":"                        ptr::copy_nonoverlapping(lut_ptr.offset(d1), buf_ptr.offset(curr), 2);","highlight_start":25,"highlight_end":28}],"label":"use of undeclared crate or module `ptr`","suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"C:\\Users\\ASUS\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\itoa-1.0.1\\src\\lib.rs","byte_start":8127,"byte_end":8191,"line_start":212,"line_end":212,"column_start":1,"column_end":65,"is_primary":false,"text":[{"text":"impl_Integer!(I32_MAX_LEN => isize, U32_MAX_LEN => usize as u32);","highlight_start":1,"highlight_end":65}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"impl_Integer!","def_site_span":{"file_name":"C:\\Users\\ASUS\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\itoa-1.0.1\\src\\lib.rs","byte_start":4595,"byte_end":7512,"line_start":116,"line_end":186,"column_start":1,"column_end":2,"is_primary":false,"text":[{"text":"macro_rules! impl_Integer {","highlight_start":1,"highlight_end":28},{"text":"    ($($max_len:expr => $t:ident),* as $conv_fn:ident) => {$(","highlight_start":1,"highlight_end":62},{"text":"        impl Integer for $t {}","highlight_start":1,"highlight_end":31},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        impl private::Sealed for $t {","highlight_start":1,"highlight_end":38},{"text":"            type Buffer = [MaybeUninit<u8>; $max_len];","highlight_start":1,"highlight_end":55},{"text":"","highlight_start":1,"highlight_end":1},{"text":"            #[allow(unused_comparisons)]","highlight_start":1,"highlight_end":41},{"text":"            #[inline]","highlight_start":1,"highlight_end":22},{"text":"            fn write(self, buf: &mut [MaybeUninit<u8>; $max_len]) -> &str {","highlight_start":1,"highlight_end":76},{"text":"                let is_nonnegative = self >= 0;","highlight_start":1,"highlight_end":48},{"text":"                let mut n = if is_nonnegative {","highlight_start":1,"highlight_end":48},{"text":"                    self as $conv_fn","highlight_start":1,"highlight_end":37},{"text":"                } else {","highlight_start":1,"highlight_end":25},{"text":"                    // convert the negative num to positive by summing 1 to it's 2 complement","highlight_start":1,"highlight_end":94},{"text":"                    (!(self as $conv_fn)).wrapping_add(1)","highlight_start":1,"highlight_end":58},{"text":"                };","highlight_start":1,"highlight_end":19},{"text":"                let mut curr = buf.len() as isize;","highlight_start":1,"highlight_end":51},{"text":"                let buf_ptr = buf.as_mut_ptr() as *mut u8;","highlight_start":1,"highlight_end":59},{"text":"                let lut_ptr = DEC_DIGITS_LUT.as_ptr();","highlight_start":1,"highlight_end":55},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                unsafe {","highlight_start":1,"highlight_end":25},{"text":"                    // need at least 16 bits for the 4-characters-at-a-time to work.","highlight_start":1,"highlight_end":85},{"text":"                    if mem::size_of::<$t>() >= 2 {","highlight_start":1,"highlight_end":51},{"text":"                        // eagerly decode 4 characters at a time","highlight_start":1,"highlight_end":65},{"text":"                        while n >= 10000 {","highlight_start":1,"highlight_end":43},{"text":"                            let rem = (n % 10000) as isize;","highlight_start":1,"highlight_end":60},{"text":"                            n /= 10000;","highlight_start":1,"highlight_end":40},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                            let d1 = (rem / 100) << 1;","highlight_start":1,"highlight_end":55},{"text":"                            let d2 = (rem % 100) << 1;","highlight_start":1,"highlight_end":55},{"text":"                            curr -= 4;","highlight_start":1,"highlight_end":39},{"text":"                            ptr::copy_nonoverlapping(lut_ptr.offset(d1), buf_ptr.offset(curr), 2);","highlight_start":1,"highlight_end":99},{"text":"                            ptr::copy_nonoverlapping(lut_ptr.offset(d2), buf_ptr.offset(curr + 2), 2);","highlight_start":1,"highlight_end":103},{"text":"                        }","highlight_start":1,"highlight_end":26},{"text":"                    }","highlight_start":1,"highlight_end":22},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                    // if we reach here numbers are <= 9999, so at most 4 chars long","highlight_start":1,"highlight_end":85},{"text":"                    let mut n = n as isize; // possibly reduce 64bit math","highlight_start":1,"highlight_end":74},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                    // decode 2 more chars, if > 2 chars","highlight_start":1,"highlight_end":57},{"text":"                    if n >= 100 {","highlight_start":1,"highlight_end":34},{"text":"                        let d1 = (n % 100) << 1;","highlight_start":1,"highlight_end":49},{"text":"                        n /= 100;","highlight_start":1,"highlight_end":34},{"text":"                        curr -= 2;","highlight_start":1,"highlight_end":35},{"text":"                        ptr::copy_nonoverlapping(lut_ptr.offset(d1), buf_ptr.offset(curr), 2);","highlight_start":1,"highlight_end":95},{"text":"                    }","highlight_start":1,"highlight_end":22},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                    // decode last 1 or 2 chars","highlight_start":1,"highlight_end":48},{"text":"                    if n < 10 {","highlight_start":1,"highlight_end":32},{"text":"                        curr -= 1;","highlight_start":1,"highlight_end":35},{"text":"                        *buf_ptr.offset(curr) = (n as u8) + b'0';","highlight_start":1,"highlight_end":66},{"text":"                    } else {","highlight_start":1,"highlight_end":29},{"text":"                        let d1 = n << 1;","highlight_start":1,"highlight_end":41},{"text":"                        curr -= 2;","highlight_start":1,"highlight_end":35},{"text":"                        ptr::copy_nonoverlapping(lut_ptr.offset(d1), buf_ptr.offset(curr), 2);","highlight_start":1,"highlight_end":95},{"text":"                    }","highlight_start":1,"highlight_end":22},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                    if !is_nonnegative {","highlight_start":1,"highlight_end":41},{"text":"                        curr -= 1;","highlight_start":1,"highlight_end":35},{"text":"                        *buf_ptr.offset(curr) = b'-';","highlight_start":1,"highlight_end":54},{"text":"                    }","highlight_start":1,"highlight_end":22},{"text":"                }","highlight_start":1,"highlight_end":18},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                let len = buf.len() - curr as usize;","highlight_start":1,"highlight_end":53},{"text":"                let bytes = unsafe { slice::from_raw_parts(buf_ptr.offset(curr), len) };","highlight_start":1,"highlight_end":89},{"text":"                unsafe { str::from_utf8_unchecked(bytes) }","highlight_start":1,"highlight_end":59},{"text":"            }","highlight_start":1,"highlight_end":14},{"text":"        }","highlight_start":1,"highlight_end":10},{"text":"    )*};","highlight_start":1,"highlight_end":9},{"text":"}","highlight_start":1,"highlight_end":2}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}}],"children":[],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0433]\u001b[0m\u001b[0m\u001b[1m\u001b[38;5;15m: failed to resolve: use of undeclared crate or module `ptr`\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m--> \u001b[0m\u001b[0mC:\\Users\\ASUS\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\itoa-1.0.1\\src\\lib.rs:161:25\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14m161\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m| \u001b[0m\u001b[0m                        ptr::copy_nonoverlapping(lut_ptr.offset(d1), buf_ptr.offset(curr), 2);\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m| \u001b[0m\u001b[0m                        \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9muse of undeclared crate or module `ptr`\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14m...\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14m212\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m| \u001b[0m\u001b[0mimpl_Integer!(I32_MAX_LEN => isize, U32_MAX_LEN => usize as u32);\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m| \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m----------------------------------------------------------------\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14min this macro invocation\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m= \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;15mnote\u001b[0m\u001b[0m: this error originates in the macro `impl_Integer` (in Nightly builds, run with -Z macro-backtrace for more info)\u001b[0m\n\n"}
{"message":"failed to resolve: use of undeclared crate or module `ptr`","code":{"code":"E0433","explanation":"An undeclared crate, module, or type was used.\n\nErroneous code example:\n\n```compile_fail,E0433\nlet map = HashMap::new();\n// error: failed to resolve: use of undeclared type `HashMap`\n```\n\nPlease verify you didn't misspell the type/module's name or that you didn't\nforget to import it:\n\n```\nuse std::collections::HashMap; // HashMap has been imported.\nlet map: HashMap<u32, u32> = HashMap::new(); // So it can be used!\n```\n\nIf you've expected to use a crate name:\n\n```compile_fail\nuse ferris_wheel::BigO;\n// error: failed to resolve: use of undeclared crate or module `ferris_wheel`\n```\n\nMake sure the crate has been added as a dependency in `Cargo.toml`.\n\nTo use a module from your current crate, add the `crate::` prefix to the path.\n"},"level":"error","spans":[{"file_name":"C:\\Users\\ASUS\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\itoa-1.0.1\\src\\lib.rs","byte_start":7012,"byte_end":7015,"line_start":171,"line_end":171,"column_start":25,"column_end":28,"is_primary":true,"text":[{"text":"                        ptr::copy_nonoverlapping(lut_ptr.offset(d1), buf_ptr.offset(curr), 2);","highlight_start":25,"highlight_end":28}],"label":"use of undeclared crate or module `ptr`","suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"C:\\Users\\ASUS\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\itoa-1.0.1\\src\\lib.rs","byte_start":8127,"byte_end":8191,"line_start":212,"line_end":212,"column_start":1,"column_end":65,"is_primary":false,"text":[{"text":"impl_Integer!(I32_MAX_LEN => isize, U32_MAX_LEN => usize as u32);","highlight_start":1,"highlight_end":65}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"impl_Integer!","def_site_span":{"file_name":"C:\\Users\\ASUS\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\itoa-1.0.1\\src\\lib.rs","byte_start":4595,"byte_end":7512,"line_start":116,"line_end":186,"column_start":1,"column_end":2,"is_primary":false,"text":[{"text":"macro_rules! impl_Integer {","highlight_start":1,"highlight_end":28},{"text":"    ($($max_len:expr => $t:ident),* as $conv_fn:ident) => {$(","highlight_start":1,"highlight_end":62},{"text":"        impl Integer for $t {}","highlight_start":1,"highlight_end":31},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        impl private::Sealed for $t {","highlight_start":1,"highlight_end":38},{"text":"            type Buffer = [MaybeUninit<u8>; $max_len];","highlight_start":1,"highlight_end":55},{"text":"","highlight_start":1,"highlight_end":1},{"text":"            #[allow(unused_comparisons)]","highlight_start":1,"highlight_end":41},{"text":"            #[inline]","highlight_start":1,"highlight_end":22},{"text":"            fn write(self, buf: &mut [MaybeUninit<u8>; $max_len]) -> &str {","highlight_start":1,"highlight_end":76},{"text":"                let is_nonnegative = self >= 0;","highlight_start":1,"highlight_end":48},{"text":"                let mut n = if is_nonnegative {","highlight_start":1,"highlight_end":48},{"text":"                    self as $conv_fn","highlight_start":1,"highlight_end":37},{"text":"                } else {","highlight_start":1,"highlight_end":25},{"text":"                    // convert the negative num to positive by summing 1 to it's 2 complement","highlight_start":1,"highlight_end":94},{"text":"                    (!(self as $conv_fn)).wrapping_add(1)","highlight_start":1,"highlight_end":58},{"text":"                };","highlight_start":1,"highlight_end":19},{"text":"                let mut curr = buf.len() as isize;","highlight_start":1,"highlight_end":51},{"text":"                let buf_ptr = buf.as_mut_ptr() as *mut u8;","highlight_start":1,"highlight_end":59},{"text":"                let lut_ptr = DEC_DIGITS_LUT.as_ptr();","highlight_start":1,"highlight_end":55},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                unsafe {","highlight_start":1,"highlight_end":25},{"text":"                    // need at least 16 bits for the 4-characters-at-a-time to work.","highlight_start":1,"highlight_end":85},{"text":"                    if mem::size_of::<$t>() >= 2 {","highlight_start":1,"highlight_end":51},{"text":"                        // eagerly decode 4 characters at a time","highlight_start":1,"highlight_end":65},{"text":"                        while n >= 10000 {","highlight_start":1,"highlight_end":43},{"text":"                            let rem = (n % 10000) as isize;","highlight_start":1,"highlight_end":60},{"text":"                            n /= 10000;","highlight_start":1,"highlight_end":40},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                            let d1 = (rem / 100) << 1;","highlight_start":1,"highlight_end":55},{"text":"                            let d2 = (rem % 100) << 1;","highlight_start":1,"highlight_end":55},{"text":"                            curr -= 4;","highlight_start":1,"highlight_end":39},{"text":"                            ptr::copy_nonoverlapping(lut_ptr.offset(d1), buf_ptr.offset(curr), 2);","highlight_start":1,"highlight_end":99},{"text":"                            ptr::copy_nonoverlapping(lut_ptr.offset(d2), buf_ptr.offset(curr + 2), 2);","highlight_start":1,"highlight_end":103},{"text":"                        }","highlight_start":1,"highlight_end":26},{"text":"                    }","highlight_start":1,"highlight_end":22},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                    // if we reach here numbers are <= 9999, so at most 4 chars long","highlight_start":1,"highlight_end":85},{"text":"                    let mut n = n as isize; // possibly reduce 64bit math","highlight_start":1,"highlight_end":74},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                    // decode 2 more chars, if > 2 chars","highlight_start":1,"highlight_end":57},{"text":"                    if n >= 100 {","highlight_start":1,"highlight_end":34},{"text":"                        let d1 = (n % 100) << 1;","highlight_start":1,"highlight_end":49},{"text":"                        n /= 100;","highlight_start":1,"highlight_end":34},{"text":"                        curr -= 2;","highlight_start":1,"highlight_end":35},{"text":"                        ptr::copy_nonoverlapping(lut_ptr.offset(d1), buf_ptr.offset(curr), 2);","highlight_start":1,"highlight_end":95},{"text":"                    }","highlight_start":1,"highlight_end":22},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                    // decode last 1 or 2 chars","highlight_start":1,"highlight_end":48},{"text":"                    if n < 10 {","highlight_start":1,"highlight_end":32},{"text":"                        curr -= 1;","highlight_start":1,"highlight_end":35},{"text":"                        *buf_ptr.offset(curr) = (n as u8) + b'0';","highlight_start":1,"highlight_end":66},{"text":"                    } else {","highlight_start":1,"highlight_end":29},{"text":"                        let d1 = n << 1;","highlight_start":1,"highlight_end":41},{"text":"                        curr -= 2;","highlight_start":1,"highlight_end":35},{"text":"                        ptr::copy_nonoverlapping(lut_ptr.offset(d1), buf_ptr.offset(curr), 2);","highlight_start":1,"highlight_end":95},{"text":"                    }","highlight_start":1,"highlight_end":22},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                    if !is_nonnegative {","highlight_start":1,"highlight_end":41},{"text":"                        curr -= 1;","highlight_start":1,"highlight_end":35},{"text":"                        *buf_ptr.offset(curr) = b'-';","highlight_start":1,"highlight_end":54},{"text":"                    }","highlight_start":1,"highlight_end":22},{"text":"                }","highlight_start":1,"highlight_end":18},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                let len = buf.len() - curr as usize;","highlight_start":1,"highlight_end":53},{"text":"                let bytes = unsafe { slice::from_raw_parts(buf_ptr.offset(curr), len) };","highlight_start":1,"highlight_end":89},{"text":"                unsafe { str::from_utf8_unchecked(bytes) }","highlight_start":1,"highlight_end":59},{"text":"            }","highlight_start":1,"highlight_end":14},{"text":"        }","highlight_start":1,"highlight_end":10},{"text":"    )*};","highlight_start":1,"highlight_end":9},{"text":"}","highlight_start":1,"highlight_end":2}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}}],"children":[],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0433]\u001b[0m\u001b[0m\u001b[1m\u001b[38;5;15m: failed to resolve: use of undeclared crate or module `ptr`\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m--> \u001b[0m\u001b[0mC:\\Users\\ASUS\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\itoa-1.0.1\\src\\lib.rs:171:25\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14m171\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m| \u001b[0m\u001b[0m                        ptr::copy_nonoverlapping(lut_ptr.offset(d1), buf_ptr.offset(curr), 2);\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m| \u001b[0m\u001b[0m                        \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9muse of undeclared crate or module `ptr`\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14m...\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14m212\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m| \u001b[0m\u001b[0mimpl_Integer!(I32_MAX_LEN => isize, U32_MAX_LEN => usize as u32);\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m| \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m----------------------------------------------------------------\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14min this macro invocation\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m= \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;15mnote\u001b[0m\u001b[0m: this error originates in the macro `impl_Integer` (in Nightly builds, run with -Z macro-backtrace for more info)\u001b[0m\n\n"}
{"message":"failed to resolve: use of undeclared crate or module `slice`","code":{"code":"E0433","explanation":"An undeclared crate, module, or type was used.\n\nErroneous code example:\n\n```compile_fail,E0433\nlet map = HashMap::new();\n// error: failed to resolve: use of undeclared type `HashMap`\n```\n\nPlease verify you didn't misspell the type/module's name or that you didn't\nforget to import it:\n\n```\nuse std::collections::HashMap; // HashMap has been imported.\nlet map: HashMap<u32, u32> = HashMap::new(); // So it can be used!\n```\n\nIf you've expected to use a crate name:\n\n```compile_fail\nuse ferris_wheel::BigO;\n// error: failed to resolve: use of undeclared crate or module `ferris_wheel`\n```\n\nMake sure the crate has been added as a dependency in `Cargo.toml`.\n\nTo use a module from your current crate, add the `crate::` prefix to the path.\n"},"level":"error","spans":[{"file_name":"C:\\Users\\ASUS\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\itoa-1.0.1\\src\\lib.rs","byte_start":7367,"byte_end":7372,"line_start":181,"line_end":181,"column_start":38,"column_end":43,"is_primary":true,"text":[{"text":"                let bytes = unsafe { slice::from_raw_parts(buf_ptr.offset(curr), len) };","highlight_start":38,"highlight_end":43}],"label":"use of undeclared crate or module `slice`","suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"C:\\Users\\ASUS\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\itoa-1.0.1\\src\\lib.rs","byte_start":8127,"byte_end":8191,"line_start":212,"line_end":212,"column_start":1,"column_end":65,"is_primary":false,"text":[{"text":"impl_Integer!(I32_MAX_LEN => isize, U32_MAX_LEN => usize as u32);","highlight_start":1,"highlight_end":65}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"impl_Integer!","def_site_span":{"file_name":"C:\\Users\\ASUS\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\itoa-1.0.1\\src\\lib.rs","byte_start":4595,"byte_end":7512,"line_start":116,"line_end":186,"column_start":1,"column_end":2,"is_primary":false,"text":[{"text":"macro_rules! impl_Integer {","highlight_start":1,"highlight_end":28},{"text":"    ($($max_len:expr => $t:ident),* as $conv_fn:ident) => {$(","highlight_start":1,"highlight_end":62},{"text":"        impl Integer for $t {}","highlight_start":1,"highlight_end":31},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        impl private::Sealed for $t {","highlight_start":1,"highlight_end":38},{"text":"            type Buffer = [MaybeUninit<u8>; $max_len];","highlight_start":1,"highlight_end":55},{"text":"","highlight_start":1,"highlight_end":1},{"text":"            #[allow(unused_comparisons)]","highlight_start":1,"highlight_end":41},{"text":"            #[inline]","highlight_start":1,"highlight_end":22},{"text":"            fn write(self, buf: &mut [MaybeUninit<u8>; $max_len]) -> &str {","highlight_start":1,"highlight_end":76},{"text":"                let is_nonnegative = self >= 0;","highlight_start":1,"highlight_end":48},{"text":"                let mut n = if is_nonnegative {","highlight_start":1,"highlight_end":48},{"text":"                    self as $conv_fn","highlight_start":1,"highlight_end":37},{"text":"                } else {","highlight_start":1,"highlight_end":25},{"text":"                    // convert the negative num to positive by summing 1 to it's 2 complement","highlight_start":1,"highlight_end":94},{"text":"                    (!(self as $conv_fn)).wrapping_add(1)","highlight_start":1,"highlight_end":58},{"text":"                };","highlight_start":1,"highlight_end":19},{"text":"                let mut curr = buf.len() as isize;","highlight_start":1,"highlight_end":51},{"text":"                let buf_ptr = buf.as_mut_ptr() as *mut u8;","highlight_start":1,"highlight_end":59},{"text":"                let lut_ptr = DEC_DIGITS_LUT.as_ptr();","highlight_start":1,"highlight_end":55},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                unsafe {","highlight_start":1,"highlight_end":25},{"text":"                    // need at least 16 bits for the 4-characters-at-a-time to work.","highlight_start":1,"highlight_end":85},{"text":"                    if mem::size_of::<$t>() >= 2 {","highlight_start":1,"highlight_end":51},{"text":"                        // eagerly decode 4 characters at a time","highlight_start":1,"highlight_end":65},{"text":"                        while n >= 10000 {","highlight_start":1,"highlight_end":43},{"text":"                            let rem = (n % 10000) as isize;","highlight_start":1,"highlight_end":60},{"text":"                            n /= 10000;","highlight_start":1,"highlight_end":40},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                            let d1 = (rem / 100) << 1;","highlight_start":1,"highlight_end":55},{"text":"                            let d2 = (rem % 100) << 1;","highlight_start":1,"highlight_end":55},{"text":"                            curr -= 4;","highlight_start":1,"highlight_end":39},{"text":"                            ptr::copy_nonoverlapping(lut_ptr.offset(d1), buf_ptr.offset(curr), 2);","highlight_start":1,"highlight_end":99},{"text":"                            ptr::copy_nonoverlapping(lut_ptr.offset(d2), buf_ptr.offset(curr + 2), 2);","highlight_start":1,"highlight_end":103},{"text":"                        }","highlight_start":1,"highlight_end":26},{"text":"                    }","highlight_start":1,"highlight_end":22},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                    // if we reach here numbers are <= 9999, so at most 4 chars long","highlight_start":1,"highlight_end":85},{"text":"                    let mut n = n as isize; // possibly reduce 64bit math","highlight_start":1,"highlight_end":74},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                    // decode 2 more chars, if > 2 chars","highlight_start":1,"highlight_end":57},{"text":"                    if n >= 100 {","highlight_start":1,"highlight_end":34},{"text":"                        let d1 = (n % 100) << 1;","highlight_start":1,"highlight_end":49},{"text":"                        n /= 100;","highlight_start":1,"highlight_end":34},{"text":"                        curr -= 2;","highlight_start":1,"highlight_end":35},{"text":"                        ptr::copy_nonoverlapping(lut_ptr.offset(d1), buf_ptr.offset(curr), 2);","highlight_start":1,"highlight_end":95},{"text":"                    }","highlight_start":1,"highlight_end":22},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                    // decode last 1 or 2 chars","highlight_start":1,"highlight_end":48},{"text":"                    if n < 10 {","highlight_start":1,"highlight_end":32},{"text":"                        curr -= 1;","highlight_start":1,"highlight_end":35},{"text":"                        *buf_ptr.offset(curr) = (n as u8) + b'0';","highlight_start":1,"highlight_end":66},{"text":"                    } else {","highlight_start":1,"highlight_end":29},{"text":"                        let d1 = n << 1;","highlight_start":1,"highlight_end":41},{"text":"                        curr -= 2;","highlight_start":1,"highlight_end":35},{"text":"                        ptr::copy_nonoverlapping(lut_ptr.offset(d1), buf_ptr.offset(curr), 2);","highlight_start":1,"highlight_end":95},{"text":"                    }","highlight_start":1,"highlight_end":22},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                    if !is_nonnegative {","highlight_start":1,"highlight_end":41},{"text":"                        curr -= 1;","highlight_start":1,"highlight_end":35},{"text":"                        *buf_ptr.offset(curr) = b'-';","highlight_start":1,"highlight_end":54},{"text":"                    }","highlight_start":1,"highlight_end":22},{"text":"                }","highlight_start":1,"highlight_end":18},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                let len = buf.len() - curr as usize;","highlight_start":1,"highlight_end":53},{"text":"                let bytes = unsafe { slice::from_raw_parts(buf_ptr.offset(curr), len) };","highlight_start":1,"highlight_end":89},{"text":"                unsafe { str::from_utf8_unchecked(bytes) }","highlight_start":1,"highlight_end":59},{"text":"            }","highlight_start":1,"highlight_end":14},{"text":"        }","highlight_start":1,"highlight_end":10},{"text":"    )*};","highlight_start":1,"highlight_end":9},{"text":"}","highlight_start":1,"highlight_end":2}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}}],"children":[],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0433]\u001b[0m\u001b[0m\u001b[1m\u001b[38;5;15m: failed to resolve: use of undeclared crate or module `slice`\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m--> \u001b[0m\u001b[0mC:\\Users\\ASUS\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\itoa-1.0.1\\src\\lib.rs:181:38\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14m181\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m| \u001b[0m\u001b[0m                let bytes = unsafe { slice::from_raw_parts(buf_ptr.offset(curr), len) };\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m| \u001b[0m\u001b[0m                                     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9muse of undeclared crate or module `slice`\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14m...\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14m212\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m| \u001b[0m\u001b[0mimpl_Integer!(I32_MAX_LEN => isize, U32_MAX_LEN => usize as u32);\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m| \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m----------------------------------------------------------------\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14min this macro invocation\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m= \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;15mnote\u001b[0m\u001b[0m: this error originates in the macro `impl_Integer` (in Nightly builds, run with -Z macro-backtrace for more info)\u001b[0m\n\n"}
{"message":"failed to resolve: use of undeclared crate or module `ptr`","code":{"code":"E0433","explanation":"An undeclared crate, module, or type was used.\n\nErroneous code example:\n\n```compile_fail,E0433\nlet map = HashMap::new();\n// error: failed to resolve: use of undeclared type `HashMap`\n```\n\nPlease verify you didn't misspell the type/module's name or that you didn't\nforget to import it:\n\n```\nuse std::collections::HashMap; // HashMap has been imported.\nlet map: HashMap<u32, u32> = HashMap::new(); // So it can be used!\n```\n\nIf you've expected to use a crate name:\n\n```compile_fail\nuse ferris_wheel::BigO;\n// error: failed to resolve: use of undeclared crate or module `ferris_wheel`\n```\n\nMake sure the crate has been added as a dependency in `Cargo.toml`.\n\nTo use a module from your current crate, add the `crate::` prefix to the path.\n"},"level":"error","spans":[{"file_name":"C:\\Users\\ASUS\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\itoa-1.0.1\\src\\lib.rs","byte_start":9600,"byte_end":9603,"line_start":246,"line_end":246,"column_start":25,"column_end":28,"is_primary":true,"text":[{"text":"                        ptr::write_bytes(buf_ptr.offset(target), b'0', (curr - target) as usize);","highlight_start":25,"highlight_end":28}],"label":"use of undeclared crate or module `ptr`","suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"C:\\Users\\ASUS\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\itoa-1.0.1\\src\\lib.rs","byte_start":11079,"byte_end":11139,"line_start":284,"line_end":284,"column_start":1,"column_end":61,"is_primary":false,"text":[{"text":"impl_Integer128!(I128_MAX_LEN => i128, U128_MAX_LEN => u128);","highlight_start":1,"highlight_end":61}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"impl_Integer128!","def_site_span":{"file_name":"C:\\Users\\ASUS\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\itoa-1.0.1\\src\\lib.rs","byte_start":8297,"byte_end":11012,"line_start":217,"line_end":279,"column_start":1,"column_end":2,"is_primary":false,"text":[{"text":"macro_rules! impl_Integer128 {","highlight_start":1,"highlight_end":31},{"text":"    ($($max_len:expr => $t:ident),*) => {$(","highlight_start":1,"highlight_end":44},{"text":"        impl Integer for $t {}","highlight_start":1,"highlight_end":31},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        impl private::Sealed for $t {","highlight_start":1,"highlight_end":38},{"text":"            type Buffer = [MaybeUninit<u8>; $max_len];","highlight_start":1,"highlight_end":55},{"text":"","highlight_start":1,"highlight_end":1},{"text":"            #[allow(unused_comparisons)]","highlight_start":1,"highlight_end":41},{"text":"            #[inline]","highlight_start":1,"highlight_end":22},{"text":"            fn write(self, buf: &mut [MaybeUninit<u8>; $max_len]) -> &str {","highlight_start":1,"highlight_end":76},{"text":"                let is_nonnegative = self >= 0;","highlight_start":1,"highlight_end":48},{"text":"                let n = if is_nonnegative {","highlight_start":1,"highlight_end":44},{"text":"                    self as u128","highlight_start":1,"highlight_end":33},{"text":"                } else {","highlight_start":1,"highlight_end":25},{"text":"                    // convert the negative num to positive by summing 1 to it's 2 complement","highlight_start":1,"highlight_end":94},{"text":"                    (!(self as u128)).wrapping_add(1)","highlight_start":1,"highlight_end":54},{"text":"                };","highlight_start":1,"highlight_end":19},{"text":"                let mut curr = buf.len() as isize;","highlight_start":1,"highlight_end":51},{"text":"                let buf_ptr = buf.as_mut_ptr() as *mut u8;","highlight_start":1,"highlight_end":59},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                unsafe {","highlight_start":1,"highlight_end":25},{"text":"                    // Divide by 10^19 which is the highest power less than 2^64.","highlight_start":1,"highlight_end":82},{"text":"                    let (n, rem) = udiv128::udivmod_1e19(n);","highlight_start":1,"highlight_end":61},{"text":"                    let buf1 = buf_ptr.offset(curr - U64_MAX_LEN as isize) as *mut [MaybeUninit<u8>; U64_MAX_LEN];","highlight_start":1,"highlight_end":115},{"text":"                    curr -= rem.write(&mut *buf1).len() as isize;","highlight_start":1,"highlight_end":66},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                    if n != 0 {","highlight_start":1,"highlight_end":32},{"text":"                        // Memset the base10 leading zeros of rem.","highlight_start":1,"highlight_end":67},{"text":"                        let target = buf.len() as isize - 19;","highlight_start":1,"highlight_end":62},{"text":"                        ptr::write_bytes(buf_ptr.offset(target), b'0', (curr - target) as usize);","highlight_start":1,"highlight_end":98},{"text":"                        curr = target;","highlight_start":1,"highlight_end":39},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                        // Divide by 10^19 again.","highlight_start":1,"highlight_end":50},{"text":"                        let (n, rem) = udiv128::udivmod_1e19(n);","highlight_start":1,"highlight_end":65},{"text":"                        let buf2 = buf_ptr.offset(curr - U64_MAX_LEN as isize) as *mut [MaybeUninit<u8>; U64_MAX_LEN];","highlight_start":1,"highlight_end":119},{"text":"                        curr -= rem.write(&mut *buf2).len() as isize;","highlight_start":1,"highlight_end":70},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                        if n != 0 {","highlight_start":1,"highlight_end":36},{"text":"                            // Memset the leading zeros.","highlight_start":1,"highlight_end":57},{"text":"                            let target = buf.len() as isize - 38;","highlight_start":1,"highlight_end":66},{"text":"                            ptr::write_bytes(buf_ptr.offset(target), b'0', (curr - target) as usize);","highlight_start":1,"highlight_end":102},{"text":"                            curr = target;","highlight_start":1,"highlight_end":43},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                            // There is at most one digit left","highlight_start":1,"highlight_end":63},{"text":"                            // because u128::max / 10^19 / 10^19 is 3.","highlight_start":1,"highlight_end":71},{"text":"                            curr -= 1;","highlight_start":1,"highlight_end":39},{"text":"                            *buf_ptr.offset(curr) = (n as u8) + b'0';","highlight_start":1,"highlight_end":70},{"text":"                        }","highlight_start":1,"highlight_end":26},{"text":"                    }","highlight_start":1,"highlight_end":22},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                    if !is_nonnegative {","highlight_start":1,"highlight_end":41},{"text":"                        curr -= 1;","highlight_start":1,"highlight_end":35},{"text":"                        *buf_ptr.offset(curr) = b'-';","highlight_start":1,"highlight_end":54},{"text":"                    }","highlight_start":1,"highlight_end":22},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                    let len = buf.len() - curr as usize;","highlight_start":1,"highlight_end":57},{"text":"                    let bytes = slice::from_raw_parts(buf_ptr.offset(curr), len);","highlight_start":1,"highlight_end":82},{"text":"                    str::from_utf8_unchecked(bytes)","highlight_start":1,"highlight_end":52},{"text":"                }","highlight_start":1,"highlight_end":18},{"text":"            }","highlight_start":1,"highlight_end":14},{"text":"        }","highlight_start":1,"highlight_end":10},{"text":"    )*};","highlight_start":1,"highlight_end":9},{"text":"}","highlight_start":1,"highlight_end":2}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}}],"children":[],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0433]\u001b[0m\u001b[0m\u001b[1m\u001b[38;5;15m: failed to resolve: use of undeclared crate or module `ptr`\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m--> \u001b[0m\u001b[0mC:\\Users\\ASUS\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\itoa-1.0.1\\src\\lib.rs:246:25\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14m246\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m| \u001b[0m\u001b[0m                        ptr::write_bytes(buf_ptr.offset(target), b'0', (curr - target) as usize);\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m| \u001b[0m\u001b[0m                        \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9muse of undeclared crate or module `ptr`\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14m...\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14m284\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m| \u001b[0m\u001b[0mimpl_Integer128!(I128_MAX_LEN => i128, U128_MAX_LEN => u128);\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m| \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m------------------------------------------------------------\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14min this macro invocation\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m= \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;15mnote\u001b[0m\u001b[0m: this error originates in the macro `impl_Integer128` (in Nightly builds, run with -Z macro-backtrace for more info)\u001b[0m\n\n"}
{"message":"failed to resolve: use of undeclared crate or module `ptr`","code":{"code":"E0433","explanation":"An undeclared crate, module, or type was used.\n\nErroneous code example:\n\n```compile_fail,E0433\nlet map = HashMap::new();\n// error: failed to resolve: use of undeclared type `HashMap`\n```\n\nPlease verify you didn't misspell the type/module's name or that you didn't\nforget to import it:\n\n```\nuse std::collections::HashMap; // HashMap has been imported.\nlet map: HashMap<u32, u32> = HashMap::new(); // So it can be used!\n```\n\nIf you've expected to use a crate name:\n\n```compile_fail\nuse ferris_wheel::BigO;\n// error: failed to resolve: use of undeclared crate or module `ferris_wheel`\n```\n\nMake sure the crate has been added as a dependency in `Cargo.toml`.\n\nTo use a module from your current crate, add the `crate::` prefix to the path.\n"},"level":"error","spans":[{"file_name":"C:\\Users\\ASUS\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\itoa-1.0.1\\src\\lib.rs","byte_start":10206,"byte_end":10209,"line_start":257,"line_end":257,"column_start":29,"column_end":32,"is_primary":true,"text":[{"text":"                            ptr::write_bytes(buf_ptr.offset(target), b'0', (curr - target) as usize);","highlight_start":29,"highlight_end":32}],"label":"use of undeclared crate or module `ptr`","suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"C:\\Users\\ASUS\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\itoa-1.0.1\\src\\lib.rs","byte_start":11079,"byte_end":11139,"line_start":284,"line_end":284,"column_start":1,"column_end":61,"is_primary":false,"text":[{"text":"impl_Integer128!(I128_MAX_LEN => i128, U128_MAX_LEN => u128);","highlight_start":1,"highlight_end":61}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"impl_Integer128!","def_site_span":{"file_name":"C:\\Users\\ASUS\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\itoa-1.0.1\\src\\lib.rs","byte_start":8297,"byte_end":11012,"line_start":217,"line_end":279,"column_start":1,"column_end":2,"is_primary":false,"text":[{"text":"macro_rules! impl_Integer128 {","highlight_start":1,"highlight_end":31},{"text":"    ($($max_len:expr => $t:ident),*) => {$(","highlight_start":1,"highlight_end":44},{"text":"        impl Integer for $t {}","highlight_start":1,"highlight_end":31},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        impl private::Sealed for $t {","highlight_start":1,"highlight_end":38},{"text":"            type Buffer = [MaybeUninit<u8>; $max_len];","highlight_start":1,"highlight_end":55},{"text":"","highlight_start":1,"highlight_end":1},{"text":"            #[allow(unused_comparisons)]","highlight_start":1,"highlight_end":41},{"text":"            #[inline]","highlight_start":1,"highlight_end":22},{"text":"            fn write(self, buf: &mut [MaybeUninit<u8>; $max_len]) -> &str {","highlight_start":1,"highlight_end":76},{"text":"                let is_nonnegative = self >= 0;","highlight_start":1,"highlight_end":48},{"text":"                let n = if is_nonnegative {","highlight_start":1,"highlight_end":44},{"text":"                    self as u128","highlight_start":1,"highlight_end":33},{"text":"                } else {","highlight_start":1,"highlight_end":25},{"text":"                    // convert the negative num to positive by summing 1 to it's 2 complement","highlight_start":1,"highlight_end":94},{"text":"                    (!(self as u128)).wrapping_add(1)","highlight_start":1,"highlight_end":54},{"text":"                };","highlight_start":1,"highlight_end":19},{"text":"                let mut curr = buf.len() as isize;","highlight_start":1,"highlight_end":51},{"text":"                let buf_ptr = buf.as_mut_ptr() as *mut u8;","highlight_start":1,"highlight_end":59},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                unsafe {","highlight_start":1,"highlight_end":25},{"text":"                    // Divide by 10^19 which is the highest power less than 2^64.","highlight_start":1,"highlight_end":82},{"text":"                    let (n, rem) = udiv128::udivmod_1e19(n);","highlight_start":1,"highlight_end":61},{"text":"                    let buf1 = buf_ptr.offset(curr - U64_MAX_LEN as isize) as *mut [MaybeUninit<u8>; U64_MAX_LEN];","highlight_start":1,"highlight_end":115},{"text":"                    curr -= rem.write(&mut *buf1).len() as isize;","highlight_start":1,"highlight_end":66},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                    if n != 0 {","highlight_start":1,"highlight_end":32},{"text":"                        // Memset the base10 leading zeros of rem.","highlight_start":1,"highlight_end":67},{"text":"                        let target = buf.len() as isize - 19;","highlight_start":1,"highlight_end":62},{"text":"                        ptr::write_bytes(buf_ptr.offset(target), b'0', (curr - target) as usize);","highlight_start":1,"highlight_end":98},{"text":"                        curr = target;","highlight_start":1,"highlight_end":39},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                        // Divide by 10^19 again.","highlight_start":1,"highlight_end":50},{"text":"                        let (n, rem) = udiv128::udivmod_1e19(n);","highlight_start":1,"highlight_end":65},{"text":"                        let buf2 = buf_ptr.offset(curr - U64_MAX_LEN as isize) as *mut [MaybeUninit<u8>; U64_MAX_LEN];","highlight_start":1,"highlight_end":119},{"text":"                        curr -= rem.write(&mut *buf2).len() as isize;","highlight_start":1,"highlight_end":70},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                        if n != 0 {","highlight_start":1,"highlight_end":36},{"text":"                            // Memset the leading zeros.","highlight_start":1,"highlight_end":57},{"text":"                            let target = buf.len() as isize - 38;","highlight_start":1,"highlight_end":66},{"text":"                            ptr::write_bytes(buf_ptr.offset(target), b'0', (curr - target) as usize);","highlight_start":1,"highlight_end":102},{"text":"                            curr = target;","highlight_start":1,"highlight_end":43},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                            // There is at most one digit left","highlight_start":1,"highlight_end":63},{"text":"                            // because u128::max / 10^19 / 10^19 is 3.","highlight_start":1,"highlight_end":71},{"text":"                            curr -= 1;","highlight_start":1,"highlight_end":39},{"text":"                            *buf_ptr.offset(curr) = (n as u8) + b'0';","highlight_start":1,"highlight_end":70},{"text":"                        }","highlight_start":1,"highlight_end":26},{"text":"                    }","highlight_start":1,"highlight_end":22},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                    if !is_nonnegative {","highlight_start":1,"highlight_end":41},{"text":"                        curr -= 1;","highlight_start":1,"highlight_end":35},{"text":"                        *buf_ptr.offset(curr) = b'-';","highlight_start":1,"highlight_end":54},{"text":"                    }","highlight_start":1,"highlight_end":22},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                    let len = buf.len() - curr as usize;","highlight_start":1,"highlight_end":57},{"text":"                    let bytes = slice::from_raw_parts(buf_ptr.offset(curr), len);","highlight_start":1,"highlight_end":82},{"text":"                    str::from_utf8_unchecked(bytes)","highlight_start":1,"highlight_end":52},{"text":"                }","highlight_start":1,"highlight_end":18},{"text":"            }","highlight_start":1,"highlight_end":14},{"text":"        }","highlight_start":1,"highlight_end":10},{"text":"    )*};","highlight_start":1,"highlight_end":9},{"text":"}","highlight_start":1,"highlight_end":2}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}}],"children":[],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0433]\u001b[0m\u001b[0m\u001b[1m\u001b[38;5;15m: failed to resolve: use of undeclared crate or module `ptr`\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m--> \u001b[0m\u001b[0mC:\\Users\\ASUS\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\itoa-1.0.1\\src\\lib.rs:257:29\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14m257\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m| \u001b[0m\u001b[0m                            ptr::write_bytes(buf_ptr.offset(target), b'0', (curr - target) as usize);\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m| \u001b[0m\u001b[0m                            \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9muse of undeclared crate or module `ptr`\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14m...\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14m284\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m| \u001b[0m\u001b[0mimpl_Integer128!(I128_MAX_LEN => i128, U128_MAX_LEN => u128);\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m| \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m------------------------------------------------------------\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14min this macro invocation\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m= \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;15mnote\u001b[0m\u001b[0m: this error originates in the macro `impl_Integer128` (in Nightly builds, run with -Z macro-backtrace for more info)\u001b[0m\n\n"}
{"message":"failed to resolve: use of undeclared crate or module `slice`","code":{"code":"E0433","explanation":"An undeclared crate, module, or type was used.\n\nErroneous code example:\n\n```compile_fail,E0433\nlet map = HashMap::new();\n// error: failed to resolve: use of undeclared type `HashMap`\n```\n\nPlease verify you didn't misspell the type/module's name or that you didn't\nforget to import it:\n\n```\nuse std::collections::HashMap; // HashMap has been imported.\nlet map: HashMap<u32, u32> = HashMap::new(); // So it can be used!\n```\n\nIf you've expected to use a crate name:\n\n```compile_fail\nuse ferris_wheel::BigO;\n// error: failed to resolve: use of undeclared crate or module `ferris_wheel`\n```\n\nMake sure the crate has been added as a dependency in `Cargo.toml`.\n\nTo use a module from your current crate, add the `crate::` prefix to the path.\n"},"level":"error","spans":[{"file_name":"C:\\Users\\ASUS\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\itoa-1.0.1\\src\\lib.rs","byte_start":10858,"byte_end":10863,"line_start":273,"line_end":273,"column_start":33,"column_end":38,"is_primary":true,"text":[{"text":"                    let bytes = slice::from_raw_parts(buf_ptr.offset(curr), len);","highlight_start":33,"highlight_end":38}],"label":"use of undeclared crate or module `slice`","suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"C:\\Users\\ASUS\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\itoa-1.0.1\\src\\lib.rs","byte_start":11079,"byte_end":11139,"line_start":284,"line_end":284,"column_start":1,"column_end":61,"is_primary":false,"text":[{"text":"impl_Integer128!(I128_MAX_LEN => i128, U128_MAX_LEN => u128);","highlight_start":1,"highlight_end":61}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"impl_Integer128!","def_site_span":{"file_name":"C:\\Users\\ASUS\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\itoa-1.0.1\\src\\lib.rs","byte_start":8297,"byte_end":11012,"line_start":217,"line_end":279,"column_start":1,"column_end":2,"is_primary":false,"text":[{"text":"macro_rules! impl_Integer128 {","highlight_start":1,"highlight_end":31},{"text":"    ($($max_len:expr => $t:ident),*) => {$(","highlight_start":1,"highlight_end":44},{"text":"        impl Integer for $t {}","highlight_start":1,"highlight_end":31},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        impl private::Sealed for $t {","highlight_start":1,"highlight_end":38},{"text":"            type Buffer = [MaybeUninit<u8>; $max_len];","highlight_start":1,"highlight_end":55},{"text":"","highlight_start":1,"highlight_end":1},{"text":"            #[allow(unused_comparisons)]","highlight_start":1,"highlight_end":41},{"text":"            #[inline]","highlight_start":1,"highlight_end":22},{"text":"            fn write(self, buf: &mut [MaybeUninit<u8>; $max_len]) -> &str {","highlight_start":1,"highlight_end":76},{"text":"                let is_nonnegative = self >= 0;","highlight_start":1,"highlight_end":48},{"text":"                let n = if is_nonnegative {","highlight_start":1,"highlight_end":44},{"text":"                    self as u128","highlight_start":1,"highlight_end":33},{"text":"                } else {","highlight_start":1,"highlight_end":25},{"text":"                    // convert the negative num to positive by summing 1 to it's 2 complement","highlight_start":1,"highlight_end":94},{"text":"                    (!(self as u128)).wrapping_add(1)","highlight_start":1,"highlight_end":54},{"text":"                };","highlight_start":1,"highlight_end":19},{"text":"                let mut curr = buf.len() as isize;","highlight_start":1,"highlight_end":51},{"text":"                let buf_ptr = buf.as_mut_ptr() as *mut u8;","highlight_start":1,"highlight_end":59},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                unsafe {","highlight_start":1,"highlight_end":25},{"text":"                    // Divide by 10^19 which is the highest power less than 2^64.","highlight_start":1,"highlight_end":82},{"text":"                    let (n, rem) = udiv128::udivmod_1e19(n);","highlight_start":1,"highlight_end":61},{"text":"                    let buf1 = buf_ptr.offset(curr - U64_MAX_LEN as isize) as *mut [MaybeUninit<u8>; U64_MAX_LEN];","highlight_start":1,"highlight_end":115},{"text":"                    curr -= rem.write(&mut *buf1).len() as isize;","highlight_start":1,"highlight_end":66},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                    if n != 0 {","highlight_start":1,"highlight_end":32},{"text":"                        // Memset the base10 leading zeros of rem.","highlight_start":1,"highlight_end":67},{"text":"                        let target = buf.len() as isize - 19;","highlight_start":1,"highlight_end":62},{"text":"                        ptr::write_bytes(buf_ptr.offset(target), b'0', (curr - target) as usize);","highlight_start":1,"highlight_end":98},{"text":"                        curr = target;","highlight_start":1,"highlight_end":39},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                        // Divide by 10^19 again.","highlight_start":1,"highlight_end":50},{"text":"                        let (n, rem) = udiv128::udivmod_1e19(n);","highlight_start":1,"highlight_end":65},{"text":"                        let buf2 = buf_ptr.offset(curr - U64_MAX_LEN as isize) as *mut [MaybeUninit<u8>; U64_MAX_LEN];","highlight_start":1,"highlight_end":119},{"text":"                        curr -= rem.write(&mut *buf2).len() as isize;","highlight_start":1,"highlight_end":70},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                        if n != 0 {","highlight_start":1,"highlight_end":36},{"text":"                            // Memset the leading zeros.","highlight_start":1,"highlight_end":57},{"text":"                            let target = buf.len() as isize - 38;","highlight_start":1,"highlight_end":66},{"text":"                            ptr::write_bytes(buf_ptr.offset(target), b'0', (curr - target) as usize);","highlight_start":1,"highlight_end":102},{"text":"                            curr = target;","highlight_start":1,"highlight_end":43},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                            // There is at most one digit left","highlight_start":1,"highlight_end":63},{"text":"                            // because u128::max / 10^19 / 10^19 is 3.","highlight_start":1,"highlight_end":71},{"text":"                            curr -= 1;","highlight_start":1,"highlight_end":39},{"text":"                            *buf_ptr.offset(curr) = (n as u8) + b'0';","highlight_start":1,"highlight_end":70},{"text":"                        }","highlight_start":1,"highlight_end":26},{"text":"                    }","highlight_start":1,"highlight_end":22},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                    if !is_nonnegative {","highlight_start":1,"highlight_end":41},{"text":"                        curr -= 1;","highlight_start":1,"highlight_end":35},{"text":"                        *buf_ptr.offset(curr) = b'-';","highlight_start":1,"highlight_end":54},{"text":"                    }","highlight_start":1,"highlight_end":22},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                    let len = buf.len() - curr as usize;","highlight_start":1,"highlight_end":57},{"text":"                    let bytes = slice::from_raw_parts(buf_ptr.offset(curr), len);","highlight_start":1,"highlight_end":82},{"text":"                    str::from_utf8_unchecked(bytes)","highlight_start":1,"highlight_end":52},{"text":"                }","highlight_start":1,"highlight_end":18},{"text":"            }","highlight_start":1,"highlight_end":14},{"text":"        }","highlight_start":1,"highlight_end":10},{"text":"    )*};","highlight_start":1,"highlight_end":9},{"text":"}","highlight_start":1,"highlight_end":2}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}}],"children":[],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0433]\u001b[0m\u001b[0m\u001b[1m\u001b[38;5;15m: failed to resolve: use of undeclared crate or module `slice`\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m--> \u001b[0m\u001b[0mC:\\Users\\ASUS\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\itoa-1.0.1\\src\\lib.rs:273:33\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14m273\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m| \u001b[0m\u001b[0m                    let bytes = slice::from_raw_parts(buf_ptr.offset(curr), len);\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m| \u001b[0m\u001b[0m                                \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9muse of undeclared crate or module `slice`\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14m...\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14m284\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m| \u001b[0m\u001b[0mimpl_Integer128!(I128_MAX_LEN => i128, U128_MAX_LEN => u128);\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m| \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m------------------------------------------------------------\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14min this macro invocation\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m= \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;15mnote\u001b[0m\u001b[0m: this error originates in the macro `impl_Integer128` (in Nightly builds, run with -Z macro-backtrace for more info)\u001b[0m\n\n"}
{"message":"cannot find type `MaybeUninit` in this scope","code":{"code":"E0412","explanation":"A used type name is not in scope.\n\nErroneous code examples:\n\n```compile_fail,E0412\nimpl Something {} // error: type name `Something` is not in scope\n\n// or:\n\ntrait Foo {\n    fn bar(N); // error: type name `N` is not in scope\n}\n\n// or:\n\nfn foo(x: T) {} // type name `T` is not in scope\n```\n\nTo fix this error, please verify you didn't misspell the type name, you did\ndeclare it or imported it into the scope. Examples:\n\n```\nstruct Something;\n\nimpl Something {} // ok!\n\n// or:\n\ntrait Foo {\n    type N;\n\n    fn bar(_: Self::N); // ok!\n}\n\n// or:\n\nfn foo<T>(x: T) {} // ok!\n```\n\nAnother case that causes this error is when a type is imported into a parent\nmodule. To fix this, you can follow the suggestion and use File directly or\n`use super::File;` which will import the types from the parent namespace. An\nexample that causes this error is below:\n\n```compile_fail,E0412\nuse std::fs::File;\n\nmod foo {\n    fn some_function(f: File) {}\n}\n```\n\n```\nuse std::fs::File;\n\nmod foo {\n    // either\n    use super::File;\n    // or\n    // use std::fs::File;\n    fn foo(f: File) {}\n}\n# fn main() {} // don't insert it for us; that'll break imports\n```\n"},"level":"error","spans":[{"file_name":"C:\\Users\\ASUS\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\itoa-1.0.1\\src\\lib.rs","byte_start":2912,"byte_end":2923,"line_start":58,"line_end":58,"column_start":13,"column_end":24,"is_primary":true,"text":[{"text":"    bytes: [MaybeUninit<u8>; I128_MAX_LEN],","highlight_start":13,"highlight_end":24}],"label":"not found in this scope","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0412]\u001b[0m\u001b[0m\u001b[1m\u001b[38;5;15m: cannot find type `MaybeUninit` in this scope\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m--> \u001b[0m\u001b[0mC:\\Users\\ASUS\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\itoa-1.0.1\\src\\lib.rs:58:13\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14m58\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m| \u001b[0m\u001b[0m    bytes: [MaybeUninit<u8>; I128_MAX_LEN],\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m| \u001b[0m\u001b[0m            \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9mnot found in this scope\u001b[0m\n\n"}
{"message":"cannot find trait `Default` in this scope","code":{"code":"E0405","explanation":"The code refers to a trait that is not in scope.\n\nErroneous code example:\n\n```compile_fail,E0405\nstruct Foo;\n\nimpl SomeTrait for Foo {} // error: trait `SomeTrait` is not in scope\n```\n\nPlease verify that the name of the trait wasn't misspelled and ensure that it\nwas imported. Example:\n\n```\n# #[cfg(for_demonstration_only)]\n// solution 1:\nuse some_file::SomeTrait;\n\n// solution 2:\ntrait SomeTrait {\n    // some functions\n}\n\nstruct Foo;\n\nimpl SomeTrait for Foo { // ok!\n    // implements functions\n}\n```\n"},"level":"error","spans":[{"file_name":"C:\\Users\\ASUS\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\itoa-1.0.1\\src\\lib.rs","byte_start":2952,"byte_end":2959,"line_start":61,"line_end":61,"column_start":6,"column_end":13,"is_primary":true,"text":[{"text":"impl Default for Buffer {","highlight_start":6,"highlight_end":13}],"label":"not found in this scope","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0405]\u001b[0m\u001b[0m\u001b[1m\u001b[38;5;15m: cannot find trait `Default` in this scope\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m--> \u001b[0m\u001b[0mC:\\Users\\ASUS\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\itoa-1.0.1\\src\\lib.rs:61:6\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14m61\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m| \u001b[0m\u001b[0mimpl Default for Buffer {\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m| \u001b[0m\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9mnot found in this scope\u001b[0m\n\n"}
{"message":"cannot find trait `Clone` in this scope","code":{"code":"E0405","explanation":"The code refers to a trait that is not in scope.\n\nErroneous code example:\n\n```compile_fail,E0405\nstruct Foo;\n\nimpl SomeTrait for Foo {} // error: trait `SomeTrait` is not in scope\n```\n\nPlease verify that the name of the trait wasn't misspelled and ensure that it\nwas imported. Example:\n\n```\n# #[cfg(for_demonstration_only)]\n// solution 1:\nuse some_file::SomeTrait;\n\n// solution 2:\ntrait SomeTrait {\n    // some functions\n}\n\nstruct Foo;\n\nimpl SomeTrait for Foo { // ok!\n    // implements functions\n}\n```\n"},"level":"error","spans":[{"file_name":"C:\\Users\\ASUS\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\itoa-1.0.1\\src\\lib.rs","byte_start":3052,"byte_end":3057,"line_start":68,"line_end":68,"column_start":6,"column_end":11,"is_primary":true,"text":[{"text":"impl Clone for Buffer {","highlight_start":6,"highlight_end":11}],"label":"not found in this scope","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0405]\u001b[0m\u001b[0m\u001b[1m\u001b[38;5;15m: cannot find trait `Clone` in this scope\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m--> \u001b[0m\u001b[0mC:\\Users\\ASUS\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\itoa-1.0.1\\src\\lib.rs:68:6\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14m68\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m| \u001b[0m\u001b[0mimpl Clone for Buffer {\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m| \u001b[0m\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9mnot found in this scope\u001b[0m\n\n"}
{"message":"cannot find type `MaybeUninit` in this scope","code":{"code":"E0412","explanation":"A used type name is not in scope.\n\nErroneous code examples:\n\n```compile_fail,E0412\nimpl Something {} // error: type name `Something` is not in scope\n\n// or:\n\ntrait Foo {\n    fn bar(N); // error: type name `N` is not in scope\n}\n\n// or:\n\nfn foo(x: T) {} // type name `T` is not in scope\n```\n\nTo fix this error, please verify you didn't misspell the type name, you did\ndeclare it or imported it into the scope. Examples:\n\n```\nstruct Something;\n\nimpl Something {} // ok!\n\n// or:\n\ntrait Foo {\n    type N;\n\n    fn bar(_: Self::N); // ok!\n}\n\n// or:\n\nfn foo<T>(x: T) {} // ok!\n```\n\nAnother case that causes this error is when a type is imported into a parent\nmodule. To fix this, you can follow the suggestion and use File directly or\n`use super::File;` which will import the types from the parent namespace. An\nexample that causes this error is below:\n\n```compile_fail,E0412\nuse std::fs::File;\n\nmod foo {\n    fn some_function(f: File) {}\n}\n```\n\n```\nuse std::fs::File;\n\nmod foo {\n    // either\n    use super::File;\n    // or\n    // use std::fs::File;\n    fn foo(f: File) {}\n}\n# fn main() {} // don't insert it for us; that'll break imports\n```\n"},"level":"error","spans":[{"file_name":"C:\\Users\\ASUS\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\itoa-1.0.1\\src\\lib.rs","byte_start":3652,"byte_end":3663,"line_start":88,"line_end":88,"column_start":45,"column_end":56,"is_primary":true,"text":[{"text":"            &mut *(&mut self.bytes as *mut [MaybeUninit<u8>; I128_MAX_LEN]","highlight_start":45,"highlight_end":56}],"label":"not found in this scope","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0412]\u001b[0m\u001b[0m\u001b[1m\u001b[38;5;15m: cannot find type `MaybeUninit` in this scope\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m--> \u001b[0m\u001b[0mC:\\Users\\ASUS\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\itoa-1.0.1\\src\\lib.rs:88:45\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14m88\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m| \u001b[0m\u001b[0m            &mut *(&mut self.bytes as *mut [MaybeUninit<u8>; I128_MAX_LEN]\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m| \u001b[0m\u001b[0m                                            \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9mnot found in this scope\u001b[0m\n\n"}
{"message":"cannot find trait `Copy` in this scope","code":{"code":"E0405","explanation":"The code refers to a trait that is not in scope.\n\nErroneous code example:\n\n```compile_fail,E0405\nstruct Foo;\n\nimpl SomeTrait for Foo {} // error: trait `SomeTrait` is not in scope\n```\n\nPlease verify that the name of the trait wasn't misspelled and ensure that it\nwas imported. Example:\n\n```\n# #[cfg(for_demonstration_only)]\n// solution 1:\nuse some_file::SomeTrait;\n\n// solution 2:\ntrait SomeTrait {\n    // some functions\n}\n\nstruct Foo;\n\nimpl SomeTrait for Foo { // ok!\n    // implements functions\n}\n```\n"},"level":"error","spans":[{"file_name":"C:\\Users\\ASUS\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\itoa-1.0.1\\src\\lib.rs","byte_start":4053,"byte_end":4057,"line_start":101,"line_end":101,"column_start":23,"column_end":27,"is_primary":true,"text":[{"text":"    pub trait Sealed: Copy {","highlight_start":23,"highlight_end":27}],"label":"not found in this scope","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0405]\u001b[0m\u001b[0m\u001b[1m\u001b[38;5;15m: cannot find trait `Copy` in this scope\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m--> \u001b[0m\u001b[0mC:\\Users\\ASUS\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\itoa-1.0.1\\src\\lib.rs:101:23\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14m101\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m| \u001b[0m\u001b[0m    pub trait Sealed: Copy {\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m| \u001b[0m\u001b[0m                      \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9mnot found in this scope\u001b[0m\n\n"}
{"message":"cannot find type `MaybeUninit` in this scope","code":{"code":"E0412","explanation":"A used type name is not in scope.\n\nErroneous code examples:\n\n```compile_fail,E0412\nimpl Something {} // error: type name `Something` is not in scope\n\n// or:\n\ntrait Foo {\n    fn bar(N); // error: type name `N` is not in scope\n}\n\n// or:\n\nfn foo(x: T) {} // type name `T` is not in scope\n```\n\nTo fix this error, please verify you didn't misspell the type name, you did\ndeclare it or imported it into the scope. Examples:\n\n```\nstruct Something;\n\nimpl Something {} // ok!\n\n// or:\n\ntrait Foo {\n    type N;\n\n    fn bar(_: Self::N); // ok!\n}\n\n// or:\n\nfn foo<T>(x: T) {} // ok!\n```\n\nAnother case that causes this error is when a type is imported into a parent\nmodule. To fix this, you can follow the suggestion and use File directly or\n`use super::File;` which will import the types from the parent namespace. An\nexample that causes this error is below:\n\n```compile_fail,E0412\nuse std::fs::File;\n\nmod foo {\n    fn some_function(f: File) {}\n}\n```\n\n```\nuse std::fs::File;\n\nmod foo {\n    // either\n    use super::File;\n    // or\n    // use std::fs::File;\n    fn foo(f: File) {}\n}\n# fn main() {} // don't insert it for us; that'll break imports\n```\n"},"level":"error","spans":[{"file_name":"C:\\Users\\ASUS\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\itoa-1.0.1\\src\\lib.rs","byte_start":4782,"byte_end":4793,"line_start":121,"line_end":121,"column_start":28,"column_end":39,"is_primary":true,"text":[{"text":"            type Buffer = [MaybeUninit<u8>; $max_len];","highlight_start":28,"highlight_end":39}],"label":"not found in this scope","suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"C:\\Users\\ASUS\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\itoa-1.0.1\\src\\lib.rs","byte_start":7757,"byte_end":7922,"line_start":197,"line_end":204,"column_start":1,"column_end":12,"is_primary":false,"text":[{"text":"impl_Integer!(","highlight_start":1,"highlight_end":15},{"text":"    I8_MAX_LEN => i8,","highlight_start":1,"highlight_end":22},{"text":"    U8_MAX_LEN => u8,","highlight_start":1,"highlight_end":22},{"text":"    I16_MAX_LEN => i16,","highlight_start":1,"highlight_end":24},{"text":"    U16_MAX_LEN => u16,","highlight_start":1,"highlight_end":24},{"text":"    I32_MAX_LEN => i32,","highlight_start":1,"highlight_end":24},{"text":"    U32_MAX_LEN => u32","highlight_start":1,"highlight_end":23},{"text":"    as u32);","highlight_start":1,"highlight_end":12}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"impl_Integer!","def_site_span":{"file_name":"C:\\Users\\ASUS\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\itoa-1.0.1\\src\\lib.rs","byte_start":4595,"byte_end":7512,"line_start":116,"line_end":186,"column_start":1,"column_end":2,"is_primary":false,"text":[{"text":"macro_rules! impl_Integer {","highlight_start":1,"highlight_end":28},{"text":"    ($($max_len:expr => $t:ident),* as $conv_fn:ident) => {$(","highlight_start":1,"highlight_end":62},{"text":"        impl Integer for $t {}","highlight_start":1,"highlight_end":31},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        impl private::Sealed for $t {","highlight_start":1,"highlight_end":38},{"text":"            type Buffer = [MaybeUninit<u8>; $max_len];","highlight_start":1,"highlight_end":55},{"text":"","highlight_start":1,"highlight_end":1},{"text":"            #[allow(unused_comparisons)]","highlight_start":1,"highlight_end":41},{"text":"            #[inline]","highlight_start":1,"highlight_end":22},{"text":"            fn write(self, buf: &mut [MaybeUninit<u8>; $max_len]) -> &str {","highlight_start":1,"highlight_end":76},{"text":"                let is_nonnegative = self >= 0;","highlight_start":1,"highlight_end":48},{"text":"                let mut n = if is_nonnegative {","highlight_start":1,"highlight_end":48},{"text":"                    self as $conv_fn","highlight_start":1,"highlight_end":37},{"text":"                } else {","highlight_start":1,"highlight_end":25},{"text":"                    // convert the negative num to positive by summing 1 to it's 2 complement","highlight_start":1,"highlight_end":94},{"text":"                    (!(self as $conv_fn)).wrapping_add(1)","highlight_start":1,"highlight_end":58},{"text":"                };","highlight_start":1,"highlight_end":19},{"text":"                let mut curr = buf.len() as isize;","highlight_start":1,"highlight_end":51},{"text":"                let buf_ptr = buf.as_mut_ptr() as *mut u8;","highlight_start":1,"highlight_end":59},{"text":"                let lut_ptr = DEC_DIGITS_LUT.as_ptr();","highlight_start":1,"highlight_end":55},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                unsafe {","highlight_start":1,"highlight_end":25},{"text":"                    // need at least 16 bits for the 4-characters-at-a-time to work.","highlight_start":1,"highlight_end":85},{"text":"                    if mem::size_of::<$t>() >= 2 {","highlight_start":1,"highlight_end":51},{"text":"                        // eagerly decode 4 characters at a time","highlight_start":1,"highlight_end":65},{"text":"                        while n >= 10000 {","highlight_start":1,"highlight_end":43},{"text":"                            let rem = (n % 10000) as isize;","highlight_start":1,"highlight_end":60},{"text":"                            n /= 10000;","highlight_start":1,"highlight_end":40},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                            let d1 = (rem / 100) << 1;","highlight_start":1,"highlight_end":55},{"text":"                            let d2 = (rem % 100) << 1;","highlight_start":1,"highlight_end":55},{"text":"                            curr -= 4;","highlight_start":1,"highlight_end":39},{"text":"                            ptr::copy_nonoverlapping(lut_ptr.offset(d1), buf_ptr.offset(curr), 2);","highlight_start":1,"highlight_end":99},{"text":"                            ptr::copy_nonoverlapping(lut_ptr.offset(d2), buf_ptr.offset(curr + 2), 2);","highlight_start":1,"highlight_end":103},{"text":"                        }","highlight_start":1,"highlight_end":26},{"text":"                    }","highlight_start":1,"highlight_end":22},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                    // if we reach here numbers are <= 9999, so at most 4 chars long","highlight_start":1,"highlight_end":85},{"text":"                    let mut n = n as isize; // possibly reduce 64bit math","highlight_start":1,"highlight_end":74},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                    // decode 2 more chars, if > 2 chars","highlight_start":1,"highlight_end":57},{"text":"                    if n >= 100 {","highlight_start":1,"highlight_end":34},{"text":"                        let d1 = (n % 100) << 1;","highlight_start":1,"highlight_end":49},{"text":"                        n /= 100;","highlight_start":1,"highlight_end":34},{"text":"                        curr -= 2;","highlight_start":1,"highlight_end":35},{"text":"                        ptr::copy_nonoverlapping(lut_ptr.offset(d1), buf_ptr.offset(curr), 2);","highlight_start":1,"highlight_end":95},{"text":"                    }","highlight_start":1,"highlight_end":22},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                    // decode last 1 or 2 chars","highlight_start":1,"highlight_end":48},{"text":"                    if n < 10 {","highlight_start":1,"highlight_end":32},{"text":"                        curr -= 1;","highlight_start":1,"highlight_end":35},{"text":"                        *buf_ptr.offset(curr) = (n as u8) + b'0';","highlight_start":1,"highlight_end":66},{"text":"                    } else {","highlight_start":1,"highlight_end":29},{"text":"                        let d1 = n << 1;","highlight_start":1,"highlight_end":41},{"text":"                        curr -= 2;","highlight_start":1,"highlight_end":35},{"text":"                        ptr::copy_nonoverlapping(lut_ptr.offset(d1), buf_ptr.offset(curr), 2);","highlight_start":1,"highlight_end":95},{"text":"                    }","highlight_start":1,"highlight_end":22},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                    if !is_nonnegative {","highlight_start":1,"highlight_end":41},{"text":"                        curr -= 1;","highlight_start":1,"highlight_end":35},{"text":"                        *buf_ptr.offset(curr) = b'-';","highlight_start":1,"highlight_end":54},{"text":"                    }","highlight_start":1,"highlight_end":22},{"text":"                }","highlight_start":1,"highlight_end":18},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                let len = buf.len() - curr as usize;","highlight_start":1,"highlight_end":53},{"text":"                let bytes = unsafe { slice::from_raw_parts(buf_ptr.offset(curr), len) };","highlight_start":1,"highlight_end":89},{"text":"                unsafe { str::from_utf8_unchecked(bytes) }","highlight_start":1,"highlight_end":59},{"text":"            }","highlight_start":1,"highlight_end":14},{"text":"        }","highlight_start":1,"highlight_end":10},{"text":"    )*};","highlight_start":1,"highlight_end":9},{"text":"}","highlight_start":1,"highlight_end":2}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}}],"children":[],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0412]\u001b[0m\u001b[0m\u001b[1m\u001b[38;5;15m: cannot find type `MaybeUninit` in this scope\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m--> \u001b[0m\u001b[0mC:\\Users\\ASUS\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\itoa-1.0.1\\src\\lib.rs:121:28\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14m121\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m| \u001b[0m\u001b[0m  \u001b[0m\u001b[0m            type Buffer = [MaybeUninit<u8>; $max_len];\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m| \u001b[0m\u001b[0m                             \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9mnot found in this scope\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14m...\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14m197\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m| \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m/\u001b[0m\u001b[0m \u001b[0m\u001b[0mimpl_Integer!(\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14m198\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m| \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    I8_MAX_LEN => i8,\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14m199\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m| \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    U8_MAX_LEN => u8,\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14m200\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m| \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    I16_MAX_LEN => i16,\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14m...\u001b[0m\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14m203\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m| \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    U32_MAX_LEN => u32\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14m204\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m| \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    as u32);\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m| \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|___________-\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14min this macro invocation\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m= \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;15mnote\u001b[0m\u001b[0m: this error originates in the macro `impl_Integer` (in Nightly builds, run with -Z macro-backtrace for more info)\u001b[0m\n\n"}
{"message":"cannot find type `MaybeUninit` in this scope","code":{"code":"E0412","explanation":"A used type name is not in scope.\n\nErroneous code examples:\n\n```compile_fail,E0412\nimpl Something {} // error: type name `Something` is not in scope\n\n// or:\n\ntrait Foo {\n    fn bar(N); // error: type name `N` is not in scope\n}\n\n// or:\n\nfn foo(x: T) {} // type name `T` is not in scope\n```\n\nTo fix this error, please verify you didn't misspell the type name, you did\ndeclare it or imported it into the scope. Examples:\n\n```\nstruct Something;\n\nimpl Something {} // ok!\n\n// or:\n\ntrait Foo {\n    type N;\n\n    fn bar(_: Self::N); // ok!\n}\n\n// or:\n\nfn foo<T>(x: T) {} // ok!\n```\n\nAnother case that causes this error is when a type is imported into a parent\nmodule. To fix this, you can follow the suggestion and use File directly or\n`use super::File;` which will import the types from the parent namespace. An\nexample that causes this error is below:\n\n```compile_fail,E0412\nuse std::fs::File;\n\nmod foo {\n    fn some_function(f: File) {}\n}\n```\n\n```\nuse std::fs::File;\n\nmod foo {\n    // either\n    use super::File;\n    // or\n    // use std::fs::File;\n    fn foo(f: File) {}\n}\n# fn main() {} // don't insert it for us; that'll break imports\n```\n"},"level":"error","spans":[{"file_name":"C:\\Users\\ASUS\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\itoa-1.0.1\\src\\lib.rs","byte_start":4912,"byte_end":4923,"line_start":125,"line_end":125,"column_start":39,"column_end":50,"is_primary":true,"text":[{"text":"            fn write(self, buf: &mut [MaybeUninit<u8>; $max_len]) -> &str {","highlight_start":39,"highlight_end":50}],"label":"not found in this scope","suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"C:\\Users\\ASUS\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\itoa-1.0.1\\src\\lib.rs","byte_start":7757,"byte_end":7922,"line_start":197,"line_end":204,"column_start":1,"column_end":12,"is_primary":false,"text":[{"text":"impl_Integer!(","highlight_start":1,"highlight_end":15},{"text":"    I8_MAX_LEN => i8,","highlight_start":1,"highlight_end":22},{"text":"    U8_MAX_LEN => u8,","highlight_start":1,"highlight_end":22},{"text":"    I16_MAX_LEN => i16,","highlight_start":1,"highlight_end":24},{"text":"    U16_MAX_LEN => u16,","highlight_start":1,"highlight_end":24},{"text":"    I32_MAX_LEN => i32,","highlight_start":1,"highlight_end":24},{"text":"    U32_MAX_LEN => u32","highlight_start":1,"highlight_end":23},{"text":"    as u32);","highlight_start":1,"highlight_end":12}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"impl_Integer!","def_site_span":{"file_name":"C:\\Users\\ASUS\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\itoa-1.0.1\\src\\lib.rs","byte_start":4595,"byte_end":7512,"line_start":116,"line_end":186,"column_start":1,"column_end":2,"is_primary":false,"text":[{"text":"macro_rules! impl_Integer {","highlight_start":1,"highlight_end":28},{"text":"    ($($max_len:expr => $t:ident),* as $conv_fn:ident) => {$(","highlight_start":1,"highlight_end":62},{"text":"        impl Integer for $t {}","highlight_start":1,"highlight_end":31},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        impl private::Sealed for $t {","highlight_start":1,"highlight_end":38},{"text":"            type Buffer = [MaybeUninit<u8>; $max_len];","highlight_start":1,"highlight_end":55},{"text":"","highlight_start":1,"highlight_end":1},{"text":"            #[allow(unused_comparisons)]","highlight_start":1,"highlight_end":41},{"text":"            #[inline]","highlight_start":1,"highlight_end":22},{"text":"            fn write(self, buf: &mut [MaybeUninit<u8>; $max_len]) -> &str {","highlight_start":1,"highlight_end":76},{"text":"                let is_nonnegative = self >= 0;","highlight_start":1,"highlight_end":48},{"text":"                let mut n = if is_nonnegative {","highlight_start":1,"highlight_end":48},{"text":"                    self as $conv_fn","highlight_start":1,"highlight_end":37},{"text":"                } else {","highlight_start":1,"highlight_end":25},{"text":"                    // convert the negative num to positive by summing 1 to it's 2 complement","highlight_start":1,"highlight_end":94},{"text":"                    (!(self as $conv_fn)).wrapping_add(1)","highlight_start":1,"highlight_end":58},{"text":"                };","highlight_start":1,"highlight_end":19},{"text":"                let mut curr = buf.len() as isize;","highlight_start":1,"highlight_end":51},{"text":"                let buf_ptr = buf.as_mut_ptr() as *mut u8;","highlight_start":1,"highlight_end":59},{"text":"                let lut_ptr = DEC_DIGITS_LUT.as_ptr();","highlight_start":1,"highlight_end":55},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                unsafe {","highlight_start":1,"highlight_end":25},{"text":"                    // need at least 16 bits for the 4-characters-at-a-time to work.","highlight_start":1,"highlight_end":85},{"text":"                    if mem::size_of::<$t>() >= 2 {","highlight_start":1,"highlight_end":51},{"text":"                        // eagerly decode 4 characters at a time","highlight_start":1,"highlight_end":65},{"text":"                        while n >= 10000 {","highlight_start":1,"highlight_end":43},{"text":"                            let rem = (n % 10000) as isize;","highlight_start":1,"highlight_end":60},{"text":"                            n /= 10000;","highlight_start":1,"highlight_end":40},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                            let d1 = (rem / 100) << 1;","highlight_start":1,"highlight_end":55},{"text":"                            let d2 = (rem % 100) << 1;","highlight_start":1,"highlight_end":55},{"text":"                            curr -= 4;","highlight_start":1,"highlight_end":39},{"text":"                            ptr::copy_nonoverlapping(lut_ptr.offset(d1), buf_ptr.offset(curr), 2);","highlight_start":1,"highlight_end":99},{"text":"                            ptr::copy_nonoverlapping(lut_ptr.offset(d2), buf_ptr.offset(curr + 2), 2);","highlight_start":1,"highlight_end":103},{"text":"                        }","highlight_start":1,"highlight_end":26},{"text":"                    }","highlight_start":1,"highlight_end":22},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                    // if we reach here numbers are <= 9999, so at most 4 chars long","highlight_start":1,"highlight_end":85},{"text":"                    let mut n = n as isize; // possibly reduce 64bit math","highlight_start":1,"highlight_end":74},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                    // decode 2 more chars, if > 2 chars","highlight_start":1,"highlight_end":57},{"text":"                    if n >= 100 {","highlight_start":1,"highlight_end":34},{"text":"                        let d1 = (n % 100) << 1;","highlight_start":1,"highlight_end":49},{"text":"                        n /= 100;","highlight_start":1,"highlight_end":34},{"text":"                        curr -= 2;","highlight_start":1,"highlight_end":35},{"text":"                        ptr::copy_nonoverlapping(lut_ptr.offset(d1), buf_ptr.offset(curr), 2);","highlight_start":1,"highlight_end":95},{"text":"                    }","highlight_start":1,"highlight_end":22},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                    // decode last 1 or 2 chars","highlight_start":1,"highlight_end":48},{"text":"                    if n < 10 {","highlight_start":1,"highlight_end":32},{"text":"                        curr -= 1;","highlight_start":1,"highlight_end":35},{"text":"                        *buf_ptr.offset(curr) = (n as u8) + b'0';","highlight_start":1,"highlight_end":66},{"text":"                    } else {","highlight_start":1,"highlight_end":29},{"text":"                        let d1 = n << 1;","highlight_start":1,"highlight_end":41},{"text":"                        curr -= 2;","highlight_start":1,"highlight_end":35},{"text":"                        ptr::copy_nonoverlapping(lut_ptr.offset(d1), buf_ptr.offset(curr), 2);","highlight_start":1,"highlight_end":95},{"text":"                    }","highlight_start":1,"highlight_end":22},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                    if !is_nonnegative {","highlight_start":1,"highlight_end":41},{"text":"                        curr -= 1;","highlight_start":1,"highlight_end":35},{"text":"                        *buf_ptr.offset(curr) = b'-';","highlight_start":1,"highlight_end":54},{"text":"                    }","highlight_start":1,"highlight_end":22},{"text":"                }","highlight_start":1,"highlight_end":18},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                let len = buf.len() - curr as usize;","highlight_start":1,"highlight_end":53},{"text":"                let bytes = unsafe { slice::from_raw_parts(buf_ptr.offset(curr), len) };","highlight_start":1,"highlight_end":89},{"text":"                unsafe { str::from_utf8_unchecked(bytes) }","highlight_start":1,"highlight_end":59},{"text":"            }","highlight_start":1,"highlight_end":14},{"text":"        }","highlight_start":1,"highlight_end":10},{"text":"    )*};","highlight_start":1,"highlight_end":9},{"text":"}","highlight_start":1,"highlight_end":2}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}}],"children":[],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0412]\u001b[0m\u001b[0m\u001b[1m\u001b[38;5;15m: cannot find type `MaybeUninit` in this scope\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m--> \u001b[0m\u001b[0mC:\\Users\\ASUS\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\itoa-1.0.1\\src\\lib.rs:125:39\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14m125\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m| \u001b[0m\u001b[0m  \u001b[0m\u001b[0m            fn write(self, buf: &mut [MaybeUninit<u8>; $max_len]) -> &str {\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m| \u001b[0m\u001b[0m                                        \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9mnot found in this scope\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14m...\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14m197\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m| \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m/\u001b[0m\u001b[0m \u001b[0m\u001b[0mimpl_Integer!(\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14m198\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m| \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    I8_MAX_LEN => i8,\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14m199\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m| \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    U8_MAX_LEN => u8,\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14m200\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m| \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    I16_MAX_LEN => i16,\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14m...\u001b[0m\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14m203\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m| \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    U32_MAX_LEN => u32\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14m204\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m| \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    as u32);\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m| \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|___________-\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14min this macro invocation\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m= \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;15mnote\u001b[0m\u001b[0m: this error originates in the macro `impl_Integer` (in Nightly builds, run with -Z macro-backtrace for more info)\u001b[0m\n\n"}
{"message":"cannot find type `MaybeUninit` in this scope","code":{"code":"E0412","explanation":"A used type name is not in scope.\n\nErroneous code examples:\n\n```compile_fail,E0412\nimpl Something {} // error: type name `Something` is not in scope\n\n// or:\n\ntrait Foo {\n    fn bar(N); // error: type name `N` is not in scope\n}\n\n// or:\n\nfn foo(x: T) {} // type name `T` is not in scope\n```\n\nTo fix this error, please verify you didn't misspell the type name, you did\ndeclare it or imported it into the scope. Examples:\n\n```\nstruct Something;\n\nimpl Something {} // ok!\n\n// or:\n\ntrait Foo {\n    type N;\n\n    fn bar(_: Self::N); // ok!\n}\n\n// or:\n\nfn foo<T>(x: T) {} // ok!\n```\n\nAnother case that causes this error is when a type is imported into a parent\nmodule. To fix this, you can follow the suggestion and use File directly or\n`use super::File;` which will import the types from the parent namespace. An\nexample that causes this error is below:\n\n```compile_fail,E0412\nuse std::fs::File;\n\nmod foo {\n    fn some_function(f: File) {}\n}\n```\n\n```\nuse std::fs::File;\n\nmod foo {\n    // either\n    use super::File;\n    // or\n    // use std::fs::File;\n    fn foo(f: File) {}\n}\n# fn main() {} // don't insert it for us; that'll break imports\n```\n"},"level":"error","spans":[{"file_name":"C:\\Users\\ASUS\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\itoa-1.0.1\\src\\lib.rs","byte_start":4782,"byte_end":4793,"line_start":121,"line_end":121,"column_start":28,"column_end":39,"is_primary":true,"text":[{"text":"            type Buffer = [MaybeUninit<u8>; $max_len];","highlight_start":28,"highlight_end":39}],"label":"not found in this scope","suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"C:\\Users\\ASUS\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\itoa-1.0.1\\src\\lib.rs","byte_start":7925,"byte_end":7985,"line_start":206,"line_end":206,"column_start":1,"column_end":61,"is_primary":false,"text":[{"text":"impl_Integer!(I64_MAX_LEN => i64, U64_MAX_LEN => u64 as u64);","highlight_start":1,"highlight_end":61}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"impl_Integer!","def_site_span":{"file_name":"C:\\Users\\ASUS\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\itoa-1.0.1\\src\\lib.rs","byte_start":4595,"byte_end":7512,"line_start":116,"line_end":186,"column_start":1,"column_end":2,"is_primary":false,"text":[{"text":"macro_rules! impl_Integer {","highlight_start":1,"highlight_end":28},{"text":"    ($($max_len:expr => $t:ident),* as $conv_fn:ident) => {$(","highlight_start":1,"highlight_end":62},{"text":"        impl Integer for $t {}","highlight_start":1,"highlight_end":31},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        impl private::Sealed for $t {","highlight_start":1,"highlight_end":38},{"text":"            type Buffer = [MaybeUninit<u8>; $max_len];","highlight_start":1,"highlight_end":55},{"text":"","highlight_start":1,"highlight_end":1},{"text":"            #[allow(unused_comparisons)]","highlight_start":1,"highlight_end":41},{"text":"            #[inline]","highlight_start":1,"highlight_end":22},{"text":"            fn write(self, buf: &mut [MaybeUninit<u8>; $max_len]) -> &str {","highlight_start":1,"highlight_end":76},{"text":"                let is_nonnegative = self >= 0;","highlight_start":1,"highlight_end":48},{"text":"                let mut n = if is_nonnegative {","highlight_start":1,"highlight_end":48},{"text":"                    self as $conv_fn","highlight_start":1,"highlight_end":37},{"text":"                } else {","highlight_start":1,"highlight_end":25},{"text":"                    // convert the negative num to positive by summing 1 to it's 2 complement","highlight_start":1,"highlight_end":94},{"text":"                    (!(self as $conv_fn)).wrapping_add(1)","highlight_start":1,"highlight_end":58},{"text":"                };","highlight_start":1,"highlight_end":19},{"text":"                let mut curr = buf.len() as isize;","highlight_start":1,"highlight_end":51},{"text":"                let buf_ptr = buf.as_mut_ptr() as *mut u8;","highlight_start":1,"highlight_end":59},{"text":"                let lut_ptr = DEC_DIGITS_LUT.as_ptr();","highlight_start":1,"highlight_end":55},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                unsafe {","highlight_start":1,"highlight_end":25},{"text":"                    // need at least 16 bits for the 4-characters-at-a-time to work.","highlight_start":1,"highlight_end":85},{"text":"                    if mem::size_of::<$t>() >= 2 {","highlight_start":1,"highlight_end":51},{"text":"                        // eagerly decode 4 characters at a time","highlight_start":1,"highlight_end":65},{"text":"                        while n >= 10000 {","highlight_start":1,"highlight_end":43},{"text":"                            let rem = (n % 10000) as isize;","highlight_start":1,"highlight_end":60},{"text":"                            n /= 10000;","highlight_start":1,"highlight_end":40},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                            let d1 = (rem / 100) << 1;","highlight_start":1,"highlight_end":55},{"text":"                            let d2 = (rem % 100) << 1;","highlight_start":1,"highlight_end":55},{"text":"                            curr -= 4;","highlight_start":1,"highlight_end":39},{"text":"                            ptr::copy_nonoverlapping(lut_ptr.offset(d1), buf_ptr.offset(curr), 2);","highlight_start":1,"highlight_end":99},{"text":"                            ptr::copy_nonoverlapping(lut_ptr.offset(d2), buf_ptr.offset(curr + 2), 2);","highlight_start":1,"highlight_end":103},{"text":"                        }","highlight_start":1,"highlight_end":26},{"text":"                    }","highlight_start":1,"highlight_end":22},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                    // if we reach here numbers are <= 9999, so at most 4 chars long","highlight_start":1,"highlight_end":85},{"text":"                    let mut n = n as isize; // possibly reduce 64bit math","highlight_start":1,"highlight_end":74},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                    // decode 2 more chars, if > 2 chars","highlight_start":1,"highlight_end":57},{"text":"                    if n >= 100 {","highlight_start":1,"highlight_end":34},{"text":"                        let d1 = (n % 100) << 1;","highlight_start":1,"highlight_end":49},{"text":"                        n /= 100;","highlight_start":1,"highlight_end":34},{"text":"                        curr -= 2;","highlight_start":1,"highlight_end":35},{"text":"                        ptr::copy_nonoverlapping(lut_ptr.offset(d1), buf_ptr.offset(curr), 2);","highlight_start":1,"highlight_end":95},{"text":"                    }","highlight_start":1,"highlight_end":22},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                    // decode last 1 or 2 chars","highlight_start":1,"highlight_end":48},{"text":"                    if n < 10 {","highlight_start":1,"highlight_end":32},{"text":"                        curr -= 1;","highlight_start":1,"highlight_end":35},{"text":"                        *buf_ptr.offset(curr) = (n as u8) + b'0';","highlight_start":1,"highlight_end":66},{"text":"                    } else {","highlight_start":1,"highlight_end":29},{"text":"                        let d1 = n << 1;","highlight_start":1,"highlight_end":41},{"text":"                        curr -= 2;","highlight_start":1,"highlight_end":35},{"text":"                        ptr::copy_nonoverlapping(lut_ptr.offset(d1), buf_ptr.offset(curr), 2);","highlight_start":1,"highlight_end":95},{"text":"                    }","highlight_start":1,"highlight_end":22},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                    if !is_nonnegative {","highlight_start":1,"highlight_end":41},{"text":"                        curr -= 1;","highlight_start":1,"highlight_end":35},{"text":"                        *buf_ptr.offset(curr) = b'-';","highlight_start":1,"highlight_end":54},{"text":"                    }","highlight_start":1,"highlight_end":22},{"text":"                }","highlight_start":1,"highlight_end":18},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                let len = buf.len() - curr as usize;","highlight_start":1,"highlight_end":53},{"text":"                let bytes = unsafe { slice::from_raw_parts(buf_ptr.offset(curr), len) };","highlight_start":1,"highlight_end":89},{"text":"                unsafe { str::from_utf8_unchecked(bytes) }","highlight_start":1,"highlight_end":59},{"text":"            }","highlight_start":1,"highlight_end":14},{"text":"        }","highlight_start":1,"highlight_end":10},{"text":"    )*};","highlight_start":1,"highlight_end":9},{"text":"}","highlight_start":1,"highlight_end":2}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}}],"children":[],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0412]\u001b[0m\u001b[0m\u001b[1m\u001b[38;5;15m: cannot find type `MaybeUninit` in this scope\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m--> \u001b[0m\u001b[0mC:\\Users\\ASUS\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\itoa-1.0.1\\src\\lib.rs:121:28\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14m121\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m| \u001b[0m\u001b[0m            type Buffer = [MaybeUninit<u8>; $max_len];\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m| \u001b[0m\u001b[0m                           \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9mnot found in this scope\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14m...\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14m206\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m| \u001b[0m\u001b[0mimpl_Integer!(I64_MAX_LEN => i64, U64_MAX_LEN => u64 as u64);\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m| \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m------------------------------------------------------------\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14min this macro invocation\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m= \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;15mnote\u001b[0m\u001b[0m: this error originates in the macro `impl_Integer` (in Nightly builds, run with -Z macro-backtrace for more info)\u001b[0m\n\n"}
{"message":"cannot find type `MaybeUninit` in this scope","code":{"code":"E0412","explanation":"A used type name is not in scope.\n\nErroneous code examples:\n\n```compile_fail,E0412\nimpl Something {} // error: type name `Something` is not in scope\n\n// or:\n\ntrait Foo {\n    fn bar(N); // error: type name `N` is not in scope\n}\n\n// or:\n\nfn foo(x: T) {} // type name `T` is not in scope\n```\n\nTo fix this error, please verify you didn't misspell the type name, you did\ndeclare it or imported it into the scope. Examples:\n\n```\nstruct Something;\n\nimpl Something {} // ok!\n\n// or:\n\ntrait Foo {\n    type N;\n\n    fn bar(_: Self::N); // ok!\n}\n\n// or:\n\nfn foo<T>(x: T) {} // ok!\n```\n\nAnother case that causes this error is when a type is imported into a parent\nmodule. To fix this, you can follow the suggestion and use File directly or\n`use super::File;` which will import the types from the parent namespace. An\nexample that causes this error is below:\n\n```compile_fail,E0412\nuse std::fs::File;\n\nmod foo {\n    fn some_function(f: File) {}\n}\n```\n\n```\nuse std::fs::File;\n\nmod foo {\n    // either\n    use super::File;\n    // or\n    // use std::fs::File;\n    fn foo(f: File) {}\n}\n# fn main() {} // don't insert it for us; that'll break imports\n```\n"},"level":"error","spans":[{"file_name":"C:\\Users\\ASUS\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\itoa-1.0.1\\src\\lib.rs","byte_start":4912,"byte_end":4923,"line_start":125,"line_end":125,"column_start":39,"column_end":50,"is_primary":true,"text":[{"text":"            fn write(self, buf: &mut [MaybeUninit<u8>; $max_len]) -> &str {","highlight_start":39,"highlight_end":50}],"label":"not found in this scope","suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"C:\\Users\\ASUS\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\itoa-1.0.1\\src\\lib.rs","byte_start":7925,"byte_end":7985,"line_start":206,"line_end":206,"column_start":1,"column_end":61,"is_primary":false,"text":[{"text":"impl_Integer!(I64_MAX_LEN => i64, U64_MAX_LEN => u64 as u64);","highlight_start":1,"highlight_end":61}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"impl_Integer!","def_site_span":{"file_name":"C:\\Users\\ASUS\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\itoa-1.0.1\\src\\lib.rs","byte_start":4595,"byte_end":7512,"line_start":116,"line_end":186,"column_start":1,"column_end":2,"is_primary":false,"text":[{"text":"macro_rules! impl_Integer {","highlight_start":1,"highlight_end":28},{"text":"    ($($max_len:expr => $t:ident),* as $conv_fn:ident) => {$(","highlight_start":1,"highlight_end":62},{"text":"        impl Integer for $t {}","highlight_start":1,"highlight_end":31},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        impl private::Sealed for $t {","highlight_start":1,"highlight_end":38},{"text":"            type Buffer = [MaybeUninit<u8>; $max_len];","highlight_start":1,"highlight_end":55},{"text":"","highlight_start":1,"highlight_end":1},{"text":"            #[allow(unused_comparisons)]","highlight_start":1,"highlight_end":41},{"text":"            #[inline]","highlight_start":1,"highlight_end":22},{"text":"            fn write(self, buf: &mut [MaybeUninit<u8>; $max_len]) -> &str {","highlight_start":1,"highlight_end":76},{"text":"                let is_nonnegative = self >= 0;","highlight_start":1,"highlight_end":48},{"text":"                let mut n = if is_nonnegative {","highlight_start":1,"highlight_end":48},{"text":"                    self as $conv_fn","highlight_start":1,"highlight_end":37},{"text":"                } else {","highlight_start":1,"highlight_end":25},{"text":"                    // convert the negative num to positive by summing 1 to it's 2 complement","highlight_start":1,"highlight_end":94},{"text":"                    (!(self as $conv_fn)).wrapping_add(1)","highlight_start":1,"highlight_end":58},{"text":"                };","highlight_start":1,"highlight_end":19},{"text":"                let mut curr = buf.len() as isize;","highlight_start":1,"highlight_end":51},{"text":"                let buf_ptr = buf.as_mut_ptr() as *mut u8;","highlight_start":1,"highlight_end":59},{"text":"                let lut_ptr = DEC_DIGITS_LUT.as_ptr();","highlight_start":1,"highlight_end":55},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                unsafe {","highlight_start":1,"highlight_end":25},{"text":"                    // need at least 16 bits for the 4-characters-at-a-time to work.","highlight_start":1,"highlight_end":85},{"text":"                    if mem::size_of::<$t>() >= 2 {","highlight_start":1,"highlight_end":51},{"text":"                        // eagerly decode 4 characters at a time","highlight_start":1,"highlight_end":65},{"text":"                        while n >= 10000 {","highlight_start":1,"highlight_end":43},{"text":"                            let rem = (n % 10000) as isize;","highlight_start":1,"highlight_end":60},{"text":"                            n /= 10000;","highlight_start":1,"highlight_end":40},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                            let d1 = (rem / 100) << 1;","highlight_start":1,"highlight_end":55},{"text":"                            let d2 = (rem % 100) << 1;","highlight_start":1,"highlight_end":55},{"text":"                            curr -= 4;","highlight_start":1,"highlight_end":39},{"text":"                            ptr::copy_nonoverlapping(lut_ptr.offset(d1), buf_ptr.offset(curr), 2);","highlight_start":1,"highlight_end":99},{"text":"                            ptr::copy_nonoverlapping(lut_ptr.offset(d2), buf_ptr.offset(curr + 2), 2);","highlight_start":1,"highlight_end":103},{"text":"                        }","highlight_start":1,"highlight_end":26},{"text":"                    }","highlight_start":1,"highlight_end":22},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                    // if we reach here numbers are <= 9999, so at most 4 chars long","highlight_start":1,"highlight_end":85},{"text":"                    let mut n = n as isize; // possibly reduce 64bit math","highlight_start":1,"highlight_end":74},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                    // decode 2 more chars, if > 2 chars","highlight_start":1,"highlight_end":57},{"text":"                    if n >= 100 {","highlight_start":1,"highlight_end":34},{"text":"                        let d1 = (n % 100) << 1;","highlight_start":1,"highlight_end":49},{"text":"                        n /= 100;","highlight_start":1,"highlight_end":34},{"text":"                        curr -= 2;","highlight_start":1,"highlight_end":35},{"text":"                        ptr::copy_nonoverlapping(lut_ptr.offset(d1), buf_ptr.offset(curr), 2);","highlight_start":1,"highlight_end":95},{"text":"                    }","highlight_start":1,"highlight_end":22},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                    // decode last 1 or 2 chars","highlight_start":1,"highlight_end":48},{"text":"                    if n < 10 {","highlight_start":1,"highlight_end":32},{"text":"                        curr -= 1;","highlight_start":1,"highlight_end":35},{"text":"                        *buf_ptr.offset(curr) = (n as u8) + b'0';","highlight_start":1,"highlight_end":66},{"text":"                    } else {","highlight_start":1,"highlight_end":29},{"text":"                        let d1 = n << 1;","highlight_start":1,"highlight_end":41},{"text":"                        curr -= 2;","highlight_start":1,"highlight_end":35},{"text":"                        ptr::copy_nonoverlapping(lut_ptr.offset(d1), buf_ptr.offset(curr), 2);","highlight_start":1,"highlight_end":95},{"text":"                    }","highlight_start":1,"highlight_end":22},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                    if !is_nonnegative {","highlight_start":1,"highlight_end":41},{"text":"                        curr -= 1;","highlight_start":1,"highlight_end":35},{"text":"                        *buf_ptr.offset(curr) = b'-';","highlight_start":1,"highlight_end":54},{"text":"                    }","highlight_start":1,"highlight_end":22},{"text":"                }","highlight_start":1,"highlight_end":18},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                let len = buf.len() - curr as usize;","highlight_start":1,"highlight_end":53},{"text":"                let bytes = unsafe { slice::from_raw_parts(buf_ptr.offset(curr), len) };","highlight_start":1,"highlight_end":89},{"text":"                unsafe { str::from_utf8_unchecked(bytes) }","highlight_start":1,"highlight_end":59},{"text":"            }","highlight_start":1,"highlight_end":14},{"text":"        }","highlight_start":1,"highlight_end":10},{"text":"    )*};","highlight_start":1,"highlight_end":9},{"text":"}","highlight_start":1,"highlight_end":2}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}}],"children":[],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0412]\u001b[0m\u001b[0m\u001b[1m\u001b[38;5;15m: cannot find type `MaybeUninit` in this scope\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m--> \u001b[0m\u001b[0mC:\\Users\\ASUS\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\itoa-1.0.1\\src\\lib.rs:125:39\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14m125\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m| \u001b[0m\u001b[0m            fn write(self, buf: &mut [MaybeUninit<u8>; $max_len]) -> &str {\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m| \u001b[0m\u001b[0m                                      \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9mnot found in this scope\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14m...\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14m206\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m| \u001b[0m\u001b[0mimpl_Integer!(I64_MAX_LEN => i64, U64_MAX_LEN => u64 as u64);\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m| \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m------------------------------------------------------------\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14min this macro invocation\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m= \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;15mnote\u001b[0m\u001b[0m: this error originates in the macro `impl_Integer` (in Nightly builds, run with -Z macro-backtrace for more info)\u001b[0m\n\n"}
{"message":"cannot find type `MaybeUninit` in this scope","code":{"code":"E0412","explanation":"A used type name is not in scope.\n\nErroneous code examples:\n\n```compile_fail,E0412\nimpl Something {} // error: type name `Something` is not in scope\n\n// or:\n\ntrait Foo {\n    fn bar(N); // error: type name `N` is not in scope\n}\n\n// or:\n\nfn foo(x: T) {} // type name `T` is not in scope\n```\n\nTo fix this error, please verify you didn't misspell the type name, you did\ndeclare it or imported it into the scope. Examples:\n\n```\nstruct Something;\n\nimpl Something {} // ok!\n\n// or:\n\ntrait Foo {\n    type N;\n\n    fn bar(_: Self::N); // ok!\n}\n\n// or:\n\nfn foo<T>(x: T) {} // ok!\n```\n\nAnother case that causes this error is when a type is imported into a parent\nmodule. To fix this, you can follow the suggestion and use File directly or\n`use super::File;` which will import the types from the parent namespace. An\nexample that causes this error is below:\n\n```compile_fail,E0412\nuse std::fs::File;\n\nmod foo {\n    fn some_function(f: File) {}\n}\n```\n\n```\nuse std::fs::File;\n\nmod foo {\n    // either\n    use super::File;\n    // or\n    // use std::fs::File;\n    fn foo(f: File) {}\n}\n# fn main() {} // don't insert it for us; that'll break imports\n```\n"},"level":"error","spans":[{"file_name":"C:\\Users\\ASUS\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\itoa-1.0.1\\src\\lib.rs","byte_start":4782,"byte_end":4793,"line_start":121,"line_end":121,"column_start":28,"column_end":39,"is_primary":true,"text":[{"text":"            type Buffer = [MaybeUninit<u8>; $max_len];","highlight_start":28,"highlight_end":39}],"label":"not found in this scope","suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"C:\\Users\\ASUS\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\itoa-1.0.1\\src\\lib.rs","byte_start":8127,"byte_end":8191,"line_start":212,"line_end":212,"column_start":1,"column_end":65,"is_primary":false,"text":[{"text":"impl_Integer!(I32_MAX_LEN => isize, U32_MAX_LEN => usize as u32);","highlight_start":1,"highlight_end":65}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"impl_Integer!","def_site_span":{"file_name":"C:\\Users\\ASUS\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\itoa-1.0.1\\src\\lib.rs","byte_start":4595,"byte_end":7512,"line_start":116,"line_end":186,"column_start":1,"column_end":2,"is_primary":false,"text":[{"text":"macro_rules! impl_Integer {","highlight_start":1,"highlight_end":28},{"text":"    ($($max_len:expr => $t:ident),* as $conv_fn:ident) => {$(","highlight_start":1,"highlight_end":62},{"text":"        impl Integer for $t {}","highlight_start":1,"highlight_end":31},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        impl private::Sealed for $t {","highlight_start":1,"highlight_end":38},{"text":"            type Buffer = [MaybeUninit<u8>; $max_len];","highlight_start":1,"highlight_end":55},{"text":"","highlight_start":1,"highlight_end":1},{"text":"            #[allow(unused_comparisons)]","highlight_start":1,"highlight_end":41},{"text":"            #[inline]","highlight_start":1,"highlight_end":22},{"text":"            fn write(self, buf: &mut [MaybeUninit<u8>; $max_len]) -> &str {","highlight_start":1,"highlight_end":76},{"text":"                let is_nonnegative = self >= 0;","highlight_start":1,"highlight_end":48},{"text":"                let mut n = if is_nonnegative {","highlight_start":1,"highlight_end":48},{"text":"                    self as $conv_fn","highlight_start":1,"highlight_end":37},{"text":"                } else {","highlight_start":1,"highlight_end":25},{"text":"                    // convert the negative num to positive by summing 1 to it's 2 complement","highlight_start":1,"highlight_end":94},{"text":"                    (!(self as $conv_fn)).wrapping_add(1)","highlight_start":1,"highlight_end":58},{"text":"                };","highlight_start":1,"highlight_end":19},{"text":"                let mut curr = buf.len() as isize;","highlight_start":1,"highlight_end":51},{"text":"                let buf_ptr = buf.as_mut_ptr() as *mut u8;","highlight_start":1,"highlight_end":59},{"text":"                let lut_ptr = DEC_DIGITS_LUT.as_ptr();","highlight_start":1,"highlight_end":55},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                unsafe {","highlight_start":1,"highlight_end":25},{"text":"                    // need at least 16 bits for the 4-characters-at-a-time to work.","highlight_start":1,"highlight_end":85},{"text":"                    if mem::size_of::<$t>() >= 2 {","highlight_start":1,"highlight_end":51},{"text":"                        // eagerly decode 4 characters at a time","highlight_start":1,"highlight_end":65},{"text":"                        while n >= 10000 {","highlight_start":1,"highlight_end":43},{"text":"                            let rem = (n % 10000) as isize;","highlight_start":1,"highlight_end":60},{"text":"                            n /= 10000;","highlight_start":1,"highlight_end":40},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                            let d1 = (rem / 100) << 1;","highlight_start":1,"highlight_end":55},{"text":"                            let d2 = (rem % 100) << 1;","highlight_start":1,"highlight_end":55},{"text":"                            curr -= 4;","highlight_start":1,"highlight_end":39},{"text":"                            ptr::copy_nonoverlapping(lut_ptr.offset(d1), buf_ptr.offset(curr), 2);","highlight_start":1,"highlight_end":99},{"text":"                            ptr::copy_nonoverlapping(lut_ptr.offset(d2), buf_ptr.offset(curr + 2), 2);","highlight_start":1,"highlight_end":103},{"text":"                        }","highlight_start":1,"highlight_end":26},{"text":"                    }","highlight_start":1,"highlight_end":22},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                    // if we reach here numbers are <= 9999, so at most 4 chars long","highlight_start":1,"highlight_end":85},{"text":"                    let mut n = n as isize; // possibly reduce 64bit math","highlight_start":1,"highlight_end":74},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                    // decode 2 more chars, if > 2 chars","highlight_start":1,"highlight_end":57},{"text":"                    if n >= 100 {","highlight_start":1,"highlight_end":34},{"text":"                        let d1 = (n % 100) << 1;","highlight_start":1,"highlight_end":49},{"text":"                        n /= 100;","highlight_start":1,"highlight_end":34},{"text":"                        curr -= 2;","highlight_start":1,"highlight_end":35},{"text":"                        ptr::copy_nonoverlapping(lut_ptr.offset(d1), buf_ptr.offset(curr), 2);","highlight_start":1,"highlight_end":95},{"text":"                    }","highlight_start":1,"highlight_end":22},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                    // decode last 1 or 2 chars","highlight_start":1,"highlight_end":48},{"text":"                    if n < 10 {","highlight_start":1,"highlight_end":32},{"text":"                        curr -= 1;","highlight_start":1,"highlight_end":35},{"text":"                        *buf_ptr.offset(curr) = (n as u8) + b'0';","highlight_start":1,"highlight_end":66},{"text":"                    } else {","highlight_start":1,"highlight_end":29},{"text":"                        let d1 = n << 1;","highlight_start":1,"highlight_end":41},{"text":"                        curr -= 2;","highlight_start":1,"highlight_end":35},{"text":"                        ptr::copy_nonoverlapping(lut_ptr.offset(d1), buf_ptr.offset(curr), 2);","highlight_start":1,"highlight_end":95},{"text":"                    }","highlight_start":1,"highlight_end":22},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                    if !is_nonnegative {","highlight_start":1,"highlight_end":41},{"text":"                        curr -= 1;","highlight_start":1,"highlight_end":35},{"text":"                        *buf_ptr.offset(curr) = b'-';","highlight_start":1,"highlight_end":54},{"text":"                    }","highlight_start":1,"highlight_end":22},{"text":"                }","highlight_start":1,"highlight_end":18},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                let len = buf.len() - curr as usize;","highlight_start":1,"highlight_end":53},{"text":"                let bytes = unsafe { slice::from_raw_parts(buf_ptr.offset(curr), len) };","highlight_start":1,"highlight_end":89},{"text":"                unsafe { str::from_utf8_unchecked(bytes) }","highlight_start":1,"highlight_end":59},{"text":"            }","highlight_start":1,"highlight_end":14},{"text":"        }","highlight_start":1,"highlight_end":10},{"text":"    )*};","highlight_start":1,"highlight_end":9},{"text":"}","highlight_start":1,"highlight_end":2}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}}],"children":[],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0412]\u001b[0m\u001b[0m\u001b[1m\u001b[38;5;15m: cannot find type `MaybeUninit` in this scope\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m--> \u001b[0m\u001b[0mC:\\Users\\ASUS\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\itoa-1.0.1\\src\\lib.rs:121:28\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14m121\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m| \u001b[0m\u001b[0m            type Buffer = [MaybeUninit<u8>; $max_len];\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m| \u001b[0m\u001b[0m                           \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9mnot found in this scope\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14m...\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14m212\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m| \u001b[0m\u001b[0mimpl_Integer!(I32_MAX_LEN => isize, U32_MAX_LEN => usize as u32);\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m| \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m----------------------------------------------------------------\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14min this macro invocation\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m= \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;15mnote\u001b[0m\u001b[0m: this error originates in the macro `impl_Integer` (in Nightly builds, run with -Z macro-backtrace for more info)\u001b[0m\n\n"}
{"message":"cannot find type `MaybeUninit` in this scope","code":{"code":"E0412","explanation":"A used type name is not in scope.\n\nErroneous code examples:\n\n```compile_fail,E0412\nimpl Something {} // error: type name `Something` is not in scope\n\n// or:\n\ntrait Foo {\n    fn bar(N); // error: type name `N` is not in scope\n}\n\n// or:\n\nfn foo(x: T) {} // type name `T` is not in scope\n```\n\nTo fix this error, please verify you didn't misspell the type name, you did\ndeclare it or imported it into the scope. Examples:\n\n```\nstruct Something;\n\nimpl Something {} // ok!\n\n// or:\n\ntrait Foo {\n    type N;\n\n    fn bar(_: Self::N); // ok!\n}\n\n// or:\n\nfn foo<T>(x: T) {} // ok!\n```\n\nAnother case that causes this error is when a type is imported into a parent\nmodule. To fix this, you can follow the suggestion and use File directly or\n`use super::File;` which will import the types from the parent namespace. An\nexample that causes this error is below:\n\n```compile_fail,E0412\nuse std::fs::File;\n\nmod foo {\n    fn some_function(f: File) {}\n}\n```\n\n```\nuse std::fs::File;\n\nmod foo {\n    // either\n    use super::File;\n    // or\n    // use std::fs::File;\n    fn foo(f: File) {}\n}\n# fn main() {} // don't insert it for us; that'll break imports\n```\n"},"level":"error","spans":[{"file_name":"C:\\Users\\ASUS\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\itoa-1.0.1\\src\\lib.rs","byte_start":4912,"byte_end":4923,"line_start":125,"line_end":125,"column_start":39,"column_end":50,"is_primary":true,"text":[{"text":"            fn write(self, buf: &mut [MaybeUninit<u8>; $max_len]) -> &str {","highlight_start":39,"highlight_end":50}],"label":"not found in this scope","suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"C:\\Users\\ASUS\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\itoa-1.0.1\\src\\lib.rs","byte_start":8127,"byte_end":8191,"line_start":212,"line_end":212,"column_start":1,"column_end":65,"is_primary":false,"text":[{"text":"impl_Integer!(I32_MAX_LEN => isize, U32_MAX_LEN => usize as u32);","highlight_start":1,"highlight_end":65}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"impl_Integer!","def_site_span":{"file_name":"C:\\Users\\ASUS\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\itoa-1.0.1\\src\\lib.rs","byte_start":4595,"byte_end":7512,"line_start":116,"line_end":186,"column_start":1,"column_end":2,"is_primary":false,"text":[{"text":"macro_rules! impl_Integer {","highlight_start":1,"highlight_end":28},{"text":"    ($($max_len:expr => $t:ident),* as $conv_fn:ident) => {$(","highlight_start":1,"highlight_end":62},{"text":"        impl Integer for $t {}","highlight_start":1,"highlight_end":31},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        impl private::Sealed for $t {","highlight_start":1,"highlight_end":38},{"text":"            type Buffer = [MaybeUninit<u8>; $max_len];","highlight_start":1,"highlight_end":55},{"text":"","highlight_start":1,"highlight_end":1},{"text":"            #[allow(unused_comparisons)]","highlight_start":1,"highlight_end":41},{"text":"            #[inline]","highlight_start":1,"highlight_end":22},{"text":"            fn write(self, buf: &mut [MaybeUninit<u8>; $max_len]) -> &str {","highlight_start":1,"highlight_end":76},{"text":"                let is_nonnegative = self >= 0;","highlight_start":1,"highlight_end":48},{"text":"                let mut n = if is_nonnegative {","highlight_start":1,"highlight_end":48},{"text":"                    self as $conv_fn","highlight_start":1,"highlight_end":37},{"text":"                } else {","highlight_start":1,"highlight_end":25},{"text":"                    // convert the negative num to positive by summing 1 to it's 2 complement","highlight_start":1,"highlight_end":94},{"text":"                    (!(self as $conv_fn)).wrapping_add(1)","highlight_start":1,"highlight_end":58},{"text":"                };","highlight_start":1,"highlight_end":19},{"text":"                let mut curr = buf.len() as isize;","highlight_start":1,"highlight_end":51},{"text":"                let buf_ptr = buf.as_mut_ptr() as *mut u8;","highlight_start":1,"highlight_end":59},{"text":"                let lut_ptr = DEC_DIGITS_LUT.as_ptr();","highlight_start":1,"highlight_end":55},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                unsafe {","highlight_start":1,"highlight_end":25},{"text":"                    // need at least 16 bits for the 4-characters-at-a-time to work.","highlight_start":1,"highlight_end":85},{"text":"                    if mem::size_of::<$t>() >= 2 {","highlight_start":1,"highlight_end":51},{"text":"                        // eagerly decode 4 characters at a time","highlight_start":1,"highlight_end":65},{"text":"                        while n >= 10000 {","highlight_start":1,"highlight_end":43},{"text":"                            let rem = (n % 10000) as isize;","highlight_start":1,"highlight_end":60},{"text":"                            n /= 10000;","highlight_start":1,"highlight_end":40},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                            let d1 = (rem / 100) << 1;","highlight_start":1,"highlight_end":55},{"text":"                            let d2 = (rem % 100) << 1;","highlight_start":1,"highlight_end":55},{"text":"                            curr -= 4;","highlight_start":1,"highlight_end":39},{"text":"                            ptr::copy_nonoverlapping(lut_ptr.offset(d1), buf_ptr.offset(curr), 2);","highlight_start":1,"highlight_end":99},{"text":"                            ptr::copy_nonoverlapping(lut_ptr.offset(d2), buf_ptr.offset(curr + 2), 2);","highlight_start":1,"highlight_end":103},{"text":"                        }","highlight_start":1,"highlight_end":26},{"text":"                    }","highlight_start":1,"highlight_end":22},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                    // if we reach here numbers are <= 9999, so at most 4 chars long","highlight_start":1,"highlight_end":85},{"text":"                    let mut n = n as isize; // possibly reduce 64bit math","highlight_start":1,"highlight_end":74},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                    // decode 2 more chars, if > 2 chars","highlight_start":1,"highlight_end":57},{"text":"                    if n >= 100 {","highlight_start":1,"highlight_end":34},{"text":"                        let d1 = (n % 100) << 1;","highlight_start":1,"highlight_end":49},{"text":"                        n /= 100;","highlight_start":1,"highlight_end":34},{"text":"                        curr -= 2;","highlight_start":1,"highlight_end":35},{"text":"                        ptr::copy_nonoverlapping(lut_ptr.offset(d1), buf_ptr.offset(curr), 2);","highlight_start":1,"highlight_end":95},{"text":"                    }","highlight_start":1,"highlight_end":22},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                    // decode last 1 or 2 chars","highlight_start":1,"highlight_end":48},{"text":"                    if n < 10 {","highlight_start":1,"highlight_end":32},{"text":"                        curr -= 1;","highlight_start":1,"highlight_end":35},{"text":"                        *buf_ptr.offset(curr) = (n as u8) + b'0';","highlight_start":1,"highlight_end":66},{"text":"                    } else {","highlight_start":1,"highlight_end":29},{"text":"                        let d1 = n << 1;","highlight_start":1,"highlight_end":41},{"text":"                        curr -= 2;","highlight_start":1,"highlight_end":35},{"text":"                        ptr::copy_nonoverlapping(lut_ptr.offset(d1), buf_ptr.offset(curr), 2);","highlight_start":1,"highlight_end":95},{"text":"                    }","highlight_start":1,"highlight_end":22},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                    if !is_nonnegative {","highlight_start":1,"highlight_end":41},{"text":"                        curr -= 1;","highlight_start":1,"highlight_end":35},{"text":"                        *buf_ptr.offset(curr) = b'-';","highlight_start":1,"highlight_end":54},{"text":"                    }","highlight_start":1,"highlight_end":22},{"text":"                }","highlight_start":1,"highlight_end":18},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                let len = buf.len() - curr as usize;","highlight_start":1,"highlight_end":53},{"text":"                let bytes = unsafe { slice::from_raw_parts(buf_ptr.offset(curr), len) };","highlight_start":1,"highlight_end":89},{"text":"                unsafe { str::from_utf8_unchecked(bytes) }","highlight_start":1,"highlight_end":59},{"text":"            }","highlight_start":1,"highlight_end":14},{"text":"        }","highlight_start":1,"highlight_end":10},{"text":"    )*};","highlight_start":1,"highlight_end":9},{"text":"}","highlight_start":1,"highlight_end":2}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}}],"children":[],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0412]\u001b[0m\u001b[0m\u001b[1m\u001b[38;5;15m: cannot find type `MaybeUninit` in this scope\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m--> \u001b[0m\u001b[0mC:\\Users\\ASUS\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\itoa-1.0.1\\src\\lib.rs:125:39\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14m125\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m| \u001b[0m\u001b[0m            fn write(self, buf: &mut [MaybeUninit<u8>; $max_len]) -> &str {\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m| \u001b[0m\u001b[0m                                      \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9mnot found in this scope\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14m...\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14m212\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m| \u001b[0m\u001b[0mimpl_Integer!(I32_MAX_LEN => isize, U32_MAX_LEN => usize as u32);\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m| \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m----------------------------------------------------------------\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14min this macro invocation\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m= \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;15mnote\u001b[0m\u001b[0m: this error originates in the macro `impl_Integer` (in Nightly builds, run with -Z macro-backtrace for more info)\u001b[0m\n\n"}
{"message":"cannot find type `MaybeUninit` in this scope","code":{"code":"E0412","explanation":"A used type name is not in scope.\n\nErroneous code examples:\n\n```compile_fail,E0412\nimpl Something {} // error: type name `Something` is not in scope\n\n// or:\n\ntrait Foo {\n    fn bar(N); // error: type name `N` is not in scope\n}\n\n// or:\n\nfn foo(x: T) {} // type name `T` is not in scope\n```\n\nTo fix this error, please verify you didn't misspell the type name, you did\ndeclare it or imported it into the scope. Examples:\n\n```\nstruct Something;\n\nimpl Something {} // ok!\n\n// or:\n\ntrait Foo {\n    type N;\n\n    fn bar(_: Self::N); // ok!\n}\n\n// or:\n\nfn foo<T>(x: T) {} // ok!\n```\n\nAnother case that causes this error is when a type is imported into a parent\nmodule. To fix this, you can follow the suggestion and use File directly or\n`use super::File;` which will import the types from the parent namespace. An\nexample that causes this error is below:\n\n```compile_fail,E0412\nuse std::fs::File;\n\nmod foo {\n    fn some_function(f: File) {}\n}\n```\n\n```\nuse std::fs::File;\n\nmod foo {\n    // either\n    use super::File;\n    // or\n    // use std::fs::File;\n    fn foo(f: File) {}\n}\n# fn main() {} // don't insert it for us; that'll break imports\n```\n"},"level":"error","spans":[{"file_name":"C:\\Users\\ASUS\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\itoa-1.0.1\\src\\lib.rs","byte_start":8469,"byte_end":8480,"line_start":222,"line_end":222,"column_start":28,"column_end":39,"is_primary":true,"text":[{"text":"            type Buffer = [MaybeUninit<u8>; $max_len];","highlight_start":28,"highlight_end":39}],"label":"not found in this scope","suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"C:\\Users\\ASUS\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\itoa-1.0.1\\src\\lib.rs","byte_start":11079,"byte_end":11139,"line_start":284,"line_end":284,"column_start":1,"column_end":61,"is_primary":false,"text":[{"text":"impl_Integer128!(I128_MAX_LEN => i128, U128_MAX_LEN => u128);","highlight_start":1,"highlight_end":61}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"impl_Integer128!","def_site_span":{"file_name":"C:\\Users\\ASUS\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\itoa-1.0.1\\src\\lib.rs","byte_start":8297,"byte_end":11012,"line_start":217,"line_end":279,"column_start":1,"column_end":2,"is_primary":false,"text":[{"text":"macro_rules! impl_Integer128 {","highlight_start":1,"highlight_end":31},{"text":"    ($($max_len:expr => $t:ident),*) => {$(","highlight_start":1,"highlight_end":44},{"text":"        impl Integer for $t {}","highlight_start":1,"highlight_end":31},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        impl private::Sealed for $t {","highlight_start":1,"highlight_end":38},{"text":"            type Buffer = [MaybeUninit<u8>; $max_len];","highlight_start":1,"highlight_end":55},{"text":"","highlight_start":1,"highlight_end":1},{"text":"            #[allow(unused_comparisons)]","highlight_start":1,"highlight_end":41},{"text":"            #[inline]","highlight_start":1,"highlight_end":22},{"text":"            fn write(self, buf: &mut [MaybeUninit<u8>; $max_len]) -> &str {","highlight_start":1,"highlight_end":76},{"text":"                let is_nonnegative = self >= 0;","highlight_start":1,"highlight_end":48},{"text":"                let n = if is_nonnegative {","highlight_start":1,"highlight_end":44},{"text":"                    self as u128","highlight_start":1,"highlight_end":33},{"text":"                } else {","highlight_start":1,"highlight_end":25},{"text":"                    // convert the negative num to positive by summing 1 to it's 2 complement","highlight_start":1,"highlight_end":94},{"text":"                    (!(self as u128)).wrapping_add(1)","highlight_start":1,"highlight_end":54},{"text":"                };","highlight_start":1,"highlight_end":19},{"text":"                let mut curr = buf.len() as isize;","highlight_start":1,"highlight_end":51},{"text":"                let buf_ptr = buf.as_mut_ptr() as *mut u8;","highlight_start":1,"highlight_end":59},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                unsafe {","highlight_start":1,"highlight_end":25},{"text":"                    // Divide by 10^19 which is the highest power less than 2^64.","highlight_start":1,"highlight_end":82},{"text":"                    let (n, rem) = udiv128::udivmod_1e19(n);","highlight_start":1,"highlight_end":61},{"text":"                    let buf1 = buf_ptr.offset(curr - U64_MAX_LEN as isize) as *mut [MaybeUninit<u8>; U64_MAX_LEN];","highlight_start":1,"highlight_end":115},{"text":"                    curr -= rem.write(&mut *buf1).len() as isize;","highlight_start":1,"highlight_end":66},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                    if n != 0 {","highlight_start":1,"highlight_end":32},{"text":"                        // Memset the base10 leading zeros of rem.","highlight_start":1,"highlight_end":67},{"text":"                        let target = buf.len() as isize - 19;","highlight_start":1,"highlight_end":62},{"text":"                        ptr::write_bytes(buf_ptr.offset(target), b'0', (curr - target) as usize);","highlight_start":1,"highlight_end":98},{"text":"                        curr = target;","highlight_start":1,"highlight_end":39},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                        // Divide by 10^19 again.","highlight_start":1,"highlight_end":50},{"text":"                        let (n, rem) = udiv128::udivmod_1e19(n);","highlight_start":1,"highlight_end":65},{"text":"                        let buf2 = buf_ptr.offset(curr - U64_MAX_LEN as isize) as *mut [MaybeUninit<u8>; U64_MAX_LEN];","highlight_start":1,"highlight_end":119},{"text":"                        curr -= rem.write(&mut *buf2).len() as isize;","highlight_start":1,"highlight_end":70},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                        if n != 0 {","highlight_start":1,"highlight_end":36},{"text":"                            // Memset the leading zeros.","highlight_start":1,"highlight_end":57},{"text":"                            let target = buf.len() as isize - 38;","highlight_start":1,"highlight_end":66},{"text":"                            ptr::write_bytes(buf_ptr.offset(target), b'0', (curr - target) as usize);","highlight_start":1,"highlight_end":102},{"text":"                            curr = target;","highlight_start":1,"highlight_end":43},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                            // There is at most one digit left","highlight_start":1,"highlight_end":63},{"text":"                            // because u128::max / 10^19 / 10^19 is 3.","highlight_start":1,"highlight_end":71},{"text":"                            curr -= 1;","highlight_start":1,"highlight_end":39},{"text":"                            *buf_ptr.offset(curr) = (n as u8) + b'0';","highlight_start":1,"highlight_end":70},{"text":"                        }","highlight_start":1,"highlight_end":26},{"text":"                    }","highlight_start":1,"highlight_end":22},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                    if !is_nonnegative {","highlight_start":1,"highlight_end":41},{"text":"                        curr -= 1;","highlight_start":1,"highlight_end":35},{"text":"                        *buf_ptr.offset(curr) = b'-';","highlight_start":1,"highlight_end":54},{"text":"                    }","highlight_start":1,"highlight_end":22},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                    let len = buf.len() - curr as usize;","highlight_start":1,"highlight_end":57},{"text":"                    let bytes = slice::from_raw_parts(buf_ptr.offset(curr), len);","highlight_start":1,"highlight_end":82},{"text":"                    str::from_utf8_unchecked(bytes)","highlight_start":1,"highlight_end":52},{"text":"                }","highlight_start":1,"highlight_end":18},{"text":"            }","highlight_start":1,"highlight_end":14},{"text":"        }","highlight_start":1,"highlight_end":10},{"text":"    )*};","highlight_start":1,"highlight_end":9},{"text":"}","highlight_start":1,"highlight_end":2}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}}],"children":[],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0412]\u001b[0m\u001b[0m\u001b[1m\u001b[38;5;15m: cannot find type `MaybeUninit` in this scope\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m--> \u001b[0m\u001b[0mC:\\Users\\ASUS\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\itoa-1.0.1\\src\\lib.rs:222:28\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14m222\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m| \u001b[0m\u001b[0m            type Buffer = [MaybeUninit<u8>; $max_len];\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m| \u001b[0m\u001b[0m                           \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9mnot found in this scope\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14m...\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14m284\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m| \u001b[0m\u001b[0mimpl_Integer128!(I128_MAX_LEN => i128, U128_MAX_LEN => u128);\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m| \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m------------------------------------------------------------\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14min this macro invocation\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m= \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;15mnote\u001b[0m\u001b[0m: this error originates in the macro `impl_Integer128` (in Nightly builds, run with -Z macro-backtrace for more info)\u001b[0m\n\n"}
{"message":"cannot find type `MaybeUninit` in this scope","code":{"code":"E0412","explanation":"A used type name is not in scope.\n\nErroneous code examples:\n\n```compile_fail,E0412\nimpl Something {} // error: type name `Something` is not in scope\n\n// or:\n\ntrait Foo {\n    fn bar(N); // error: type name `N` is not in scope\n}\n\n// or:\n\nfn foo(x: T) {} // type name `T` is not in scope\n```\n\nTo fix this error, please verify you didn't misspell the type name, you did\ndeclare it or imported it into the scope. Examples:\n\n```\nstruct Something;\n\nimpl Something {} // ok!\n\n// or:\n\ntrait Foo {\n    type N;\n\n    fn bar(_: Self::N); // ok!\n}\n\n// or:\n\nfn foo<T>(x: T) {} // ok!\n```\n\nAnother case that causes this error is when a type is imported into a parent\nmodule. To fix this, you can follow the suggestion and use File directly or\n`use super::File;` which will import the types from the parent namespace. An\nexample that causes this error is below:\n\n```compile_fail,E0412\nuse std::fs::File;\n\nmod foo {\n    fn some_function(f: File) {}\n}\n```\n\n```\nuse std::fs::File;\n\nmod foo {\n    // either\n    use super::File;\n    // or\n    // use std::fs::File;\n    fn foo(f: File) {}\n}\n# fn main() {} // don't insert it for us; that'll break imports\n```\n"},"level":"error","spans":[{"file_name":"C:\\Users\\ASUS\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\itoa-1.0.1\\src\\lib.rs","byte_start":8599,"byte_end":8610,"line_start":226,"line_end":226,"column_start":39,"column_end":50,"is_primary":true,"text":[{"text":"            fn write(self, buf: &mut [MaybeUninit<u8>; $max_len]) -> &str {","highlight_start":39,"highlight_end":50}],"label":"not found in this scope","suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"C:\\Users\\ASUS\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\itoa-1.0.1\\src\\lib.rs","byte_start":11079,"byte_end":11139,"line_start":284,"line_end":284,"column_start":1,"column_end":61,"is_primary":false,"text":[{"text":"impl_Integer128!(I128_MAX_LEN => i128, U128_MAX_LEN => u128);","highlight_start":1,"highlight_end":61}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"impl_Integer128!","def_site_span":{"file_name":"C:\\Users\\ASUS\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\itoa-1.0.1\\src\\lib.rs","byte_start":8297,"byte_end":11012,"line_start":217,"line_end":279,"column_start":1,"column_end":2,"is_primary":false,"text":[{"text":"macro_rules! impl_Integer128 {","highlight_start":1,"highlight_end":31},{"text":"    ($($max_len:expr => $t:ident),*) => {$(","highlight_start":1,"highlight_end":44},{"text":"        impl Integer for $t {}","highlight_start":1,"highlight_end":31},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        impl private::Sealed for $t {","highlight_start":1,"highlight_end":38},{"text":"            type Buffer = [MaybeUninit<u8>; $max_len];","highlight_start":1,"highlight_end":55},{"text":"","highlight_start":1,"highlight_end":1},{"text":"            #[allow(unused_comparisons)]","highlight_start":1,"highlight_end":41},{"text":"            #[inline]","highlight_start":1,"highlight_end":22},{"text":"            fn write(self, buf: &mut [MaybeUninit<u8>; $max_len]) -> &str {","highlight_start":1,"highlight_end":76},{"text":"                let is_nonnegative = self >= 0;","highlight_start":1,"highlight_end":48},{"text":"                let n = if is_nonnegative {","highlight_start":1,"highlight_end":44},{"text":"                    self as u128","highlight_start":1,"highlight_end":33},{"text":"                } else {","highlight_start":1,"highlight_end":25},{"text":"                    // convert the negative num to positive by summing 1 to it's 2 complement","highlight_start":1,"highlight_end":94},{"text":"                    (!(self as u128)).wrapping_add(1)","highlight_start":1,"highlight_end":54},{"text":"                };","highlight_start":1,"highlight_end":19},{"text":"                let mut curr = buf.len() as isize;","highlight_start":1,"highlight_end":51},{"text":"                let buf_ptr = buf.as_mut_ptr() as *mut u8;","highlight_start":1,"highlight_end":59},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                unsafe {","highlight_start":1,"highlight_end":25},{"text":"                    // Divide by 10^19 which is the highest power less than 2^64.","highlight_start":1,"highlight_end":82},{"text":"                    let (n, rem) = udiv128::udivmod_1e19(n);","highlight_start":1,"highlight_end":61},{"text":"                    let buf1 = buf_ptr.offset(curr - U64_MAX_LEN as isize) as *mut [MaybeUninit<u8>; U64_MAX_LEN];","highlight_start":1,"highlight_end":115},{"text":"                    curr -= rem.write(&mut *buf1).len() as isize;","highlight_start":1,"highlight_end":66},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                    if n != 0 {","highlight_start":1,"highlight_end":32},{"text":"                        // Memset the base10 leading zeros of rem.","highlight_start":1,"highlight_end":67},{"text":"                        let target = buf.len() as isize - 19;","highlight_start":1,"highlight_end":62},{"text":"                        ptr::write_bytes(buf_ptr.offset(target), b'0', (curr - target) as usize);","highlight_start":1,"highlight_end":98},{"text":"                        curr = target;","highlight_start":1,"highlight_end":39},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                        // Divide by 10^19 again.","highlight_start":1,"highlight_end":50},{"text":"                        let (n, rem) = udiv128::udivmod_1e19(n);","highlight_start":1,"highlight_end":65},{"text":"                        let buf2 = buf_ptr.offset(curr - U64_MAX_LEN as isize) as *mut [MaybeUninit<u8>; U64_MAX_LEN];","highlight_start":1,"highlight_end":119},{"text":"                        curr -= rem.write(&mut *buf2).len() as isize;","highlight_start":1,"highlight_end":70},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                        if n != 0 {","highlight_start":1,"highlight_end":36},{"text":"                            // Memset the leading zeros.","highlight_start":1,"highlight_end":57},{"text":"                            let target = buf.len() as isize - 38;","highlight_start":1,"highlight_end":66},{"text":"                            ptr::write_bytes(buf_ptr.offset(target), b'0', (curr - target) as usize);","highlight_start":1,"highlight_end":102},{"text":"                            curr = target;","highlight_start":1,"highlight_end":43},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                            // There is at most one digit left","highlight_start":1,"highlight_end":63},{"text":"                            // because u128::max / 10^19 / 10^19 is 3.","highlight_start":1,"highlight_end":71},{"text":"                            curr -= 1;","highlight_start":1,"highlight_end":39},{"text":"                            *buf_ptr.offset(curr) = (n as u8) + b'0';","highlight_start":1,"highlight_end":70},{"text":"                        }","highlight_start":1,"highlight_end":26},{"text":"                    }","highlight_start":1,"highlight_end":22},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                    if !is_nonnegative {","highlight_start":1,"highlight_end":41},{"text":"                        curr -= 1;","highlight_start":1,"highlight_end":35},{"text":"                        *buf_ptr.offset(curr) = b'-';","highlight_start":1,"highlight_end":54},{"text":"                    }","highlight_start":1,"highlight_end":22},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                    let len = buf.len() - curr as usize;","highlight_start":1,"highlight_end":57},{"text":"                    let bytes = slice::from_raw_parts(buf_ptr.offset(curr), len);","highlight_start":1,"highlight_end":82},{"text":"                    str::from_utf8_unchecked(bytes)","highlight_start":1,"highlight_end":52},{"text":"                }","highlight_start":1,"highlight_end":18},{"text":"            }","highlight_start":1,"highlight_end":14},{"text":"        }","highlight_start":1,"highlight_end":10},{"text":"    )*};","highlight_start":1,"highlight_end":9},{"text":"}","highlight_start":1,"highlight_end":2}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}}],"children":[],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0412]\u001b[0m\u001b[0m\u001b[1m\u001b[38;5;15m: cannot find type `MaybeUninit` in this scope\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m--> \u001b[0m\u001b[0mC:\\Users\\ASUS\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\itoa-1.0.1\\src\\lib.rs:226:39\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14m226\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m| \u001b[0m\u001b[0m            fn write(self, buf: &mut [MaybeUninit<u8>; $max_len]) -> &str {\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m| \u001b[0m\u001b[0m                                      \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9mnot found in this scope\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14m...\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14m284\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m| \u001b[0m\u001b[0mimpl_Integer128!(I128_MAX_LEN => i128, U128_MAX_LEN => u128);\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m| \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m------------------------------------------------------------\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14min this macro invocation\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m= \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;15mnote\u001b[0m\u001b[0m: this error originates in the macro `impl_Integer128` (in Nightly builds, run with -Z macro-backtrace for more info)\u001b[0m\n\n"}
{"message":"cannot find type `MaybeUninit` in this scope","code":{"code":"E0412","explanation":"A used type name is not in scope.\n\nErroneous code examples:\n\n```compile_fail,E0412\nimpl Something {} // error: type name `Something` is not in scope\n\n// or:\n\ntrait Foo {\n    fn bar(N); // error: type name `N` is not in scope\n}\n\n// or:\n\nfn foo(x: T) {} // type name `T` is not in scope\n```\n\nTo fix this error, please verify you didn't misspell the type name, you did\ndeclare it or imported it into the scope. Examples:\n\n```\nstruct Something;\n\nimpl Something {} // ok!\n\n// or:\n\ntrait Foo {\n    type N;\n\n    fn bar(_: Self::N); // ok!\n}\n\n// or:\n\nfn foo<T>(x: T) {} // ok!\n```\n\nAnother case that causes this error is when a type is imported into a parent\nmodule. To fix this, you can follow the suggestion and use File directly or\n`use super::File;` which will import the types from the parent namespace. An\nexample that causes this error is below:\n\n```compile_fail,E0412\nuse std::fs::File;\n\nmod foo {\n    fn some_function(f: File) {}\n}\n```\n\n```\nuse std::fs::File;\n\nmod foo {\n    // either\n    use super::File;\n    // or\n    // use std::fs::File;\n    fn foo(f: File) {}\n}\n# fn main() {} // don't insert it for us; that'll break imports\n```\n"},"level":"error","spans":[{"file_name":"C:\\Users\\ASUS\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\itoa-1.0.1\\src\\lib.rs","byte_start":9317,"byte_end":9328,"line_start":240,"line_end":240,"column_start":85,"column_end":96,"is_primary":true,"text":[{"text":"                    let buf1 = buf_ptr.offset(curr - U64_MAX_LEN as isize) as *mut [MaybeUninit<u8>; U64_MAX_LEN];","highlight_start":85,"highlight_end":96}],"label":"not found in this scope","suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"C:\\Users\\ASUS\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\itoa-1.0.1\\src\\lib.rs","byte_start":11079,"byte_end":11139,"line_start":284,"line_end":284,"column_start":1,"column_end":61,"is_primary":false,"text":[{"text":"impl_Integer128!(I128_MAX_LEN => i128, U128_MAX_LEN => u128);","highlight_start":1,"highlight_end":61}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"impl_Integer128!","def_site_span":{"file_name":"C:\\Users\\ASUS\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\itoa-1.0.1\\src\\lib.rs","byte_start":8297,"byte_end":11012,"line_start":217,"line_end":279,"column_start":1,"column_end":2,"is_primary":false,"text":[{"text":"macro_rules! impl_Integer128 {","highlight_start":1,"highlight_end":31},{"text":"    ($($max_len:expr => $t:ident),*) => {$(","highlight_start":1,"highlight_end":44},{"text":"        impl Integer for $t {}","highlight_start":1,"highlight_end":31},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        impl private::Sealed for $t {","highlight_start":1,"highlight_end":38},{"text":"            type Buffer = [MaybeUninit<u8>; $max_len];","highlight_start":1,"highlight_end":55},{"text":"","highlight_start":1,"highlight_end":1},{"text":"            #[allow(unused_comparisons)]","highlight_start":1,"highlight_end":41},{"text":"            #[inline]","highlight_start":1,"highlight_end":22},{"text":"            fn write(self, buf: &mut [MaybeUninit<u8>; $max_len]) -> &str {","highlight_start":1,"highlight_end":76},{"text":"                let is_nonnegative = self >= 0;","highlight_start":1,"highlight_end":48},{"text":"                let n = if is_nonnegative {","highlight_start":1,"highlight_end":44},{"text":"                    self as u128","highlight_start":1,"highlight_end":33},{"text":"                } else {","highlight_start":1,"highlight_end":25},{"text":"                    // convert the negative num to positive by summing 1 to it's 2 complement","highlight_start":1,"highlight_end":94},{"text":"                    (!(self as u128)).wrapping_add(1)","highlight_start":1,"highlight_end":54},{"text":"                };","highlight_start":1,"highlight_end":19},{"text":"                let mut curr = buf.len() as isize;","highlight_start":1,"highlight_end":51},{"text":"                let buf_ptr = buf.as_mut_ptr() as *mut u8;","highlight_start":1,"highlight_end":59},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                unsafe {","highlight_start":1,"highlight_end":25},{"text":"                    // Divide by 10^19 which is the highest power less than 2^64.","highlight_start":1,"highlight_end":82},{"text":"                    let (n, rem) = udiv128::udivmod_1e19(n);","highlight_start":1,"highlight_end":61},{"text":"                    let buf1 = buf_ptr.offset(curr - U64_MAX_LEN as isize) as *mut [MaybeUninit<u8>; U64_MAX_LEN];","highlight_start":1,"highlight_end":115},{"text":"                    curr -= rem.write(&mut *buf1).len() as isize;","highlight_start":1,"highlight_end":66},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                    if n != 0 {","highlight_start":1,"highlight_end":32},{"text":"                        // Memset the base10 leading zeros of rem.","highlight_start":1,"highlight_end":67},{"text":"                        let target = buf.len() as isize - 19;","highlight_start":1,"highlight_end":62},{"text":"                        ptr::write_bytes(buf_ptr.offset(target), b'0', (curr - target) as usize);","highlight_start":1,"highlight_end":98},{"text":"                        curr = target;","highlight_start":1,"highlight_end":39},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                        // Divide by 10^19 again.","highlight_start":1,"highlight_end":50},{"text":"                        let (n, rem) = udiv128::udivmod_1e19(n);","highlight_start":1,"highlight_end":65},{"text":"                        let buf2 = buf_ptr.offset(curr - U64_MAX_LEN as isize) as *mut [MaybeUninit<u8>; U64_MAX_LEN];","highlight_start":1,"highlight_end":119},{"text":"                        curr -= rem.write(&mut *buf2).len() as isize;","highlight_start":1,"highlight_end":70},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                        if n != 0 {","highlight_start":1,"highlight_end":36},{"text":"                            // Memset the leading zeros.","highlight_start":1,"highlight_end":57},{"text":"                            let target = buf.len() as isize - 38;","highlight_start":1,"highlight_end":66},{"text":"                            ptr::write_bytes(buf_ptr.offset(target), b'0', (curr - target) as usize);","highlight_start":1,"highlight_end":102},{"text":"                            curr = target;","highlight_start":1,"highlight_end":43},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                            // There is at most one digit left","highlight_start":1,"highlight_end":63},{"text":"                            // because u128::max / 10^19 / 10^19 is 3.","highlight_start":1,"highlight_end":71},{"text":"                            curr -= 1;","highlight_start":1,"highlight_end":39},{"text":"                            *buf_ptr.offset(curr) = (n as u8) + b'0';","highlight_start":1,"highlight_end":70},{"text":"                        }","highlight_start":1,"highlight_end":26},{"text":"                    }","highlight_start":1,"highlight_end":22},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                    if !is_nonnegative {","highlight_start":1,"highlight_end":41},{"text":"                        curr -= 1;","highlight_start":1,"highlight_end":35},{"text":"                        *buf_ptr.offset(curr) = b'-';","highlight_start":1,"highlight_end":54},{"text":"                    }","highlight_start":1,"highlight_end":22},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                    let len = buf.len() - curr as usize;","highlight_start":1,"highlight_end":57},{"text":"                    let bytes = slice::from_raw_parts(buf_ptr.offset(curr), len);","highlight_start":1,"highlight_end":82},{"text":"                    str::from_utf8_unchecked(bytes)","highlight_start":1,"highlight_end":52},{"text":"                }","highlight_start":1,"highlight_end":18},{"text":"            }","highlight_start":1,"highlight_end":14},{"text":"        }","highlight_start":1,"highlight_end":10},{"text":"    )*};","highlight_start":1,"highlight_end":9},{"text":"}","highlight_start":1,"highlight_end":2}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}}],"children":[],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0412]\u001b[0m\u001b[0m\u001b[1m\u001b[38;5;15m: cannot find type `MaybeUninit` in this scope\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m--> \u001b[0m\u001b[0mC:\\Users\\ASUS\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\itoa-1.0.1\\src\\lib.rs:240:85\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14m240\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m| \u001b[0m\u001b[0m                    let buf1 = buf_ptr.offset(curr - U64_MAX_LEN as isize) as *mut [MaybeUninit<u8>; U64_MAX_LEN];\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m| \u001b[0m\u001b[0m                                                                                    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9mnot found in this scope\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14m...\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14m284\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m| \u001b[0m\u001b[0mimpl_Integer128!(I128_MAX_LEN => i128, U128_MAX_LEN => u128);\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m| \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m------------------------------------------------------------\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14min this macro invocation\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m= \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;15mnote\u001b[0m\u001b[0m: this error originates in the macro `impl_Integer128` (in Nightly builds, run with -Z macro-backtrace for more info)\u001b[0m\n\n"}
{"message":"cannot find type `MaybeUninit` in this scope","code":{"code":"E0412","explanation":"A used type name is not in scope.\n\nErroneous code examples:\n\n```compile_fail,E0412\nimpl Something {} // error: type name `Something` is not in scope\n\n// or:\n\ntrait Foo {\n    fn bar(N); // error: type name `N` is not in scope\n}\n\n// or:\n\nfn foo(x: T) {} // type name `T` is not in scope\n```\n\nTo fix this error, please verify you didn't misspell the type name, you did\ndeclare it or imported it into the scope. Examples:\n\n```\nstruct Something;\n\nimpl Something {} // ok!\n\n// or:\n\ntrait Foo {\n    type N;\n\n    fn bar(_: Self::N); // ok!\n}\n\n// or:\n\nfn foo<T>(x: T) {} // ok!\n```\n\nAnother case that causes this error is when a type is imported into a parent\nmodule. To fix this, you can follow the suggestion and use File directly or\n`use super::File;` which will import the types from the parent namespace. An\nexample that causes this error is below:\n\n```compile_fail,E0412\nuse std::fs::File;\n\nmod foo {\n    fn some_function(f: File) {}\n}\n```\n\n```\nuse std::fs::File;\n\nmod foo {\n    // either\n    use super::File;\n    // or\n    // use std::fs::File;\n    fn foo(f: File) {}\n}\n# fn main() {} // don't insert it for us; that'll break imports\n```\n"},"level":"error","spans":[{"file_name":"C:\\Users\\ASUS\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\itoa-1.0.1\\src\\lib.rs","byte_start":9917,"byte_end":9928,"line_start":251,"line_end":251,"column_start":89,"column_end":100,"is_primary":true,"text":[{"text":"                        let buf2 = buf_ptr.offset(curr - U64_MAX_LEN as isize) as *mut [MaybeUninit<u8>; U64_MAX_LEN];","highlight_start":89,"highlight_end":100}],"label":"not found in this scope","suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"C:\\Users\\ASUS\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\itoa-1.0.1\\src\\lib.rs","byte_start":11079,"byte_end":11139,"line_start":284,"line_end":284,"column_start":1,"column_end":61,"is_primary":false,"text":[{"text":"impl_Integer128!(I128_MAX_LEN => i128, U128_MAX_LEN => u128);","highlight_start":1,"highlight_end":61}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"impl_Integer128!","def_site_span":{"file_name":"C:\\Users\\ASUS\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\itoa-1.0.1\\src\\lib.rs","byte_start":8297,"byte_end":11012,"line_start":217,"line_end":279,"column_start":1,"column_end":2,"is_primary":false,"text":[{"text":"macro_rules! impl_Integer128 {","highlight_start":1,"highlight_end":31},{"text":"    ($($max_len:expr => $t:ident),*) => {$(","highlight_start":1,"highlight_end":44},{"text":"        impl Integer for $t {}","highlight_start":1,"highlight_end":31},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        impl private::Sealed for $t {","highlight_start":1,"highlight_end":38},{"text":"            type Buffer = [MaybeUninit<u8>; $max_len];","highlight_start":1,"highlight_end":55},{"text":"","highlight_start":1,"highlight_end":1},{"text":"            #[allow(unused_comparisons)]","highlight_start":1,"highlight_end":41},{"text":"            #[inline]","highlight_start":1,"highlight_end":22},{"text":"            fn write(self, buf: &mut [MaybeUninit<u8>; $max_len]) -> &str {","highlight_start":1,"highlight_end":76},{"text":"                let is_nonnegative = self >= 0;","highlight_start":1,"highlight_end":48},{"text":"                let n = if is_nonnegative {","highlight_start":1,"highlight_end":44},{"text":"                    self as u128","highlight_start":1,"highlight_end":33},{"text":"                } else {","highlight_start":1,"highlight_end":25},{"text":"                    // convert the negative num to positive by summing 1 to it's 2 complement","highlight_start":1,"highlight_end":94},{"text":"                    (!(self as u128)).wrapping_add(1)","highlight_start":1,"highlight_end":54},{"text":"                };","highlight_start":1,"highlight_end":19},{"text":"                let mut curr = buf.len() as isize;","highlight_start":1,"highlight_end":51},{"text":"                let buf_ptr = buf.as_mut_ptr() as *mut u8;","highlight_start":1,"highlight_end":59},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                unsafe {","highlight_start":1,"highlight_end":25},{"text":"                    // Divide by 10^19 which is the highest power less than 2^64.","highlight_start":1,"highlight_end":82},{"text":"                    let (n, rem) = udiv128::udivmod_1e19(n);","highlight_start":1,"highlight_end":61},{"text":"                    let buf1 = buf_ptr.offset(curr - U64_MAX_LEN as isize) as *mut [MaybeUninit<u8>; U64_MAX_LEN];","highlight_start":1,"highlight_end":115},{"text":"                    curr -= rem.write(&mut *buf1).len() as isize;","highlight_start":1,"highlight_end":66},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                    if n != 0 {","highlight_start":1,"highlight_end":32},{"text":"                        // Memset the base10 leading zeros of rem.","highlight_start":1,"highlight_end":67},{"text":"                        let target = buf.len() as isize - 19;","highlight_start":1,"highlight_end":62},{"text":"                        ptr::write_bytes(buf_ptr.offset(target), b'0', (curr - target) as usize);","highlight_start":1,"highlight_end":98},{"text":"                        curr = target;","highlight_start":1,"highlight_end":39},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                        // Divide by 10^19 again.","highlight_start":1,"highlight_end":50},{"text":"                        let (n, rem) = udiv128::udivmod_1e19(n);","highlight_start":1,"highlight_end":65},{"text":"                        let buf2 = buf_ptr.offset(curr - U64_MAX_LEN as isize) as *mut [MaybeUninit<u8>; U64_MAX_LEN];","highlight_start":1,"highlight_end":119},{"text":"                        curr -= rem.write(&mut *buf2).len() as isize;","highlight_start":1,"highlight_end":70},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                        if n != 0 {","highlight_start":1,"highlight_end":36},{"text":"                            // Memset the leading zeros.","highlight_start":1,"highlight_end":57},{"text":"                            let target = buf.len() as isize - 38;","highlight_start":1,"highlight_end":66},{"text":"                            ptr::write_bytes(buf_ptr.offset(target), b'0', (curr - target) as usize);","highlight_start":1,"highlight_end":102},{"text":"                            curr = target;","highlight_start":1,"highlight_end":43},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                            // There is at most one digit left","highlight_start":1,"highlight_end":63},{"text":"                            // because u128::max / 10^19 / 10^19 is 3.","highlight_start":1,"highlight_end":71},{"text":"                            curr -= 1;","highlight_start":1,"highlight_end":39},{"text":"                            *buf_ptr.offset(curr) = (n as u8) + b'0';","highlight_start":1,"highlight_end":70},{"text":"                        }","highlight_start":1,"highlight_end":26},{"text":"                    }","highlight_start":1,"highlight_end":22},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                    if !is_nonnegative {","highlight_start":1,"highlight_end":41},{"text":"                        curr -= 1;","highlight_start":1,"highlight_end":35},{"text":"                        *buf_ptr.offset(curr) = b'-';","highlight_start":1,"highlight_end":54},{"text":"                    }","highlight_start":1,"highlight_end":22},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                    let len = buf.len() - curr as usize;","highlight_start":1,"highlight_end":57},{"text":"                    let bytes = slice::from_raw_parts(buf_ptr.offset(curr), len);","highlight_start":1,"highlight_end":82},{"text":"                    str::from_utf8_unchecked(bytes)","highlight_start":1,"highlight_end":52},{"text":"                }","highlight_start":1,"highlight_end":18},{"text":"            }","highlight_start":1,"highlight_end":14},{"text":"        }","highlight_start":1,"highlight_end":10},{"text":"    )*};","highlight_start":1,"highlight_end":9},{"text":"}","highlight_start":1,"highlight_end":2}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}}],"children":[],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0412]\u001b[0m\u001b[0m\u001b[1m\u001b[38;5;15m: cannot find type `MaybeUninit` in this scope\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m--> \u001b[0m\u001b[0mC:\\Users\\ASUS\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\itoa-1.0.1\\src\\lib.rs:251:89\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14m251\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m| \u001b[0m\u001b[0m                        let buf2 = buf_ptr.offset(curr - U64_MAX_LEN as isize) as *mut [MaybeUninit<u8>; U64_MAX_LEN];\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m| \u001b[0m\u001b[0m                                                                                        \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9mnot found in this scope\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14m...\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14m284\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m| \u001b[0m\u001b[0mimpl_Integer128!(I128_MAX_LEN => i128, U128_MAX_LEN => u128);\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m| \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m------------------------------------------------------------\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14min this macro invocation\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m= \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;15mnote\u001b[0m\u001b[0m: this error originates in the macro `impl_Integer128` (in Nightly builds, run with -Z macro-backtrace for more info)\u001b[0m\n\n"}
{"message":"aborting due to 43 previous errors","code":null,"level":"error","spans":[],"children":[],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror\u001b[0m\u001b[0m\u001b[1m\u001b[38;5;15m: aborting due to 43 previous errors\u001b[0m\n\n"}
{"message":"Some errors have detailed explanations: E0405, E0412, E0433, E0463.","code":null,"level":"failure-note","spans":[],"children":[],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;15mSome errors have detailed explanations: E0405, E0412, E0433, E0463.\u001b[0m\n"}
{"message":"For more information about an error, try `rustc --explain E0405`.","code":null,"level":"failure-note","spans":[],"children":[],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;15mFor more information about an error, try `rustc --explain E0405`.\u001b[0m\n"}
